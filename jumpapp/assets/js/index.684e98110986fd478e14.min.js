/******/ (() => { // webpackBootstrap
/******/ 	var __webpack_modules__ = ({

/***/ "./jumpapp/assets/js/src/classes/Clock.js":
/*!************************************************!*\
  !*** ./jumpapp/assets/js/src/classes/Clock.js ***!
  \************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ Clock)
/* harmony export */ });
/**
 * Calculate the time, local to the requested location from
 * the OpenWeather API, by passing in the number of seconds
 * that location has shifted from UTC based on the timezones.
 *
 * @author Dale Davies <dale@daledavies.co.uk>
 * @license MIT
 */

class Clock {
    /**
     * Calculate the time shifted from UTC.
     *
     * @param boolean ampm Return 12 hour format if true.
     * @param number utcshift Number of seconds to shift time from UTC.
     */
    constructor(eventemitter, ampm = false, forcelocaltime = false) {
        this.set_utc_shift();
        this.contentintervalid = null;
        this.eventemitter = eventemitter;
        this.ampm = ampm;
        this.forcelocaltime = forcelocaltime;
    }

    set_utc_shift(newutcshift = 0) {
        this.utcshift = newutcshift;
        this.shiftedtimestamp = new Date().getTime()+this.utcshift;
        this.shifteddate = new Date(this.shiftedtimestamp);
    }

    /**
     * Return a formatted string representing time for display in template.
     *
     * @returns string The time string.
     */
    get_formatted_time() {
        // We need to use getUTCHours and getUTC Minutes here to stop
        // the Date() object adjusting the returned time relative to the
        // browser's local timezone.
        let hour = this.shifteddate.getUTCHours();
        let minutes = String(this.shifteddate.getUTCMinutes()).padStart(2, '0');

        // Completely ignore the shifted date and just return whatever happens to be
        // in the local timezone.
        if (this.forcelocaltime) {
            hour = new Date().getHours();
            minutes = String(new Date().getMinutes()).padStart(2, '0');
        }

        if (!this.ampm) {
            return String(hour).padStart(2, '0') + ":" + minutes;
        }
        // Convert to 12 hour AM/PM format and return.
        const suffix = hour <= 12 ? 'AM':'PM';
        hour = ((hour + 11) % 12 + 1);
        return hour + ':' + minutes + '<span>' + suffix + '</span>';
    }

    /**
     * Returns just the hour.
     *
     * @returns number The hour.
     */
    get_hour() {
        if (this.forcelocaltime) {
            return new Date().getHours();
        }
        return this.shifteddate.getUTCHours();
    }

    update_time() {
        this.set_utc_shift(this.utcshift);
        this.eventemitter.emit('clock-updated', {
            formatted_time: this.get_formatted_time(),
            hour: this.get_hour(),
            utcshift: this.utcshift
        });
    }

    run(updatefrequency) {
        // Clear any previously set intervals for updating content.
        if (this.contentintervalid) {
            clearInterval(this.contentintervalid);
        }
        // Set the clock and greeting text appropriately for the requested location.
        this.update_time();
        // Update the content periodically, we don't need to be too frequent as we are
        // not displaying seconds on the clock.
        this.contentintervalid = setInterval(() => {
            this.update_time();
        }, updatefrequency);
    }

}


/***/ }),

/***/ "./jumpapp/assets/js/src/classes/Greeting.js":
/*!***************************************************!*\
  !*** ./jumpapp/assets/js/src/classes/Greeting.js ***!
  \***************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ Greeting)
/* harmony export */ });
/* harmony import */ var _Clock__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Clock */ "./jumpapp/assets/js/src/classes/Clock.js");


class Greeting {

    constructor(hour) {
        this.hour = hour;
        this.greetings = {
            0  : 'morning',
            12 : 'afternoon',
            16 : 'evening',
            19 : 'night'
        };
    }

    get_greeting() {
        let keys = Object.keys(this.greetings).reverse();
        for (let element of keys) {
            if (this.hour >= element) {
                return this.greetings[element];
            }
        };
    }

}


/***/ }),

/***/ "./jumpapp/assets/js/src/classes/Main.js":
/*!***********************************************!*\
  !*** ./jumpapp/assets/js/src/classes/Main.js ***!
  \***********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ Main)
/* harmony export */ });
/* harmony import */ var _Clock__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Clock */ "./jumpapp/assets/js/src/classes/Clock.js");
/* harmony import */ var eventemitter3__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! eventemitter3 */ "./node_modules/eventemitter3/index.js");
/* harmony import */ var eventemitter3__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(eventemitter3__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var fuse_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! fuse.js */ "./node_modules/fuse.js/dist/fuse.esm.js");
/* harmony import */ var _Greeting__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./Greeting */ "./jumpapp/assets/js/src/classes/Greeting.js");
/* harmony import */ var _SearchSuggestions__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./SearchSuggestions */ "./jumpapp/assets/js/src/classes/SearchSuggestions.js");
/* harmony import */ var _Weather__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./Weather */ "./jumpapp/assets/js/src/classes/Weather.js");







class Main {

    constructor() {
        this.latlong = [];
        this.storage = window.localStorage;
        this.clockfrequency = 10000; // 10 seconds.
        this.weatherfrequency = 300000; // 5 minutes.
        this.timezoneshift = 0;
        this.metrictemp = JUMP.metrictemp;
        // Cache some DOM elements that we will access frequently.
        this.greetingelm = document.querySelector('.greeting .chosen');
        this.holderelm = document.querySelector('.time-weather');
        this.tempelm = this.holderelm.querySelector('.weather-info .temp');
        this.weatherdescelm = this.holderelm.querySelector('.weather-info .desc');
        this.timeelm = this.holderelm.querySelector('.time');
        this.weatherelm = this.holderelm.querySelector('.weather');
        this.weathericonelm = this.holderelm.querySelector('.weather-icon');
        this.clientlocationelm = document.querySelector('.useclientlocation');
        this.showtagsbuttonelm = document.querySelector('.show-tags');
        this.tagselectorelm = document.querySelector('.tags');
        this.tagsselectorclosebuttonelm = document.querySelector('.tags .close');
        this.showsearchbuttonelm = document.querySelector('.search');
        // If the user has previously asked for geolocation we will have stored the latlong.
        if (this.lastrequestedlocation = this.storage.getItem('lastrequestedlocation')){
            this.latlong = JSON.parse(this.lastrequestedlocation);
        }
        // Finally create instances of the classes we'll be using.
        this.eventemitter = new (eventemitter3__WEBPACK_IMPORTED_MODULE_1___default())();
        this.clock = new _Clock__WEBPACK_IMPORTED_MODULE_0__["default"](this.eventemitter, !!JUMP.ampmclock, !JUMP.owmapikey);
        this.weather = new _Weather__WEBPACK_IMPORTED_MODULE_4__["default"](this.eventemitter);

        if (this.showsearchbuttonelm) {
            this.searchclosebuttonelm = this.showsearchbuttonelm.querySelector('.close');
            this.fuse = new fuse_js__WEBPACK_IMPORTED_MODULE_5__["default"](JSON.parse(JUMP.search), {
                threshold: 0.3,
                keys: ['name', 'tags']
            });
        }
    }

    /**
     * Get data from OWM and do stuff with it.
     */
    init() {
        // Let's display some images from unsplash then shall we...
        if (JUMP.unsplash) {
            const backgroundelm = document.querySelector('.background');
            if (JUMP.unsplashcolor) {
                backgroundelm.style.backgroundColor = JUMP.unsplashcolor;
            }
            fetch(JUMP.wwwurl + '/api/unsplash/' + JUMP.token + '/')
            .then(response => response.json())
            .then(data => {
                if (data.error) {
                    console.error('JUMP ERROR: There was an issue with the Unsplash API... ' + data.error);
                    return;
                }
                backgroundelm.style.backgroundImage = 'url("' + data.imagedatauri + '")';
                document.querySelector('.unsplash').innerHTML = data.attribution;
            });
        }

        // Start listening for events so we can do stuff when needed.
        this.add_event_listeners();
        // If there is no OWM API key provided then just update the greeting
        // and clock, otherwise we can go get the weather data and set everything
        // up properly.
        if (!JUMP.owmapikey) {
            this.eventemitter.emit('show-content');
            return;
        }
        // Retrieve weather and timezone data from Open Weather Map API.
        this.weather.fetch_owm_data(this.latlong);
        setInterval(() => {
            this.weather.fetch_owm_data(this.latlong);
        }, this.weatherfrequency);
    }

    /**
     * Umm... adds event listeners
     */
    add_event_listeners() {
        this.eventemitter.on('weather-loaded', owmdata => {
            // Update the timezone shift from UTC to whatever it should be for the
            // requested location, then tell the greeting and clock to update.
            this.timezoneshift = owmdata.timezoneshift;
            // Display the weather icon, link to the requested location in OWM
            // and update location name element.
            this.weatherelm.href = 'https://openweathermap.org/city/' + owmdata.locationcode;
            this.weathericonelm.classList.add(owmdata.iconclass);
            this.clientlocationelm.innerHTML = owmdata.locationname;
            this.tempelm.innerHTML = owmdata.temp;
            this.weatherdescelm.innerHTML = owmdata.description;
            this.clientlocationelm.classList.add('enable');
            this.eventemitter.emit('show-content');
        });

        this.eventemitter.on('clock-updated', clockdata => {
            if (this.timeelm != null) {
                this.timeelm.innerHTML = clockdata.formatted_time;
            }
            if (this.greetingelm != null) {
                let greeting = new _Greeting__WEBPACK_IMPORTED_MODULE_2__["default"](clockdata.hour);
                this.greetingelm.innerHTML = greeting.get_greeting();
            }
        });

        this.eventemitter.on('show-content', () => {
            this.set_clock();
            this.show_content();
        });

        // Should someone click on the location button then request their location
        // from the client and store it, then refetch weather data to update the page.
        this.clientlocationelm.addEventListener('click', e => {
            navigator.geolocation.getCurrentPosition(position => {
                this.latlong = [position.coords.latitude, position.coords.longitude];
                this.storage.setItem('lastrequestedlocation', JSON.stringify(this.latlong));
                this.weather.fetch_owm_data(this.latlong);
            },
            error => {
                console.error(error.message);
            },
            {enableHighAccuracy: true});
        });

        if (this.showtagsbuttonelm) {
            this.showtagsbuttonelm.addEventListener('click', e => {
                this.tagselectorelm.classList.add('enable');
                e.preventDefault();
            });
        }

        if (this.tagsselectorclosebuttonelm) {
            this.tagsselectorclosebuttonelm.addEventListener('click', e => {
                this.tagselectorelm.classList.remove('enable');
            });
        }

        if (this.showsearchbuttonelm) {
            const searchinput = document.querySelector('.search-form input');
            this.searchsuggestions = new _SearchSuggestions__WEBPACK_IMPORTED_MODULE_3__["default"](JSON.parse(JUMP.searchengines), searchinput, this.showsearchbuttonelm, this.eventemitter);

            // When the search icon is licked, show the search bar and focus on it.
            this.showsearchbuttonelm.addEventListener('click', e => {
                if (!e.target.classList.contains('open')) {
                    this.showsearchbuttonelm.classList.add('open');
                    searchinput.focus();
                }
            });

            // Listen for CTRL+/ key combo and open search bar.
            document.addEventListener('keyup', e => {
                if (e.ctrlKey && e.shiftKey && e.code == 'Slash') {
                    if (!this.showsearchbuttonelm.classList.contains('open')) {
                        this.showsearchbuttonelm.classList.add('open');
                        searchinput.focus();
                    } else {
                        this.search_close();
                    }
                }
            });

            // Handle the close button.
            this.searchclosebuttonelm.addEventListener('click', e => {
                e.stopPropagation();
                this.search_close();
            });

            // Listen for key events triggered by the searh bar and do stuff.
            searchinput.addEventListener('keyup', e => {
                // On arrow down, focus on the first search suggestion.
                let suggestionslist = document.querySelector('.suggestion-list .searchproviders');
                if (e.code === 'ArrowDown') {
                    if (suggestionslist && suggestionslist.childNodes.length) {
                        suggestionslist.firstChild.firstChild.focus();
                    }
                    return;
                }
                // Perform search, limit number of results, create new array containing only what
                // we need and finally display the suggestions on the page.
                let results = [];
                let siteresults = this.fuse.search(searchinput.value);
                siteresults.length = 8;
                if (siteresults.length > 0) {
                    siteresults.forEach((result) => {
                        results.push(result.item);
                    });
                }
                this.searchsuggestions.replace(results);
            });

            // If someone presses enter then open up the first link, this is the default seach engine
            // purely because it is at the top of the list.
            document.querySelector('.search-form').addEventListener('submit', e => {
                e.preventDefault();
                if (searchinput.value != '') {
                    document.querySelector('.searchproviders li a').click();
                }
            });
        }
    }

    search_close() {
        let suggestions = this.showsearchbuttonelm.querySelector('.suggestionholder');
        if (suggestions) {
            suggestions.remove();
        }
        this.showsearchbuttonelm.classList.remove('suggestions');
        document.querySelector('.search').classList.remove('open');
        document.querySelector('.search-form input').value = '';
    }

    /**
     * Once everything is set up we can remove the .hidden class to display content
     * on the page to stop things jumping around between the initial page load
     * and JS rendering.
     */
    show_content() {
        document.querySelectorAll('.hidden').forEach(function(element){
            element.classList.remove('hidden');
        });
    }

    set_clock() {
        this.clock.set_utc_shift(this.timezoneshift);
        this.clock.run(this.clockfrequency);
    }

}


/***/ }),

/***/ "./jumpapp/assets/js/src/classes/SearchSuggestions.js":
/*!************************************************************!*\
  !*** ./jumpapp/assets/js/src/classes/SearchSuggestions.js ***!
  \************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ SearchSuggestions)
/* harmony export */ });
/**
 * Generate search suggestions.
 *
 * @author Dale Davies <dale@daledavies.co.uk>
 * @license MIT
 */

class SearchSuggestions {

    constructor(searchengines, inputelm, containerelm, eventemitter) {
        this.containerelm = containerelm;
        this.eventemitter = eventemitter;
        this.inputelm = inputelm;
        this.suggestionslistelm = containerelm.querySelector('.suggestion-list');
        this.searchproviderlist = null;
        this.searchengines = searchengines;
    }

    build_searchprovider_list_elm(query) {
        const searchproviderlist = document.createElement('ul');
        searchproviderlist.classList.add('searchproviders');
        searchproviderlist.setAttribute('tabindex', -1);
        this.searchengines.forEach((provider) => {
            const searchprovider = document.createElement('li');
            searchprovider.setAttribute('tabindex', -1);
            searchprovider.innerHTML = '<a target="_blank" rel="noopener" \
                href="'+provider.url+encodeURIComponent(query)+'"><span>Search on</span> '+provider.name+'</a>';
            searchproviderlist.appendChild(searchprovider);
        });
        searchproviderlist.addEventListener('keyup', e => {
            switch (e.code) {
                case 'ArrowUp':
                    if (document.activeElement == e.target.parentNode.parentNode.firstChild.firstChild) {
                        this.inputelm.focus();
                        break;
                    }
                    document.activeElement.parentNode.previousSibling.firstChild.focus();
                    break;
                case 'ArrowDown':
                    if (document.activeElement == e.target.parentNode.parentNode.lastChild.firstChild) {
                        const suggestionselm = document.querySelector('.suggestionholder .suggestions');
                        if (suggestionselm) {
                            suggestionselm.firstChild.firstChild.focus();
                        } else {
                            e.target.parentNode.parentNode.firstChild.firstChild.focus();
                        }
                        break;
                    }
                    document.activeElement.parentNode.nextSibling.firstChild.focus();
                    break;
            }
        });
        return searchproviderlist;
    }

    build_suggestion_list_elm(siteresults) {
        const suggestionslist = document.createElement('ul');
        suggestionslist.classList.add('suggestions');
        suggestionslist.setAttribute('tabindex', -1);
        siteresults.forEach((result) => {
            const resultitem = document.createElement('li');
            resultitem.setAttribute('tabindex', -1);
            resultitem.innerHTML = '<a target="_blank" rel="noopener" href="'+result.url+'">\
                <img class="icon" src="'+result.iconurl+'"><span class="name">'+result.name+'</span>';
            suggestionslist.appendChild(resultitem);
        });
        suggestionslist.addEventListener('keyup', e => {
            switch (e.code) {
                case 'ArrowUp':
                    if (document.activeElement == e.target.parentNode.parentNode.firstChild.firstChild) {
                        this.searchproviderlist.lastChild.firstChild.focus();
                        break;
                    }
                    document.activeElement.parentNode.previousSibling.firstChild.focus();
                    break;
                case 'ArrowDown':
                    if (document.activeElement == e.target.parentNode.parentNode.lastChild.firstChild) {
                        this.searchproviderlist.firstChild.firstChild.focus();
                        break;
                    }
                    document.activeElement.parentNode.nextSibling.firstChild.focus();
                    break;
            }
        });
        return suggestionslist;
    }

    replace(siteresults) {
        const newsuggestionslist = this.build_suggestion_list_elm(siteresults);

        const suggestionholder = document.createElement('span');
        suggestionholder.classList.add('suggestionholder');

        if (this.inputelm.value !== '') {
            const searchtitle = document.createElement('span');
            searchtitle.classList.add('suggestiontitle');
            searchtitle.innerHTML = 'Search';
            suggestionholder.appendChild(searchtitle);
            this.searchproviderlist = this.build_searchprovider_list_elm(this.inputelm.value);
            suggestionholder.appendChild(this.searchproviderlist);
        }

        if (newsuggestionslist.childNodes.length > 0) {
            const suggestiontitle = document.createElement('span');
            suggestiontitle.classList.add('suggestiontitle');
            suggestiontitle.innerHTML = 'Sites';
            suggestionholder.appendChild(suggestiontitle);
            suggestionholder.appendChild(newsuggestionslist)
        }

        if (suggestionholder.childNodes.length > 0) {
            this.containerelm.classList.add('suggestions');
            this.suggestionslistelm.replaceChildren(suggestionholder);
        } else {
            this.containerelm.classList.remove('suggestions');
            let suggestions = this.containerelm.querySelector('.suggestionholder');
            if (suggestions) {
                suggestions.remove();
            }
        }
    }
}


/***/ }),

/***/ "./jumpapp/assets/js/src/classes/Weather.js":
/*!**************************************************!*\
  !*** ./jumpapp/assets/js/src/classes/Weather.js ***!
  \**************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ Weather)
/* harmony export */ });
class Weather {

    /**
     * Responsible for retrieveing weather data from OWM and doing
     * stuff with it.
     *
     * @param {string} latlong Comma separated string representing a lattitude and longitude.
     */
    constructor(eventemitter) {
        this.eventemitter = eventemitter;
    }

    /**
     * Make an async request to the weather API, parse and return the response.
     */
    fetch_owm_data(latlong) {
        // If we are provided with a latlong then the user must have cliecked on the location
        // button at some point, so let's use this in the api url...
        let apiurl = JUMP.wwwurl + '/api/weather/' + JUMP.token + '/';
        if (latlong.length) {
            apiurl += (latlong[0] + '/' + latlong[1] + '/');
        }
        // Get some data from the weather api...
        fetch(apiurl)
        .then(response => response.json())
        .then(data => {
            if (data.error) {
                console.error('JUMP ERROR: There was an issue with the OWM API... ' + data.error);
                return;
            }
            if (data.cod === 401) {
                console.error('JUMP ERROR: The OWM API key is invalid, check config.php');
                return;
            }
            // Determine if we should use the day or night variant of our weather icon.
            var daynightvariant = 'night';
            if (data.dt > data.sys.sunrise && data.dt < data.sys.sunset) {
                daynightvariant = 'day'
            }
            this.eventemitter.emit('weather-loaded', {
                locationcode: data.id,
                locationname: data.name,
                temp: Math.ceil(data.main.temp) + '&deg;' + (JUMP.metrictemp ? 'C' : 'F'),
                description: data.weather[0].main,
                iconclass: 'wi-owm-' + daynightvariant + '-' + data.weather[0].id,
                timezoneshift: data.timezone*1000,
            });
        })
    }

}


/***/ }),

/***/ "./node_modules/eventemitter3/index.js":
/*!*********************************************!*\
  !*** ./node_modules/eventemitter3/index.js ***!
  \*********************************************/
/***/ ((module) => {

"use strict";


var has = Object.prototype.hasOwnProperty
  , prefix = '~';

/**
 * Constructor to create a storage for our `EE` objects.
 * An `Events` instance is a plain object whose properties are event names.
 *
 * @constructor
 * @private
 */
function Events() {}

//
// We try to not inherit from `Object.prototype`. In some engines creating an
// instance in this way is faster than calling `Object.create(null)` directly.
// If `Object.create(null)` is not supported we prefix the event names with a
// character to make sure that the built-in object properties are not
// overridden or used as an attack vector.
//
if (Object.create) {
  Events.prototype = Object.create(null);

  //
  // This hack is needed because the `__proto__` property is still inherited in
  // some old browsers like Android 4, iPhone 5.1, Opera 11 and Safari 5.
  //
  if (!new Events().__proto__) prefix = false;
}

/**
 * Representation of a single event listener.
 *
 * @param {Function} fn The listener function.
 * @param {*} context The context to invoke the listener with.
 * @param {Boolean} [once=false] Specify if the listener is a one-time listener.
 * @constructor
 * @private
 */
function EE(fn, context, once) {
  this.fn = fn;
  this.context = context;
  this.once = once || false;
}

/**
 * Add a listener for a given event.
 *
 * @param {EventEmitter} emitter Reference to the `EventEmitter` instance.
 * @param {(String|Symbol)} event The event name.
 * @param {Function} fn The listener function.
 * @param {*} context The context to invoke the listener with.
 * @param {Boolean} once Specify if the listener is a one-time listener.
 * @returns {EventEmitter}
 * @private
 */
function addListener(emitter, event, fn, context, once) {
  if (typeof fn !== 'function') {
    throw new TypeError('The listener must be a function');
  }

  var listener = new EE(fn, context || emitter, once)
    , evt = prefix ? prefix + event : event;

  if (!emitter._events[evt]) emitter._events[evt] = listener, emitter._eventsCount++;
  else if (!emitter._events[evt].fn) emitter._events[evt].push(listener);
  else emitter._events[evt] = [emitter._events[evt], listener];

  return emitter;
}

/**
 * Clear event by name.
 *
 * @param {EventEmitter} emitter Reference to the `EventEmitter` instance.
 * @param {(String|Symbol)} evt The Event name.
 * @private
 */
function clearEvent(emitter, evt) {
  if (--emitter._eventsCount === 0) emitter._events = new Events();
  else delete emitter._events[evt];
}

/**
 * Minimal `EventEmitter` interface that is molded against the Node.js
 * `EventEmitter` interface.
 *
 * @constructor
 * @public
 */
function EventEmitter() {
  this._events = new Events();
  this._eventsCount = 0;
}

/**
 * Return an array listing the events for which the emitter has registered
 * listeners.
 *
 * @returns {Array}
 * @public
 */
EventEmitter.prototype.eventNames = function eventNames() {
  var names = []
    , events
    , name;

  if (this._eventsCount === 0) return names;

  for (name in (events = this._events)) {
    if (has.call(events, name)) names.push(prefix ? name.slice(1) : name);
  }

  if (Object.getOwnPropertySymbols) {
    return names.concat(Object.getOwnPropertySymbols(events));
  }

  return names;
};

/**
 * Return the listeners registered for a given event.
 *
 * @param {(String|Symbol)} event The event name.
 * @returns {Array} The registered listeners.
 * @public
 */
EventEmitter.prototype.listeners = function listeners(event) {
  var evt = prefix ? prefix + event : event
    , handlers = this._events[evt];

  if (!handlers) return [];
  if (handlers.fn) return [handlers.fn];

  for (var i = 0, l = handlers.length, ee = new Array(l); i < l; i++) {
    ee[i] = handlers[i].fn;
  }

  return ee;
};

/**
 * Return the number of listeners listening to a given event.
 *
 * @param {(String|Symbol)} event The event name.
 * @returns {Number} The number of listeners.
 * @public
 */
EventEmitter.prototype.listenerCount = function listenerCount(event) {
  var evt = prefix ? prefix + event : event
    , listeners = this._events[evt];

  if (!listeners) return 0;
  if (listeners.fn) return 1;
  return listeners.length;
};

/**
 * Calls each of the listeners registered for a given event.
 *
 * @param {(String|Symbol)} event The event name.
 * @returns {Boolean} `true` if the event had listeners, else `false`.
 * @public
 */
EventEmitter.prototype.emit = function emit(event, a1, a2, a3, a4, a5) {
  var evt = prefix ? prefix + event : event;

  if (!this._events[evt]) return false;

  var listeners = this._events[evt]
    , len = arguments.length
    , args
    , i;

  if (listeners.fn) {
    if (listeners.once) this.removeListener(event, listeners.fn, undefined, true);

    switch (len) {
      case 1: return listeners.fn.call(listeners.context), true;
      case 2: return listeners.fn.call(listeners.context, a1), true;
      case 3: return listeners.fn.call(listeners.context, a1, a2), true;
      case 4: return listeners.fn.call(listeners.context, a1, a2, a3), true;
      case 5: return listeners.fn.call(listeners.context, a1, a2, a3, a4), true;
      case 6: return listeners.fn.call(listeners.context, a1, a2, a3, a4, a5), true;
    }

    for (i = 1, args = new Array(len -1); i < len; i++) {
      args[i - 1] = arguments[i];
    }

    listeners.fn.apply(listeners.context, args);
  } else {
    var length = listeners.length
      , j;

    for (i = 0; i < length; i++) {
      if (listeners[i].once) this.removeListener(event, listeners[i].fn, undefined, true);

      switch (len) {
        case 1: listeners[i].fn.call(listeners[i].context); break;
        case 2: listeners[i].fn.call(listeners[i].context, a1); break;
        case 3: listeners[i].fn.call(listeners[i].context, a1, a2); break;
        case 4: listeners[i].fn.call(listeners[i].context, a1, a2, a3); break;
        default:
          if (!args) for (j = 1, args = new Array(len -1); j < len; j++) {
            args[j - 1] = arguments[j];
          }

          listeners[i].fn.apply(listeners[i].context, args);
      }
    }
  }

  return true;
};

/**
 * Add a listener for a given event.
 *
 * @param {(String|Symbol)} event The event name.
 * @param {Function} fn The listener function.
 * @param {*} [context=this] The context to invoke the listener with.
 * @returns {EventEmitter} `this`.
 * @public
 */
EventEmitter.prototype.on = function on(event, fn, context) {
  return addListener(this, event, fn, context, false);
};

/**
 * Add a one-time listener for a given event.
 *
 * @param {(String|Symbol)} event The event name.
 * @param {Function} fn The listener function.
 * @param {*} [context=this] The context to invoke the listener with.
 * @returns {EventEmitter} `this`.
 * @public
 */
EventEmitter.prototype.once = function once(event, fn, context) {
  return addListener(this, event, fn, context, true);
};

/**
 * Remove the listeners of a given event.
 *
 * @param {(String|Symbol)} event The event name.
 * @param {Function} fn Only remove the listeners that match this function.
 * @param {*} context Only remove the listeners that have this context.
 * @param {Boolean} once Only remove one-time listeners.
 * @returns {EventEmitter} `this`.
 * @public
 */
EventEmitter.prototype.removeListener = function removeListener(event, fn, context, once) {
  var evt = prefix ? prefix + event : event;

  if (!this._events[evt]) return this;
  if (!fn) {
    clearEvent(this, evt);
    return this;
  }

  var listeners = this._events[evt];

  if (listeners.fn) {
    if (
      listeners.fn === fn &&
      (!once || listeners.once) &&
      (!context || listeners.context === context)
    ) {
      clearEvent(this, evt);
    }
  } else {
    for (var i = 0, events = [], length = listeners.length; i < length; i++) {
      if (
        listeners[i].fn !== fn ||
        (once && !listeners[i].once) ||
        (context && listeners[i].context !== context)
      ) {
        events.push(listeners[i]);
      }
    }

    //
    // Reset the array, or remove it completely if we have no more listeners.
    //
    if (events.length) this._events[evt] = events.length === 1 ? events[0] : events;
    else clearEvent(this, evt);
  }

  return this;
};

/**
 * Remove all listeners, or those of the specified event.
 *
 * @param {(String|Symbol)} [event] The event name.
 * @returns {EventEmitter} `this`.
 * @public
 */
EventEmitter.prototype.removeAllListeners = function removeAllListeners(event) {
  var evt;

  if (event) {
    evt = prefix ? prefix + event : event;
    if (this._events[evt]) clearEvent(this, evt);
  } else {
    this._events = new Events();
    this._eventsCount = 0;
  }

  return this;
};

//
// Alias methods names because people roll like that.
//
EventEmitter.prototype.off = EventEmitter.prototype.removeListener;
EventEmitter.prototype.addListener = EventEmitter.prototype.on;

//
// Expose the prefix.
//
EventEmitter.prefixed = prefix;

//
// Allow `EventEmitter` to be imported as module namespace.
//
EventEmitter.EventEmitter = EventEmitter;

//
// Expose the module.
//
if (true) {
  module.exports = EventEmitter;
}


/***/ }),

/***/ "./node_modules/fuse.js/dist/fuse.esm.js":
/*!***********************************************!*\
  !*** ./node_modules/fuse.js/dist/fuse.esm.js ***!
  \***********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ Fuse)
/* harmony export */ });
/**
 * Fuse.js v6.6.2 - Lightweight fuzzy-search (http://fusejs.io)
 *
 * Copyright (c) 2022 Kiro Risk (http://kiro.me)
 * All Rights Reserved. Apache Software License 2.0
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 */

function isArray(value) {
  return !Array.isArray
    ? getTag(value) === '[object Array]'
    : Array.isArray(value)
}

// Adapted from: https://github.com/lodash/lodash/blob/master/.internal/baseToString.js
const INFINITY = 1 / 0;
function baseToString(value) {
  // Exit early for strings to avoid a performance hit in some environments.
  if (typeof value == 'string') {
    return value
  }
  let result = value + '';
  return result == '0' && 1 / value == -INFINITY ? '-0' : result
}

function toString(value) {
  return value == null ? '' : baseToString(value)
}

function isString(value) {
  return typeof value === 'string'
}

function isNumber(value) {
  return typeof value === 'number'
}

// Adapted from: https://github.com/lodash/lodash/blob/master/isBoolean.js
function isBoolean(value) {
  return (
    value === true ||
    value === false ||
    (isObjectLike(value) && getTag(value) == '[object Boolean]')
  )
}

function isObject(value) {
  return typeof value === 'object'
}

// Checks if `value` is object-like.
function isObjectLike(value) {
  return isObject(value) && value !== null
}

function isDefined(value) {
  return value !== undefined && value !== null
}

function isBlank(value) {
  return !value.trim().length
}

// Gets the `toStringTag` of `value`.
// Adapted from: https://github.com/lodash/lodash/blob/master/.internal/getTag.js
function getTag(value) {
  return value == null
    ? value === undefined
      ? '[object Undefined]'
      : '[object Null]'
    : Object.prototype.toString.call(value)
}

const EXTENDED_SEARCH_UNAVAILABLE = 'Extended search is not available';

const INCORRECT_INDEX_TYPE = "Incorrect 'index' type";

const LOGICAL_SEARCH_INVALID_QUERY_FOR_KEY = (key) =>
  `Invalid value for key ${key}`;

const PATTERN_LENGTH_TOO_LARGE = (max) =>
  `Pattern length exceeds max of ${max}.`;

const MISSING_KEY_PROPERTY = (name) => `Missing ${name} property in key`;

const INVALID_KEY_WEIGHT_VALUE = (key) =>
  `Property 'weight' in key '${key}' must be a positive integer`;

const hasOwn = Object.prototype.hasOwnProperty;

class KeyStore {
  constructor(keys) {
    this._keys = [];
    this._keyMap = {};

    let totalWeight = 0;

    keys.forEach((key) => {
      let obj = createKey(key);

      totalWeight += obj.weight;

      this._keys.push(obj);
      this._keyMap[obj.id] = obj;

      totalWeight += obj.weight;
    });

    // Normalize weights so that their sum is equal to 1
    this._keys.forEach((key) => {
      key.weight /= totalWeight;
    });
  }
  get(keyId) {
    return this._keyMap[keyId]
  }
  keys() {
    return this._keys
  }
  toJSON() {
    return JSON.stringify(this._keys)
  }
}

function createKey(key) {
  let path = null;
  let id = null;
  let src = null;
  let weight = 1;
  let getFn = null;

  if (isString(key) || isArray(key)) {
    src = key;
    path = createKeyPath(key);
    id = createKeyId(key);
  } else {
    if (!hasOwn.call(key, 'name')) {
      throw new Error(MISSING_KEY_PROPERTY('name'))
    }

    const name = key.name;
    src = name;

    if (hasOwn.call(key, 'weight')) {
      weight = key.weight;

      if (weight <= 0) {
        throw new Error(INVALID_KEY_WEIGHT_VALUE(name))
      }
    }

    path = createKeyPath(name);
    id = createKeyId(name);
    getFn = key.getFn;
  }

  return { path, id, weight, src, getFn }
}

function createKeyPath(key) {
  return isArray(key) ? key : key.split('.')
}

function createKeyId(key) {
  return isArray(key) ? key.join('.') : key
}

function get(obj, path) {
  let list = [];
  let arr = false;

  const deepGet = (obj, path, index) => {
    if (!isDefined(obj)) {
      return
    }
    if (!path[index]) {
      // If there's no path left, we've arrived at the object we care about.
      list.push(obj);
    } else {
      let key = path[index];

      const value = obj[key];

      if (!isDefined(value)) {
        return
      }

      // If we're at the last value in the path, and if it's a string/number/bool,
      // add it to the list
      if (
        index === path.length - 1 &&
        (isString(value) || isNumber(value) || isBoolean(value))
      ) {
        list.push(toString(value));
      } else if (isArray(value)) {
        arr = true;
        // Search each item in the array.
        for (let i = 0, len = value.length; i < len; i += 1) {
          deepGet(value[i], path, index + 1);
        }
      } else if (path.length) {
        // An object. Recurse further.
        deepGet(value, path, index + 1);
      }
    }
  };

  // Backwards compatibility (since path used to be a string)
  deepGet(obj, isString(path) ? path.split('.') : path, 0);

  return arr ? list : list[0]
}

const MatchOptions = {
  // Whether the matches should be included in the result set. When `true`, each record in the result
  // set will include the indices of the matched characters.
  // These can consequently be used for highlighting purposes.
  includeMatches: false,
  // When `true`, the matching function will continue to the end of a search pattern even if
  // a perfect match has already been located in the string.
  findAllMatches: false,
  // Minimum number of characters that must be matched before a result is considered a match
  minMatchCharLength: 1
};

const BasicOptions = {
  // When `true`, the algorithm continues searching to the end of the input even if a perfect
  // match is found before the end of the same input.
  isCaseSensitive: false,
  // When true, the matching function will continue to the end of a search pattern even if
  includeScore: false,
  // List of properties that will be searched. This also supports nested properties.
  keys: [],
  // Whether to sort the result list, by score
  shouldSort: true,
  // Default sort function: sort by ascending score, ascending index
  sortFn: (a, b) =>
    a.score === b.score ? (a.idx < b.idx ? -1 : 1) : a.score < b.score ? -1 : 1
};

const FuzzyOptions = {
  // Approximately where in the text is the pattern expected to be found?
  location: 0,
  // At what point does the match algorithm give up. A threshold of '0.0' requires a perfect match
  // (of both letters and location), a threshold of '1.0' would match anything.
  threshold: 0.6,
  // Determines how close the match must be to the fuzzy location (specified above).
  // An exact letter match which is 'distance' characters away from the fuzzy location
  // would score as a complete mismatch. A distance of '0' requires the match be at
  // the exact location specified, a threshold of '1000' would require a perfect match
  // to be within 800 characters of the fuzzy location to be found using a 0.8 threshold.
  distance: 100
};

const AdvancedOptions = {
  // When `true`, it enables the use of unix-like search commands
  useExtendedSearch: false,
  // The get function to use when fetching an object's properties.
  // The default will search nested paths *ie foo.bar.baz*
  getFn: get,
  // When `true`, search will ignore `location` and `distance`, so it won't matter
  // where in the string the pattern appears.
  // More info: https://fusejs.io/concepts/scoring-theory.html#fuzziness-score
  ignoreLocation: false,
  // When `true`, the calculation for the relevance score (used for sorting) will
  // ignore the field-length norm.
  // More info: https://fusejs.io/concepts/scoring-theory.html#field-length-norm
  ignoreFieldNorm: false,
  // The weight to determine how much field length norm effects scoring.
  fieldNormWeight: 1
};

var Config = {
  ...BasicOptions,
  ...MatchOptions,
  ...FuzzyOptions,
  ...AdvancedOptions
};

const SPACE = /[^ ]+/g;

// Field-length norm: the shorter the field, the higher the weight.
// Set to 3 decimals to reduce index size.
function norm(weight = 1, mantissa = 3) {
  const cache = new Map();
  const m = Math.pow(10, mantissa);

  return {
    get(value) {
      const numTokens = value.match(SPACE).length;

      if (cache.has(numTokens)) {
        return cache.get(numTokens)
      }

      // Default function is 1/sqrt(x), weight makes that variable
      const norm = 1 / Math.pow(numTokens, 0.5 * weight);

      // In place of `toFixed(mantissa)`, for faster computation
      const n = parseFloat(Math.round(norm * m) / m);

      cache.set(numTokens, n);

      return n
    },
    clear() {
      cache.clear();
    }
  }
}

class FuseIndex {
  constructor({
    getFn = Config.getFn,
    fieldNormWeight = Config.fieldNormWeight
  } = {}) {
    this.norm = norm(fieldNormWeight, 3);
    this.getFn = getFn;
    this.isCreated = false;

    this.setIndexRecords();
  }
  setSources(docs = []) {
    this.docs = docs;
  }
  setIndexRecords(records = []) {
    this.records = records;
  }
  setKeys(keys = []) {
    this.keys = keys;
    this._keysMap = {};
    keys.forEach((key, idx) => {
      this._keysMap[key.id] = idx;
    });
  }
  create() {
    if (this.isCreated || !this.docs.length) {
      return
    }

    this.isCreated = true;

    // List is Array<String>
    if (isString(this.docs[0])) {
      this.docs.forEach((doc, docIndex) => {
        this._addString(doc, docIndex);
      });
    } else {
      // List is Array<Object>
      this.docs.forEach((doc, docIndex) => {
        this._addObject(doc, docIndex);
      });
    }

    this.norm.clear();
  }
  // Adds a doc to the end of the index
  add(doc) {
    const idx = this.size();

    if (isString(doc)) {
      this._addString(doc, idx);
    } else {
      this._addObject(doc, idx);
    }
  }
  // Removes the doc at the specified index of the index
  removeAt(idx) {
    this.records.splice(idx, 1);

    // Change ref index of every subsquent doc
    for (let i = idx, len = this.size(); i < len; i += 1) {
      this.records[i].i -= 1;
    }
  }
  getValueForItemAtKeyId(item, keyId) {
    return item[this._keysMap[keyId]]
  }
  size() {
    return this.records.length
  }
  _addString(doc, docIndex) {
    if (!isDefined(doc) || isBlank(doc)) {
      return
    }

    let record = {
      v: doc,
      i: docIndex,
      n: this.norm.get(doc)
    };

    this.records.push(record);
  }
  _addObject(doc, docIndex) {
    let record = { i: docIndex, $: {} };

    // Iterate over every key (i.e, path), and fetch the value at that key
    this.keys.forEach((key, keyIndex) => {
      let value = key.getFn ? key.getFn(doc) : this.getFn(doc, key.path);

      if (!isDefined(value)) {
        return
      }

      if (isArray(value)) {
        let subRecords = [];
        const stack = [{ nestedArrIndex: -1, value }];

        while (stack.length) {
          const { nestedArrIndex, value } = stack.pop();

          if (!isDefined(value)) {
            continue
          }

          if (isString(value) && !isBlank(value)) {
            let subRecord = {
              v: value,
              i: nestedArrIndex,
              n: this.norm.get(value)
            };

            subRecords.push(subRecord);
          } else if (isArray(value)) {
            value.forEach((item, k) => {
              stack.push({
                nestedArrIndex: k,
                value: item
              });
            });
          } else ;
        }
        record.$[keyIndex] = subRecords;
      } else if (isString(value) && !isBlank(value)) {
        let subRecord = {
          v: value,
          n: this.norm.get(value)
        };

        record.$[keyIndex] = subRecord;
      }
    });

    this.records.push(record);
  }
  toJSON() {
    return {
      keys: this.keys,
      records: this.records
    }
  }
}

function createIndex(
  keys,
  docs,
  { getFn = Config.getFn, fieldNormWeight = Config.fieldNormWeight } = {}
) {
  const myIndex = new FuseIndex({ getFn, fieldNormWeight });
  myIndex.setKeys(keys.map(createKey));
  myIndex.setSources(docs);
  myIndex.create();
  return myIndex
}

function parseIndex(
  data,
  { getFn = Config.getFn, fieldNormWeight = Config.fieldNormWeight } = {}
) {
  const { keys, records } = data;
  const myIndex = new FuseIndex({ getFn, fieldNormWeight });
  myIndex.setKeys(keys);
  myIndex.setIndexRecords(records);
  return myIndex
}

function computeScore$1(
  pattern,
  {
    errors = 0,
    currentLocation = 0,
    expectedLocation = 0,
    distance = Config.distance,
    ignoreLocation = Config.ignoreLocation
  } = {}
) {
  const accuracy = errors / pattern.length;

  if (ignoreLocation) {
    return accuracy
  }

  const proximity = Math.abs(expectedLocation - currentLocation);

  if (!distance) {
    // Dodge divide by zero error.
    return proximity ? 1.0 : accuracy
  }

  return accuracy + proximity / distance
}

function convertMaskToIndices(
  matchmask = [],
  minMatchCharLength = Config.minMatchCharLength
) {
  let indices = [];
  let start = -1;
  let end = -1;
  let i = 0;

  for (let len = matchmask.length; i < len; i += 1) {
    let match = matchmask[i];
    if (match && start === -1) {
      start = i;
    } else if (!match && start !== -1) {
      end = i - 1;
      if (end - start + 1 >= minMatchCharLength) {
        indices.push([start, end]);
      }
      start = -1;
    }
  }

  // (i-1 - start) + 1 => i - start
  if (matchmask[i - 1] && i - start >= minMatchCharLength) {
    indices.push([start, i - 1]);
  }

  return indices
}

// Machine word size
const MAX_BITS = 32;

function search(
  text,
  pattern,
  patternAlphabet,
  {
    location = Config.location,
    distance = Config.distance,
    threshold = Config.threshold,
    findAllMatches = Config.findAllMatches,
    minMatchCharLength = Config.minMatchCharLength,
    includeMatches = Config.includeMatches,
    ignoreLocation = Config.ignoreLocation
  } = {}
) {
  if (pattern.length > MAX_BITS) {
    throw new Error(PATTERN_LENGTH_TOO_LARGE(MAX_BITS))
  }

  const patternLen = pattern.length;
  // Set starting location at beginning text and initialize the alphabet.
  const textLen = text.length;
  // Handle the case when location > text.length
  const expectedLocation = Math.max(0, Math.min(location, textLen));
  // Highest score beyond which we give up.
  let currentThreshold = threshold;
  // Is there a nearby exact match? (speedup)
  let bestLocation = expectedLocation;

  // Performance: only computer matches when the minMatchCharLength > 1
  // OR if `includeMatches` is true.
  const computeMatches = minMatchCharLength > 1 || includeMatches;
  // A mask of the matches, used for building the indices
  const matchMask = computeMatches ? Array(textLen) : [];

  let index;

  // Get all exact matches, here for speed up
  while ((index = text.indexOf(pattern, bestLocation)) > -1) {
    let score = computeScore$1(pattern, {
      currentLocation: index,
      expectedLocation,
      distance,
      ignoreLocation
    });

    currentThreshold = Math.min(score, currentThreshold);
    bestLocation = index + patternLen;

    if (computeMatches) {
      let i = 0;
      while (i < patternLen) {
        matchMask[index + i] = 1;
        i += 1;
      }
    }
  }

  // Reset the best location
  bestLocation = -1;

  let lastBitArr = [];
  let finalScore = 1;
  let binMax = patternLen + textLen;

  const mask = 1 << (patternLen - 1);

  for (let i = 0; i < patternLen; i += 1) {
    // Scan for the best match; each iteration allows for one more error.
    // Run a binary search to determine how far from the match location we can stray
    // at this error level.
    let binMin = 0;
    let binMid = binMax;

    while (binMin < binMid) {
      const score = computeScore$1(pattern, {
        errors: i,
        currentLocation: expectedLocation + binMid,
        expectedLocation,
        distance,
        ignoreLocation
      });

      if (score <= currentThreshold) {
        binMin = binMid;
      } else {
        binMax = binMid;
      }

      binMid = Math.floor((binMax - binMin) / 2 + binMin);
    }

    // Use the result from this iteration as the maximum for the next.
    binMax = binMid;

    let start = Math.max(1, expectedLocation - binMid + 1);
    let finish = findAllMatches
      ? textLen
      : Math.min(expectedLocation + binMid, textLen) + patternLen;

    // Initialize the bit array
    let bitArr = Array(finish + 2);

    bitArr[finish + 1] = (1 << i) - 1;

    for (let j = finish; j >= start; j -= 1) {
      let currentLocation = j - 1;
      let charMatch = patternAlphabet[text.charAt(currentLocation)];

      if (computeMatches) {
        // Speed up: quick bool to int conversion (i.e, `charMatch ? 1 : 0`)
        matchMask[currentLocation] = +!!charMatch;
      }

      // First pass: exact match
      bitArr[j] = ((bitArr[j + 1] << 1) | 1) & charMatch;

      // Subsequent passes: fuzzy match
      if (i) {
        bitArr[j] |=
          ((lastBitArr[j + 1] | lastBitArr[j]) << 1) | 1 | lastBitArr[j + 1];
      }

      if (bitArr[j] & mask) {
        finalScore = computeScore$1(pattern, {
          errors: i,
          currentLocation,
          expectedLocation,
          distance,
          ignoreLocation
        });

        // This match will almost certainly be better than any existing match.
        // But check anyway.
        if (finalScore <= currentThreshold) {
          // Indeed it is
          currentThreshold = finalScore;
          bestLocation = currentLocation;

          // Already passed `loc`, downhill from here on in.
          if (bestLocation <= expectedLocation) {
            break
          }

          // When passing `bestLocation`, don't exceed our current distance from `expectedLocation`.
          start = Math.max(1, 2 * expectedLocation - bestLocation);
        }
      }
    }

    // No hope for a (better) match at greater error levels.
    const score = computeScore$1(pattern, {
      errors: i + 1,
      currentLocation: expectedLocation,
      expectedLocation,
      distance,
      ignoreLocation
    });

    if (score > currentThreshold) {
      break
    }

    lastBitArr = bitArr;
  }

  const result = {
    isMatch: bestLocation >= 0,
    // Count exact matches (those with a score of 0) to be "almost" exact
    score: Math.max(0.001, finalScore)
  };

  if (computeMatches) {
    const indices = convertMaskToIndices(matchMask, minMatchCharLength);
    if (!indices.length) {
      result.isMatch = false;
    } else if (includeMatches) {
      result.indices = indices;
    }
  }

  return result
}

function createPatternAlphabet(pattern) {
  let mask = {};

  for (let i = 0, len = pattern.length; i < len; i += 1) {
    const char = pattern.charAt(i);
    mask[char] = (mask[char] || 0) | (1 << (len - i - 1));
  }

  return mask
}

class BitapSearch {
  constructor(
    pattern,
    {
      location = Config.location,
      threshold = Config.threshold,
      distance = Config.distance,
      includeMatches = Config.includeMatches,
      findAllMatches = Config.findAllMatches,
      minMatchCharLength = Config.minMatchCharLength,
      isCaseSensitive = Config.isCaseSensitive,
      ignoreLocation = Config.ignoreLocation
    } = {}
  ) {
    this.options = {
      location,
      threshold,
      distance,
      includeMatches,
      findAllMatches,
      minMatchCharLength,
      isCaseSensitive,
      ignoreLocation
    };

    this.pattern = isCaseSensitive ? pattern : pattern.toLowerCase();

    this.chunks = [];

    if (!this.pattern.length) {
      return
    }

    const addChunk = (pattern, startIndex) => {
      this.chunks.push({
        pattern,
        alphabet: createPatternAlphabet(pattern),
        startIndex
      });
    };

    const len = this.pattern.length;

    if (len > MAX_BITS) {
      let i = 0;
      const remainder = len % MAX_BITS;
      const end = len - remainder;

      while (i < end) {
        addChunk(this.pattern.substr(i, MAX_BITS), i);
        i += MAX_BITS;
      }

      if (remainder) {
        const startIndex = len - MAX_BITS;
        addChunk(this.pattern.substr(startIndex), startIndex);
      }
    } else {
      addChunk(this.pattern, 0);
    }
  }

  searchIn(text) {
    const { isCaseSensitive, includeMatches } = this.options;

    if (!isCaseSensitive) {
      text = text.toLowerCase();
    }

    // Exact match
    if (this.pattern === text) {
      let result = {
        isMatch: true,
        score: 0
      };

      if (includeMatches) {
        result.indices = [[0, text.length - 1]];
      }

      return result
    }

    // Otherwise, use Bitap algorithm
    const {
      location,
      distance,
      threshold,
      findAllMatches,
      minMatchCharLength,
      ignoreLocation
    } = this.options;

    let allIndices = [];
    let totalScore = 0;
    let hasMatches = false;

    this.chunks.forEach(({ pattern, alphabet, startIndex }) => {
      const { isMatch, score, indices } = search(text, pattern, alphabet, {
        location: location + startIndex,
        distance,
        threshold,
        findAllMatches,
        minMatchCharLength,
        includeMatches,
        ignoreLocation
      });

      if (isMatch) {
        hasMatches = true;
      }

      totalScore += score;

      if (isMatch && indices) {
        allIndices = [...allIndices, ...indices];
      }
    });

    let result = {
      isMatch: hasMatches,
      score: hasMatches ? totalScore / this.chunks.length : 1
    };

    if (hasMatches && includeMatches) {
      result.indices = allIndices;
    }

    return result
  }
}

class BaseMatch {
  constructor(pattern) {
    this.pattern = pattern;
  }
  static isMultiMatch(pattern) {
    return getMatch(pattern, this.multiRegex)
  }
  static isSingleMatch(pattern) {
    return getMatch(pattern, this.singleRegex)
  }
  search(/*text*/) {}
}

function getMatch(pattern, exp) {
  const matches = pattern.match(exp);
  return matches ? matches[1] : null
}

// Token: 'file

class ExactMatch extends BaseMatch {
  constructor(pattern) {
    super(pattern);
  }
  static get type() {
    return 'exact'
  }
  static get multiRegex() {
    return /^="(.*)"$/
  }
  static get singleRegex() {
    return /^=(.*)$/
  }
  search(text) {
    const isMatch = text === this.pattern;

    return {
      isMatch,
      score: isMatch ? 0 : 1,
      indices: [0, this.pattern.length - 1]
    }
  }
}

// Token: !fire

class InverseExactMatch extends BaseMatch {
  constructor(pattern) {
    super(pattern);
  }
  static get type() {
    return 'inverse-exact'
  }
  static get multiRegex() {
    return /^!"(.*)"$/
  }
  static get singleRegex() {
    return /^!(.*)$/
  }
  search(text) {
    const index = text.indexOf(this.pattern);
    const isMatch = index === -1;

    return {
      isMatch,
      score: isMatch ? 0 : 1,
      indices: [0, text.length - 1]
    }
  }
}

// Token: ^file

class PrefixExactMatch extends BaseMatch {
  constructor(pattern) {
    super(pattern);
  }
  static get type() {
    return 'prefix-exact'
  }
  static get multiRegex() {
    return /^\^"(.*)"$/
  }
  static get singleRegex() {
    return /^\^(.*)$/
  }
  search(text) {
    const isMatch = text.startsWith(this.pattern);

    return {
      isMatch,
      score: isMatch ? 0 : 1,
      indices: [0, this.pattern.length - 1]
    }
  }
}

// Token: !^fire

class InversePrefixExactMatch extends BaseMatch {
  constructor(pattern) {
    super(pattern);
  }
  static get type() {
    return 'inverse-prefix-exact'
  }
  static get multiRegex() {
    return /^!\^"(.*)"$/
  }
  static get singleRegex() {
    return /^!\^(.*)$/
  }
  search(text) {
    const isMatch = !text.startsWith(this.pattern);

    return {
      isMatch,
      score: isMatch ? 0 : 1,
      indices: [0, text.length - 1]
    }
  }
}

// Token: .file$

class SuffixExactMatch extends BaseMatch {
  constructor(pattern) {
    super(pattern);
  }
  static get type() {
    return 'suffix-exact'
  }
  static get multiRegex() {
    return /^"(.*)"\$$/
  }
  static get singleRegex() {
    return /^(.*)\$$/
  }
  search(text) {
    const isMatch = text.endsWith(this.pattern);

    return {
      isMatch,
      score: isMatch ? 0 : 1,
      indices: [text.length - this.pattern.length, text.length - 1]
    }
  }
}

// Token: !.file$

class InverseSuffixExactMatch extends BaseMatch {
  constructor(pattern) {
    super(pattern);
  }
  static get type() {
    return 'inverse-suffix-exact'
  }
  static get multiRegex() {
    return /^!"(.*)"\$$/
  }
  static get singleRegex() {
    return /^!(.*)\$$/
  }
  search(text) {
    const isMatch = !text.endsWith(this.pattern);
    return {
      isMatch,
      score: isMatch ? 0 : 1,
      indices: [0, text.length - 1]
    }
  }
}

class FuzzyMatch extends BaseMatch {
  constructor(
    pattern,
    {
      location = Config.location,
      threshold = Config.threshold,
      distance = Config.distance,
      includeMatches = Config.includeMatches,
      findAllMatches = Config.findAllMatches,
      minMatchCharLength = Config.minMatchCharLength,
      isCaseSensitive = Config.isCaseSensitive,
      ignoreLocation = Config.ignoreLocation
    } = {}
  ) {
    super(pattern);
    this._bitapSearch = new BitapSearch(pattern, {
      location,
      threshold,
      distance,
      includeMatches,
      findAllMatches,
      minMatchCharLength,
      isCaseSensitive,
      ignoreLocation
    });
  }
  static get type() {
    return 'fuzzy'
  }
  static get multiRegex() {
    return /^"(.*)"$/
  }
  static get singleRegex() {
    return /^(.*)$/
  }
  search(text) {
    return this._bitapSearch.searchIn(text)
  }
}

// Token: 'file

class IncludeMatch extends BaseMatch {
  constructor(pattern) {
    super(pattern);
  }
  static get type() {
    return 'include'
  }
  static get multiRegex() {
    return /^'"(.*)"$/
  }
  static get singleRegex() {
    return /^'(.*)$/
  }
  search(text) {
    let location = 0;
    let index;

    const indices = [];
    const patternLen = this.pattern.length;

    // Get all exact matches
    while ((index = text.indexOf(this.pattern, location)) > -1) {
      location = index + patternLen;
      indices.push([index, location - 1]);
    }

    const isMatch = !!indices.length;

    return {
      isMatch,
      score: isMatch ? 0 : 1,
      indices
    }
  }
}

// Order is important. DO NOT CHANGE.
const searchers = [
  ExactMatch,
  IncludeMatch,
  PrefixExactMatch,
  InversePrefixExactMatch,
  InverseSuffixExactMatch,
  SuffixExactMatch,
  InverseExactMatch,
  FuzzyMatch
];

const searchersLen = searchers.length;

// Regex to split by spaces, but keep anything in quotes together
const SPACE_RE = / +(?=(?:[^\"]*\"[^\"]*\")*[^\"]*$)/;
const OR_TOKEN = '|';

// Return a 2D array representation of the query, for simpler parsing.
// Example:
// "^core go$ | rb$ | py$ xy$" => [["^core", "go$"], ["rb$"], ["py$", "xy$"]]
function parseQuery(pattern, options = {}) {
  return pattern.split(OR_TOKEN).map((item) => {
    let query = item
      .trim()
      .split(SPACE_RE)
      .filter((item) => item && !!item.trim());

    let results = [];
    for (let i = 0, len = query.length; i < len; i += 1) {
      const queryItem = query[i];

      // 1. Handle multiple query match (i.e, once that are quoted, like `"hello world"`)
      let found = false;
      let idx = -1;
      while (!found && ++idx < searchersLen) {
        const searcher = searchers[idx];
        let token = searcher.isMultiMatch(queryItem);
        if (token) {
          results.push(new searcher(token, options));
          found = true;
        }
      }

      if (found) {
        continue
      }

      // 2. Handle single query matches (i.e, once that are *not* quoted)
      idx = -1;
      while (++idx < searchersLen) {
        const searcher = searchers[idx];
        let token = searcher.isSingleMatch(queryItem);
        if (token) {
          results.push(new searcher(token, options));
          break
        }
      }
    }

    return results
  })
}

// These extended matchers can return an array of matches, as opposed
// to a singl match
const MultiMatchSet = new Set([FuzzyMatch.type, IncludeMatch.type]);

/**
 * Command-like searching
 * ======================
 *
 * Given multiple search terms delimited by spaces.e.g. `^jscript .python$ ruby !java`,
 * search in a given text.
 *
 * Search syntax:
 *
 * | Token       | Match type                 | Description                            |
 * | ----------- | -------------------------- | -------------------------------------- |
 * | `jscript`   | fuzzy-match                | Items that fuzzy match `jscript`       |
 * | `=scheme`   | exact-match                | Items that are `scheme`                |
 * | `'python`   | include-match              | Items that include `python`            |
 * | `!ruby`     | inverse-exact-match        | Items that do not include `ruby`       |
 * | `^java`     | prefix-exact-match         | Items that start with `java`           |
 * | `!^earlang` | inverse-prefix-exact-match | Items that do not start with `earlang` |
 * | `.js$`      | suffix-exact-match         | Items that end with `.js`              |
 * | `!.go$`     | inverse-suffix-exact-match | Items that do not end with `.go`       |
 *
 * A single pipe character acts as an OR operator. For example, the following
 * query matches entries that start with `core` and end with either`go`, `rb`,
 * or`py`.
 *
 * ```
 * ^core go$ | rb$ | py$
 * ```
 */
class ExtendedSearch {
  constructor(
    pattern,
    {
      isCaseSensitive = Config.isCaseSensitive,
      includeMatches = Config.includeMatches,
      minMatchCharLength = Config.minMatchCharLength,
      ignoreLocation = Config.ignoreLocation,
      findAllMatches = Config.findAllMatches,
      location = Config.location,
      threshold = Config.threshold,
      distance = Config.distance
    } = {}
  ) {
    this.query = null;
    this.options = {
      isCaseSensitive,
      includeMatches,
      minMatchCharLength,
      findAllMatches,
      ignoreLocation,
      location,
      threshold,
      distance
    };

    this.pattern = isCaseSensitive ? pattern : pattern.toLowerCase();
    this.query = parseQuery(this.pattern, this.options);
  }

  static condition(_, options) {
    return options.useExtendedSearch
  }

  searchIn(text) {
    const query = this.query;

    if (!query) {
      return {
        isMatch: false,
        score: 1
      }
    }

    const { includeMatches, isCaseSensitive } = this.options;

    text = isCaseSensitive ? text : text.toLowerCase();

    let numMatches = 0;
    let allIndices = [];
    let totalScore = 0;

    // ORs
    for (let i = 0, qLen = query.length; i < qLen; i += 1) {
      const searchers = query[i];

      // Reset indices
      allIndices.length = 0;
      numMatches = 0;

      // ANDs
      for (let j = 0, pLen = searchers.length; j < pLen; j += 1) {
        const searcher = searchers[j];
        const { isMatch, indices, score } = searcher.search(text);

        if (isMatch) {
          numMatches += 1;
          totalScore += score;
          if (includeMatches) {
            const type = searcher.constructor.type;
            if (MultiMatchSet.has(type)) {
              allIndices = [...allIndices, ...indices];
            } else {
              allIndices.push(indices);
            }
          }
        } else {
          totalScore = 0;
          numMatches = 0;
          allIndices.length = 0;
          break
        }
      }

      // OR condition, so if TRUE, return
      if (numMatches) {
        let result = {
          isMatch: true,
          score: totalScore / numMatches
        };

        if (includeMatches) {
          result.indices = allIndices;
        }

        return result
      }
    }

    // Nothing was matched
    return {
      isMatch: false,
      score: 1
    }
  }
}

const registeredSearchers = [];

function register(...args) {
  registeredSearchers.push(...args);
}

function createSearcher(pattern, options) {
  for (let i = 0, len = registeredSearchers.length; i < len; i += 1) {
    let searcherClass = registeredSearchers[i];
    if (searcherClass.condition(pattern, options)) {
      return new searcherClass(pattern, options)
    }
  }

  return new BitapSearch(pattern, options)
}

const LogicalOperator = {
  AND: '$and',
  OR: '$or'
};

const KeyType = {
  PATH: '$path',
  PATTERN: '$val'
};

const isExpression = (query) =>
  !!(query[LogicalOperator.AND] || query[LogicalOperator.OR]);

const isPath = (query) => !!query[KeyType.PATH];

const isLeaf = (query) =>
  !isArray(query) && isObject(query) && !isExpression(query);

const convertToExplicit = (query) => ({
  [LogicalOperator.AND]: Object.keys(query).map((key) => ({
    [key]: query[key]
  }))
});

// When `auto` is `true`, the parse function will infer and initialize and add
// the appropriate `Searcher` instance
function parse(query, options, { auto = true } = {}) {
  const next = (query) => {
    let keys = Object.keys(query);

    const isQueryPath = isPath(query);

    if (!isQueryPath && keys.length > 1 && !isExpression(query)) {
      return next(convertToExplicit(query))
    }

    if (isLeaf(query)) {
      const key = isQueryPath ? query[KeyType.PATH] : keys[0];

      const pattern = isQueryPath ? query[KeyType.PATTERN] : query[key];

      if (!isString(pattern)) {
        throw new Error(LOGICAL_SEARCH_INVALID_QUERY_FOR_KEY(key))
      }

      const obj = {
        keyId: createKeyId(key),
        pattern
      };

      if (auto) {
        obj.searcher = createSearcher(pattern, options);
      }

      return obj
    }

    let node = {
      children: [],
      operator: keys[0]
    };

    keys.forEach((key) => {
      const value = query[key];

      if (isArray(value)) {
        value.forEach((item) => {
          node.children.push(next(item));
        });
      }
    });

    return node
  };

  if (!isExpression(query)) {
    query = convertToExplicit(query);
  }

  return next(query)
}

// Practical scoring function
function computeScore(
  results,
  { ignoreFieldNorm = Config.ignoreFieldNorm }
) {
  results.forEach((result) => {
    let totalScore = 1;

    result.matches.forEach(({ key, norm, score }) => {
      const weight = key ? key.weight : null;

      totalScore *= Math.pow(
        score === 0 && weight ? Number.EPSILON : score,
        (weight || 1) * (ignoreFieldNorm ? 1 : norm)
      );
    });

    result.score = totalScore;
  });
}

function transformMatches(result, data) {
  const matches = result.matches;
  data.matches = [];

  if (!isDefined(matches)) {
    return
  }

  matches.forEach((match) => {
    if (!isDefined(match.indices) || !match.indices.length) {
      return
    }

    const { indices, value } = match;

    let obj = {
      indices,
      value
    };

    if (match.key) {
      obj.key = match.key.src;
    }

    if (match.idx > -1) {
      obj.refIndex = match.idx;
    }

    data.matches.push(obj);
  });
}

function transformScore(result, data) {
  data.score = result.score;
}

function format(
  results,
  docs,
  {
    includeMatches = Config.includeMatches,
    includeScore = Config.includeScore
  } = {}
) {
  const transformers = [];

  if (includeMatches) transformers.push(transformMatches);
  if (includeScore) transformers.push(transformScore);

  return results.map((result) => {
    const { idx } = result;

    const data = {
      item: docs[idx],
      refIndex: idx
    };

    if (transformers.length) {
      transformers.forEach((transformer) => {
        transformer(result, data);
      });
    }

    return data
  })
}

class Fuse {
  constructor(docs, options = {}, index) {
    this.options = { ...Config, ...options };

    if (
      this.options.useExtendedSearch &&
      !true
    ) {}

    this._keyStore = new KeyStore(this.options.keys);

    this.setCollection(docs, index);
  }

  setCollection(docs, index) {
    this._docs = docs;

    if (index && !(index instanceof FuseIndex)) {
      throw new Error(INCORRECT_INDEX_TYPE)
    }

    this._myIndex =
      index ||
      createIndex(this.options.keys, this._docs, {
        getFn: this.options.getFn,
        fieldNormWeight: this.options.fieldNormWeight
      });
  }

  add(doc) {
    if (!isDefined(doc)) {
      return
    }

    this._docs.push(doc);
    this._myIndex.add(doc);
  }

  remove(predicate = (/* doc, idx */) => false) {
    const results = [];

    for (let i = 0, len = this._docs.length; i < len; i += 1) {
      const doc = this._docs[i];
      if (predicate(doc, i)) {
        this.removeAt(i);
        i -= 1;
        len -= 1;

        results.push(doc);
      }
    }

    return results
  }

  removeAt(idx) {
    this._docs.splice(idx, 1);
    this._myIndex.removeAt(idx);
  }

  getIndex() {
    return this._myIndex
  }

  search(query, { limit = -1 } = {}) {
    const {
      includeMatches,
      includeScore,
      shouldSort,
      sortFn,
      ignoreFieldNorm
    } = this.options;

    let results = isString(query)
      ? isString(this._docs[0])
        ? this._searchStringList(query)
        : this._searchObjectList(query)
      : this._searchLogical(query);

    computeScore(results, { ignoreFieldNorm });

    if (shouldSort) {
      results.sort(sortFn);
    }

    if (isNumber(limit) && limit > -1) {
      results = results.slice(0, limit);
    }

    return format(results, this._docs, {
      includeMatches,
      includeScore
    })
  }

  _searchStringList(query) {
    const searcher = createSearcher(query, this.options);
    const { records } = this._myIndex;
    const results = [];

    // Iterate over every string in the index
    records.forEach(({ v: text, i: idx, n: norm }) => {
      if (!isDefined(text)) {
        return
      }

      const { isMatch, score, indices } = searcher.searchIn(text);

      if (isMatch) {
        results.push({
          item: text,
          idx,
          matches: [{ score, value: text, norm, indices }]
        });
      }
    });

    return results
  }

  _searchLogical(query) {

    const expression = parse(query, this.options);

    const evaluate = (node, item, idx) => {
      if (!node.children) {
        const { keyId, searcher } = node;

        const matches = this._findMatches({
          key: this._keyStore.get(keyId),
          value: this._myIndex.getValueForItemAtKeyId(item, keyId),
          searcher
        });

        if (matches && matches.length) {
          return [
            {
              idx,
              item,
              matches
            }
          ]
        }

        return []
      }

      const res = [];
      for (let i = 0, len = node.children.length; i < len; i += 1) {
        const child = node.children[i];
        const result = evaluate(child, item, idx);
        if (result.length) {
          res.push(...result);
        } else if (node.operator === LogicalOperator.AND) {
          return []
        }
      }
      return res
    };

    const records = this._myIndex.records;
    const resultMap = {};
    const results = [];

    records.forEach(({ $: item, i: idx }) => {
      if (isDefined(item)) {
        let expResults = evaluate(expression, item, idx);

        if (expResults.length) {
          // Dedupe when adding
          if (!resultMap[idx]) {
            resultMap[idx] = { idx, item, matches: [] };
            results.push(resultMap[idx]);
          }
          expResults.forEach(({ matches }) => {
            resultMap[idx].matches.push(...matches);
          });
        }
      }
    });

    return results
  }

  _searchObjectList(query) {
    const searcher = createSearcher(query, this.options);
    const { keys, records } = this._myIndex;
    const results = [];

    // List is Array<Object>
    records.forEach(({ $: item, i: idx }) => {
      if (!isDefined(item)) {
        return
      }

      let matches = [];

      // Iterate over every key (i.e, path), and fetch the value at that key
      keys.forEach((key, keyIndex) => {
        matches.push(
          ...this._findMatches({
            key,
            value: item[keyIndex],
            searcher
          })
        );
      });

      if (matches.length) {
        results.push({
          idx,
          item,
          matches
        });
      }
    });

    return results
  }
  _findMatches({ key, value, searcher }) {
    if (!isDefined(value)) {
      return []
    }

    let matches = [];

    if (isArray(value)) {
      value.forEach(({ v: text, i: idx, n: norm }) => {
        if (!isDefined(text)) {
          return
        }

        const { isMatch, score, indices } = searcher.searchIn(text);

        if (isMatch) {
          matches.push({
            score,
            key,
            value: text,
            idx,
            norm,
            indices
          });
        }
      });
    } else {
      const { v: text, n: norm } = value;

      const { isMatch, score, indices } = searcher.searchIn(text);

      if (isMatch) {
        matches.push({ score, key, value: text, norm, indices });
      }
    }

    return matches
  }
}

Fuse.version = '6.6.2';
Fuse.createIndex = createIndex;
Fuse.parseIndex = parseIndex;
Fuse.config = Config;

{
  Fuse.parseQuery = parse;
}

{
  register(ExtendedSearch);
}




/***/ }),

/***/ "./node_modules/youtube-background/jquery.youtube-background.js":
/*!**********************************************************************!*\
  !*** ./node_modules/youtube-background/jquery.youtube-background.js ***!
  \**********************************************************************/
/***/ (() => {

/**
 * jquery.youtube-background v1.0.14 | Nikola Stamatovic <@stamat> | MIT
 */

(function () {
  'use strict';

  function hasClass(element, className) {
    if (element.classList) {
      return element.classList.contains(className);
    }
    return new RegExp('\\b'+ className+'\\b').test(element.className);
  }

  function addClass(element, classNames) {
    if (element.classList) {
      const classes = classNames.split(' ');
      for (var i = 0; i < classes.length; i++) {
        const el_class = classes[i];
        element.classList.add(el_class);
      }
      return;
    }

    if (!hasClass(element, className)) {
      element.className += ' ' + className;
    }
  }

  function removeClass(element, className) {
    if (element.classList) {
      element.classList.remove(className);
      return;
    }

    element.className = element.className.replace(new RegExp('\\b'+ className+'\\b', 'g'), '');
  }

  function isMobile() {
    let is_mobile = false;
    (function(a){if(/(android|bb\d+|meego).+mobile|avantgo|bada\/|blackberry|blazer|compal|elaine|fennec|hiptop|iemobile|ip(hone|od)|iris|kindle|lge |maemo|midp|mmp|mobile.+firefox|netfront|opera m(ob|in)i|palm( os)?|phone|p(ixi|re)\/|plucker|pocket|psp|series(4|6)0|symbian|treo|up\.(browser|link)|vodafone|wap|windows ce|xda|xiino/i.test(a)||/1207|6310|6590|3gso|4thp|50[1-6]i|770s|802s|a wa|abac|ac(er|oo|s\-)|ai(ko|rn)|al(av|ca|co)|amoi|an(ex|ny|yw)|aptu|ar(ch|go)|as(te|us)|attw|au(di|\-m|r |s )|avan|be(ck|ll|nq)|bi(lb|rd)|bl(ac|az)|br(e|v)w|bumb|bw\-(n|u)|c55\/|capi|ccwa|cdm\-|cell|chtm|cldc|cmd\-|co(mp|nd)|craw|da(it|ll|ng)|dbte|dc\-s|devi|dica|dmob|do(c|p)o|ds(12|\-d)|el(49|ai)|em(l2|ul)|er(ic|k0)|esl8|ez([4-7]0|os|wa|ze)|fetc|fly(\-|_)|g1 u|g560|gene|gf\-5|g\-mo|go(\.w|od)|gr(ad|un)|haie|hcit|hd\-(m|p|t)|hei\-|hi(pt|ta)|hp( i|ip)|hs\-c|ht(c(\-| |_|a|g|p|s|t)|tp)|hu(aw|tc)|i\-(20|go|ma)|i230|iac( |\-|\/)|ibro|idea|ig01|ikom|im1k|inno|ipaq|iris|ja(t|v)a|jbro|jemu|jigs|kddi|keji|kgt( |\/)|klon|kpt |kwc\-|kyo(c|k)|le(no|xi)|lg( g|\/(k|l|u)|50|54|\-[a-w])|libw|lynx|m1\-w|m3ga|m50\/|ma(te|ui|xo)|mc(01|21|ca)|m\-cr|me(rc|ri)|mi(o8|oa|ts)|mmef|mo(01|02|bi|de|do|t(\-| |o|v)|zz)|mt(50|p1|v )|mwbp|mywa|n10[0-2]|n20[2-3]|n30(0|2)|n50(0|2|5)|n7(0(0|1)|10)|ne((c|m)\-|on|tf|wf|wg|wt)|nok(6|i)|nzph|o2im|op(ti|wv)|oran|owg1|p800|pan(a|d|t)|pdxg|pg(13|\-([1-8]|c))|phil|pire|pl(ay|uc)|pn\-2|po(ck|rt|se)|prox|psio|pt\-g|qa\-a|qc(07|12|21|32|60|\-[2-7]|i\-)|qtek|r380|r600|raks|rim9|ro(ve|zo)|s55\/|sa(ge|ma|mm|ms|ny|va)|sc(01|h\-|oo|p\-)|sdk\/|se(c(\-|0|1)|47|mc|nd|ri)|sgh\-|shar|sie(\-|m)|sk\-0|sl(45|id)|sm(al|ar|b3|it|t5)|so(ft|ny)|sp(01|h\-|v\-|v )|sy(01|mb)|t2(18|50)|t6(00|10|18)|ta(gt|lk)|tcl\-|tdg\-|tel(i|m)|tim\-|t\-mo|to(pl|sh)|ts(70|m\-|m3|m5)|tx\-9|up(\.b|g1|si)|utst|v400|v750|veri|vi(rg|te)|vk(40|5[0-3]|\-v)|vm40|voda|vulc|vx(52|53|60|61|70|80|81|83|85|98)|w3c(\-| )|webc|whit|wi(g |nc|nw)|wmlb|wonu|x700|yas\-|your|zeto|zte\-/i.test(a.substr(0,4))) is_mobile = true;})(navigator.userAgent||navigator.vendor||window.opera);

    return is_mobile;
  }

  function getRandomIntInclusive(min, max) {
    min = Math.ceil(min);
    max = Math.floor(max);
    return Math.floor(Math.random() * (max - min + 1)) + min; //The maximum is inclusive and the minimum is inclusive
  }

  function parseResolutionString(res) {
    const pts = res.split(/\s?:\s?/i);
    const DEFAULT_RESOLUTION = 16/9;
    if (pts.length < 2) {
      return DEFAULT_RESOLUTION;
    }

    const w = parseInt(pts[0], 10);
    const h = parseInt(pts[1], 10);

    if (isNaN(w) || isNaN(h)) {
      return DEFAULT_RESOLUTION;
    }

    return w/h;
  }

  function parseProperties(params, defaults, element, attr_prefix) {
    let res_params = {};

    if (!params) {
      res_params = defaults;
    } else {
      for (let k in defaults) {
        if (!params.hasOwnProperty(k)) {
          //load in defaults if the param hasn't been set
          res_params[k] = defaults[k];
        }
      }
    }

    if (!element) return res_params;
    // load params from data attributes
    for (let k in res_params) {
      let data;

      if (attr_prefix instanceof Array) {
        for (var i = 0; i < attr_prefix.length; i++) {
          const temp_data = element.getAttribute(attr_prefix[i]+k);
          if (temp_data) {
            data = temp_data;
            break;
          }
        }
      } else {
        data = element.getAttribute(attr_prefix+k);
      }

      if (data !== undefined && data !== null) {
        data = data === 'false' ? false : data;
        data = /^\d+$/.test(data) ? parseInt(data, 10) : data;
        data = /^\d+\.\d+$/.test(data) ? parseFloat(data) : data;
        res_params[k] = data;
      }
    }

    return res_params;
  }

  const tag = document.createElement('script');
  tag.src = "https://www.youtube.com/player_api";
  const firstScriptTag = document.getElementsByTagName('script')[0];
  firstScriptTag.parentNode.insertBefore(tag, firstScriptTag);

  function YoutubeBackground(elem, params, id, uid) {
    this.is_mobile = isMobile();

    this.element = elem;
    this.ytid = id;
    this.uid = uid;
    this.player = null;
    this.buttons = {};

    this.state = {};
    this.state.play = false;
    this.state.mute = false;

    this.params = {};

    const DEFAULTS = {
      'pause': false, //deprecated
      'play-button': false,
      'mute-button': false,
      'autoplay': true,
      'muted': true,
      'loop': true,
      'mobile': false,
      'load-background': true,
      'resolution': '16:9',
      'onStatusChange': function() {},
      'inline-styles': true,
      'fit-box': false,
      'offset': 200,
      'start-at': 0,
      'end-at': 0,
      'poster': null
    };

    this.__init__ = function () {
      if (!this.ytid) {
        return;
      }

      this.params = parseProperties(params, DEFAULTS, this.element, ['data-ytbg-', 'data-vbg-']);
      //pause deprecated
      if (this.params.pause) {
        this.params['play-button'] = this.params.pause;
      }
      this.params.resolution_mod = parseResolutionString(this.params.resolution);
      this.state.playing = this.params.autoplay;
      this.state.muted = this.params.muted;
      this.buildHTML();
      this.injectPlayer();


      if (this.params['play-button']) {
        this.generateActionButton({
          name: 'play',
          className: 'play-toggle',
          innerHtml: '<i class="fa"></i>',
          initialState: false,
          stateClassName: 'paused',
          condition_parameter: 'autoplay',
          stateChildClassNames: ['fa-pause-circle', 'fa-play-circle'],
          actions: ['play', 'pause']
        });
      }

      if (this.params['mute-button']) {
        this.generateActionButton({
          name: 'mute',
          className: 'mute-toggle',
          innerHtml: '<i class="fa"></i>',
          initialState: true,
          stateClassName: 'muted',
          condition_parameter: 'muted',
          stateChildClassNames: ['fa-volume-up', 'fa-volume-mute'],
          actions: ['unmute', 'mute']
        });
      }
    };

    this.__init__();
  }

  YoutubeBackground.prototype.initYTPlayer = function () {
    const self = this;
    if (window.hasOwnProperty('YT')) {
      this.player = new YT.Player(this.uid, {
        events: {
          'onReady': function(event) {
            self.onVideoPlayerReady(event);
          },
          'onStateChange': function(event) {
            self.onVideoStateChange(event);
          },
          'onError' : function(event) {
            //console.error('player_api', event);
          }
        }
      });
    }
  };

  YoutubeBackground.prototype.seekTo = function (seconds) {
    if (seconds > 0) {
      this.player.seekTo(seconds, true);
    }
  };

  YoutubeBackground.prototype.onVideoPlayerReady = function (event) {
    if (this.params.autoplay) {
      this.seekTo(this.params['start-at']);
      this.player.playVideo();
    }
  };

  YoutubeBackground.prototype.onVideoStateChange = function (event) {
    if (event.data === 0 && this.params.loop) {
      this.seekTo(this.params['start-at']);
      this.player.playVideo();
    }

    if (event.data === -1 && this.params.autoplay) {
      this.seekTo(this.params['start-at']);
      this.player.playVideo();
      this.element.dispatchEvent(new CustomEvent('video-background-play', { bubbles: true, detail: this }));
    }

    if (event.data === 1) {
      this.iframe.style.opacity = 1;
    }

    this.params["onStatusChange"](event);
  };

  YoutubeBackground.prototype.injectPlayer = function () {
    this.iframe = document.createElement('iframe');
    this.iframe.setAttribute('frameborder', 0);
    this.iframe.setAttribute('allow', 'autoplay; mute');
    let src = `https://www.youtube.com/embed/${this.ytid}?&enablejsapi=1&disablekb=1&controls=0&rel=0&iv_load_policy=3&cc_load_policy=0&playsinline=1&showinfo=0&modestbranding=1&fs=0`;

    if (this.params.muted) {
      src += '&mute=1';
    }

    if (this.params.autoplay) {
      src += '&autoplay=1';
    }

    if (this.params.loop) {
      src += '&loop=1';
    }

    if (this.params['end-at'] > 0) {
      src += `&end=${this.params['end-at']}`;
    }

    this.iframe.src = src;

    if (this.uid) {
      this.iframe.id = this.uid;
    }

    if (this.params['inline-styles']) {
      this.iframe.style.top = '50%';
      this.iframe.style.left = '50%';
      this.iframe.style.transform = 'translateX(-50%) translateY(-50%)';
      this.iframe.style.position = 'absolute';
      this.iframe.style.opacity = 0;
    }

    this.element.appendChild(this.iframe);

    if (this.params['fit-box']) {
      this.iframe.style.width = '100%';
      this.iframe.style.height = '100%';
    } else {
      const self = this;

      //TODO: maybe a spacer or at least add requestAnimationFrame
      function onResize() {
        const h = self.iframe.parentNode.offsetHeight + self.params.offset; // since showinfo is deprecated and ignored after September 25, 2018. we add +200 to hide it in the overflow
        const w = self.iframe.parentNode.offsetWidth + self.params.offset;
        const res = self.params.resolution_mod;

        if (res > w/h) {
          self.iframe.style.width = h*res + 'px';
          self.iframe.style.height = h + 'px';
        } else {
          self.iframe.style.width = w + 'px';
          self.iframe.style.height = w/res + 'px';
        }
      }

      if (window.hasOwnProperty('ResizeObserver')) {
        const resize_observer = new ResizeObserver(() => {
          window.requestAnimationFrame(onResize);
        });
        resize_observer.observe(this.element);
      } else {
        window.addEventListener('resize', () => {
          window.requestAnimationFrame(onResize);
        });
      }
      onResize();
    }
  };

  YoutubeBackground.prototype.buildHTML = function () {
    const parent = this.element.parentNode;
    // wrap
    addClass(this.element, 'youtube-background video-background');

    //set css rules
    const wrapper_styles = {
      "height" : "100%",
      "width" : "100%",
      "z-index": "0",
      "position": "absolute",
      "overflow": "hidden",
      "top": 0, // added by @insad
      "left": 0,
      "bottom": 0,
      "right": 0
    };

    if (!this.params['mute-button']) {
      wrapper_styles["pointer-events"] = "none"; // avoid right mouse click popup menu
    }

    if (this.params['load-background'] || this.params['poster']) {
      if (this.params['load-background']) wrapper_styles['background-image'] = 'url(https://img.youtube.com/vi/'+this.ytid+'/maxresdefault.jpg)';
      if (this.params['poster']) wrapper_styles['background-image'] = this.params['poster'];
      wrapper_styles['background-size'] = 'cover';
      wrapper_styles['background-repeat'] = 'no-repeat';
      wrapper_styles['background-position'] = 'center';
    }

    if (this.params['inline-styles']) {
      for (let property in wrapper_styles) {
        this.element.style[property] = wrapper_styles[property];
      }
      
      if (!['absolute', 'fixed', 'relative', 'sticky'].indexOf(parent.style.position)) {
        parent.style.position = 'relative';
      }
    }

    if (this.is_mobile && !this.params.mobile) {
      return this.element;
    }

    // set play/mute controls wrap
    if (this.params['play-button'] || this.params['mute-button']) {
      const controls = document.createElement('div');
      controls.className = 'video-background-controls';

      controls.style.position = 'absolute';
      controls.style.top = '10px';
      controls.style.right = '10px';
      controls.style['z-index'] = 2;

      this.controls_element = controls;
      parent.appendChild(controls);
    }

    return this.element;
  };

  YoutubeBackground.prototype.play = function () {
    //TODO: solve this with ARIA toggle states. P.S. warning repetitive code!!!
    if (this.buttons.hasOwnProperty('play')) {
      const btn_obj = this.buttons.play;
      removeClass(btn_obj.element, btn_obj.button_properties.stateClassName);
      addClass(btn_obj.element.firstChild, btn_obj.button_properties.stateChildClassNames[0]);
      removeClass(btn_obj.element.firstChild, btn_obj.button_properties.stateChildClassNames[1]);
    }

    if (this.player) {
      if (this.params['start-at'] && this.player.getCurrentTime() < this.params['start-at'] ) {
        this.seekTo(this.params['start-at']);
      }
      this.player.playVideo();
      this.element.dispatchEvent(new CustomEvent('video-background-play', { bubbles: true, detail: this }));
    }
  };

  YoutubeBackground.prototype.pause = function () {
    //TODO: solve this with ARIA toggle states
    if (this.buttons.hasOwnProperty('play')) {
      const btn_obj = this.buttons.play;
      addClass(btn_obj.element, btn_obj.button_properties.stateClassName);
      removeClass(btn_obj.element.firstChild, btn_obj.button_properties.stateChildClassNames[0]);
      addClass(btn_obj.element.firstChild, btn_obj.button_properties.stateChildClassNames[1]);
    }

    if (this.player) {
      this.player.pauseVideo();
      this.element.dispatchEvent(new CustomEvent('video-background-pause', { bubbles: true, detail: this }));
    }
  };

  YoutubeBackground.prototype.unmute = function () {
    //TODO: solve this with ARIA toggle states
    if (this.buttons.hasOwnProperty('mute')) {
      const btn_obj = this.buttons.mute;
      removeClass(btn_obj.element, btn_obj.button_properties.stateClassName);
      addClass(btn_obj.element.firstChild, btn_obj.button_properties.stateChildClassNames[0]);
      removeClass(btn_obj.element.firstChild, btn_obj.button_properties.stateChildClassNames[1]);
    }

    if (this.player) {
      this.player.unMute();
      this.element.dispatchEvent(new CustomEvent('video-background-unmute', { bubbles: true, detail: this }));
    }
  };

  YoutubeBackground.prototype.mute = function () {
    //TODO: solve this with ARIA toggle states
    if (this.buttons.hasOwnProperty('mute')) {
      const btn_obj = this.buttons.mute;
      addClass(btn_obj.element, btn_obj.button_properties.stateClassName);
      removeClass(btn_obj.element.firstChild, btn_obj.button_properties.stateChildClassNames[0]);
      addClass(btn_obj.element.firstChild, btn_obj.button_properties.stateChildClassNames[1]);
    }

    if (this.player) {
      this.player.mute();
      this.element.dispatchEvent(new CustomEvent('video-background-mute', { bubbles: true, detail: this }));
    }
  };

  //TODO: refactor states to be equal for all buttons
  YoutubeBackground.prototype.generateActionButton = function (obj) {
    const btn = document.createElement('button');
    btn.className = obj.className;
    btn.innerHTML = obj.innerHtml;
    addClass(btn.firstChild, obj.stateChildClassNames[0]);

    //TODO: solve this with ARIA toggle states
    if (this.params[obj.condition_parameter] === obj.initialState) {
      addClass(btn, obj.stateClassName);
      removeClass(btn.firstChild, obj.stateChildClassNames[0]);
      addClass(btn.firstChild, obj.stateChildClassNames[1]);
    }

    const self = this;
    btn.addEventListener('click', function(e) {
      if (hasClass(this, obj.stateClassName)) {
        self.state[obj.name] = false;
        self[obj.actions[0]]();
      } else {
        self.state[obj.name] = true;
        self[obj.actions[1]]();
      }
    });

    this.buttons[obj.name] = {
      element: btn,
      button_properties: obj
    };

    this.controls_element.appendChild(btn);
  };

  function VimeoBackground(elem, params, id, uid) {
    this.is_mobile = isMobile();

    this.element = elem;
    this.vid = id;
    this.uid = uid;
    this.player = null;
    this.buttons = {};

    this.state = {};
    this.state.play = false;
    this.state.mute = false;

    this.params = {};

    const DEFAULTS = {
  //    'pause': false, //deprecated
  //    'play-button': false,
  //    'mute-button': false,
      'autoplay': true,
      'muted': true,
      'loop': true,
      'mobile': false,
  //    'load-background': true,
      'resolution': '16:9',
      'inline-styles': true,
      'fit-box': false,
      'offset': 200,
      'start-at': 0,
      'poster': null
    };

    this.__init__ = function () {
      if (!this.vid) {
        return;
      }

      this.params = parseProperties(params, DEFAULTS, this.element, ['data-ytbg-', 'data-vbg-']);
      //pause deprecated
      if (this.params.pause) {
        this.params['play-button'] = this.params.pause;
      }
      this.params.resolution_mod = parseResolutionString(this.params.resolution);
      this.state.playing = this.params.autoplay;
      this.state.muted = this.params.muted;

      this.buildHTML();
      this.injectPlayer();
    };

    this.__init__();
  }

  VimeoBackground.prototype.injectPlayer = function () {
    this.iframe = document.createElement('iframe');
    this.iframe.setAttribute('frameborder', 0);
    this.iframe.setAttribute('allow', ['autoplay; mute']);
    let src = 'https://player.vimeo.com/video/'+this.vid+'?background=1&controls=0';

    if (this.params.muted) {
      src += '&muted=1';
    }

    if (this.params.autoplay) {
      src += '&autoplay=1';
    }

    if (this.params.loop) {
      src += '&loop=1&autopause=0';
    }

    //WARN this is a hash not a query param
    if (this.params['start-at']) {
      src += '#t=' + this.params['start-at'] + 's';
    }

    this.iframe.src = src;

    if (this.uid) {
      this.iframe.id = this.uid;
    }

    if (this.params['load-background'] || this.params['poster']) {
      //if (this.params['load-background']) wrapper_styles['background-image'] = 'url(https://img.youtube.com/vi/'+this.ytid+'/maxresdefault.jpg)';
      if (this.params['poster']) wrapper_styles['background-image'] = this.params['poster'];
      wrapper_styles['background-size'] = 'cover';
      wrapper_styles['background-repeat'] = 'no-repeat';
      wrapper_styles['background-position'] = 'center';
    }

    if (this.params['inline-styles']) {
      this.iframe.style.top = '50%';
      this.iframe.style.left = '50%';
      this.iframe.style.transform = 'translateX(-50%) translateY(-50%)';
      this.iframe.style.position = 'absolute';
      this.iframe.style.opacity = 1;
    }

    this.element.appendChild(this.iframe);

    if (this.params['fit-box']) {
      this.iframe.style.width = '100%';
      this.iframe.style.height = '100%';
    } else {
      const self = this;

      const onResize = function() {
        const h = self.iframe.parentNode.offsetHeight + self.params.offset; // since showinfo is deprecated and ignored after September 25, 2018. we add +200 to hide it in the overflow
        const w = self.iframe.parentNode.offsetWidth + self.params.offset;
        const res = self.params.resolution_mod;

        if (res > w/h) {
          self.iframe.style.width = h*res + 'px';
          self.iframe.style.height = h + 'px';
        } else {
          self.iframe.style.width = w + 'px';
          self.iframe.style.height = w/res + 'px';
        }
      };

      if (window.hasOwnProperty('ResizeObserver')) {
        const resize_observer = new ResizeObserver(() => {
          window.requestAnimationFrame(onResize);
        });
        resize_observer.observe(this.element);
      } else {
        window.addEventListener('resize', () => {
          window.requestAnimationFrame(onResize);
        });
      }
      onResize();
    }
  };

  VimeoBackground.prototype.buildHTML = function () {
    const parent = this.element.parentNode;
    // wrap
    addClass(this.element, 'youtube-background');

    //set css rules
    const wrapper_styles = {
      "height" : "100%",
      "width" : "100%",
      "z-index": "0",
      "position": "absolute",
      "overflow": "hidden",
      "top": 0, // added by @insad
      "left": 0,
      "bottom": 0,
      "right": 0
    };

    if (this.params['load-background'] || this.params['poster']) {
      //if (this.params['load-background']) wrapper_styles['background-image'] = 'url(https://img.youtube.com/vi/'+this.ytid+'/maxresdefault.jpg)';
      if (this.params['poster']) wrapper_styles['background-image'] = this.params['poster'];
      wrapper_styles['background-size'] = 'cover';
      wrapper_styles['background-repeat'] = 'no-repeat';
      wrapper_styles['background-position'] = 'center';
    }

    if (!this.params['mute-button']) {
      wrapper_styles["pointer-events"] = "none"; // avoid right mouse click popup menu
    }

    if (this.params['load-background']) {
      //TODO: wrapper_styles['background-image'] = 'url(https://img.youtube.com/vi/'+this.vid+'/maxresdefault.jpg)';
      wrapper_styles['background-size'] = 'cover';
      wrapper_styles['background-repeat'] = 'no-repeat';
      wrapper_styles['background-position'] = 'center';
    }

    if (this.params['inline-styles']) {
      for (let property in wrapper_styles) {
        this.element.style[property] = wrapper_styles[property];
      }

      if (!['absolute', 'fixed', 'relative', 'sticky'].indexOf(parent.style.position)) {
        parent.style.position = 'relative';
      }
    }

    return this.element;
  };

  function VideoBackground(elem, params, vid_data, uid) {
    this.is_mobile = isMobile();

    this.element = elem;
    this.link = vid_data.link;
    this.ext = vid_data.id;
    this.uid = uid;
    this.player = null;
    this.buttons = {};

    this.state = {};
    this.state.play = false;
    this.state.mute = false;

    this.params = {};

    const MIME_MAP = {
      'ogv' : 'video/ogg',
      'ogm' : 'video/ogg',
      'ogg' : 'video/ogg',
      'avi' : 'video/avi',
      'mp4' : 'video/mp4',
      'webm' : 'video/webm'
    };

    const DEFAULTS = {
      'pause': false, //deprecated
      'play-button': false,
      'mute-button': false,
      'autoplay': true,
      'muted': true,
      'loop': true,
      'mobile': false,
      'resolution': '16:9',
      'inline-styles': true,
      'fit-box': false,
      'offset': 200,
  //    'start-at': 0,
  //    'end-at': 0,
      'poster': null
    };

    this.__init__ = function () {
      if (!this.link || !this.ext) {
        return;
      }

      this.mime = MIME_MAP[this.ext.toLowerCase()];
      this.params = parseProperties(params, DEFAULTS, this.element, ['data-ytbg-', 'data-vbg-']);
      //pause deprecated
      if (this.params.pause) {
        this.params['play-button'] = this.params.pause;
      }
      this.params.resolution_mod = parseResolutionString(this.params.resolution);
      this.state.playing = this.params.autoplay;
      this.state.muted = this.params.muted;

      this.buildHTML();
      this.injectPlayer();


      if (this.params['play-button']) {
        this.generateActionButton({
          name: 'play',
          className: 'play-toggle',
          innerHtml: '<i class="fa"></i>',
          initialState: false,
          stateClassName: 'paused',
          condition_parameter: 'autoplay',
          stateChildClassNames: ['fa-pause-circle', 'fa-play-circle'],
          actions: ['play', 'pause']
        });
      }

      if (this.params['mute-button']) {
        this.generateActionButton({
          name: 'mute',
          className: 'mute-toggle',
          innerHtml: '<i class="fa"></i>',
          initialState: true,
          stateClassName: 'muted',
          condition_parameter: 'muted',
          stateChildClassNames: ['fa-volume-up', 'fa-volume-mute'],
          actions: ['unmute', 'mute']
        });
      }
    };

    this.__init__();
  }

  VideoBackground.prototype.seekTo = function (seconds) {
    if (this.player.hasOwnProperty('fastSeek')) {
      this.player.fastSeek(seconds);
      return;
    }
    this.player.currentTime = seconds;
  };

  VideoBackground.prototype.injectPlayer = function () {
    this.player = document.createElement('video');
    this.player.muted = this.params.muted;
    this.player.autoplay = this.params.autoplay;
    this.player.loop = this.params.loop;
    this.player.playsinline = true;

    this.player.setAttribute('id', this.uid);

    if (this.params['inline-styles']) {
      this.player.style.top = '50%';
      this.player.style.left = '50%';
      this.player.style.transform = 'translateX(-50%) translateY(-50%)';
      this.player.style.position = 'absolute';
      this.player.style.opacity = 0;

      this.player.addEventListener('canplay', (e) => {
        e.target.style.opacity = 1;
      });
    }

    const self = this;
    /*
    this.player.addEventListener('canplay', (e) => {
      if (self.params['start-at'] && self.params.autoplay) {
        self.seekTo(self.params['start-at']);
      }
    });

    this.player.addEventListener('canplaythrough', (e) => {
      if (self.params['end-at'] > 0) {
      self.player.addEventListener('timeupdate', (e) => {
        if (self.params['end-at'] >= self.player.currentTime) {
          self.seekTo(self.params['start-at']);
        }
      });
    }
    });
    */

    const source = document.createElement('source');
    source.setAttribute('src', this.link);
    source.setAttribute('type', this.mime);
    this.player.appendChild(source);
    this.element.appendChild(this.player);

    if (this.params['fit-box']) {
      this.player.style.width = '100%';
      this.player.style.height = '100%';
    } else {
      //TODO: maybe a spacer or at least add requestAnimationFrame
      function onResize() {
        const h = self.player.parentNode.offsetHeight + self.params.offset; // since showinfo is deprecated and ignored after September 25, 2018. we add +200 to hide it in the overflow
        const w = self.player.parentNode.offsetWidth + self.params.offset;
        const res = self.params.resolution_mod;

        if (res > w/h) {
          self.player.style.width = h*res + 'px';
          self.player.style.height = h + 'px';
        } else {
          self.player.style.width = w + 'px';
          self.player.style.height = w/res + 'px';
        }
      }

      if (window.hasOwnProperty('ResizeObserver')) {
        const resize_observer = new ResizeObserver(() => {
          window.requestAnimationFrame(onResize);
        });
        resize_observer.observe(this.element);
      } else {
        window.addEventListener('resize', () => {
          window.requestAnimationFrame(onResize);
        });
      }
      onResize();
    }
  };

  VideoBackground.prototype.buildHTML = function () {
    const parent = this.element.parentNode;
    // wrap
    addClass(this.element, 'video-background');

    //set css rules
    const wrapper_styles = {
      "height" : "100%",
      "width" : "100%",
      "z-index": "0",
      "position": "absolute",
      "overflow": "hidden",
      "top": 0, // added by @insad
      "left": 0,
      "bottom": 0,
      "right": 0
    };

    if (!this.params['mute-button']) {
      wrapper_styles["pointer-events"] = "none"; // avoid right mouse click popup menu
    }

    if (this.params['load-background'] || this.params['poster']) {
      if (this.params['poster']) wrapper_styles['background-image'] = `url('${this.params['poster']}')`;
      wrapper_styles['background-size'] = 'cover';
      wrapper_styles['background-repeat'] = 'no-repeat';
      wrapper_styles['background-position'] = 'center';
    }

    if (this.params['inline-styles']) {
      for (let property in wrapper_styles) {
        this.element.style[property] = wrapper_styles[property];
      }

      if (!['absolute', 'fixed', 'relative', 'sticky'].indexOf(parent.style.position)) {
        parent.style.position = 'relative';
      }
    }

    if (this.is_mobile && !this.params.mobile) {
      return this.element;
    }

    // set play/mute controls wrap
    if (this.params['play-button'] || this.params['mute-button']) {
      const controls = document.createElement('div');
      controls.className = 'video-background-controls';

      controls.style.position = 'absolute';
      controls.style.top = '10px';
      controls.style.right = '10px';
      controls.style['z-index'] = 2;

      this.controls_element = controls;
      parent.appendChild(controls);
    }

    return this.element;
  };

  VideoBackground.prototype.play = function () {
    //TODO: solve this with ARIA toggle states. P.S. warning repetitive code!!!
    if (this.buttons.hasOwnProperty('play')) {
      const btn_obj = this.buttons.play;
      removeClass(btn_obj.element, btn_obj.button_properties.stateClassName);
      addClass(btn_obj.element.firstChild, btn_obj.button_properties.stateChildClassNames[0]);
      removeClass(btn_obj.element.firstChild, btn_obj.button_properties.stateChildClassNames[1]);
    }

    if (this.player) {
      /* if (this.params['start-at'] && this.player.currentTime < this.params['start-at'] ) {
        this.seekTo(this.params['start-at']);
      } */
      this.player.play();
      this.element.dispatchEvent(new CustomEvent('video-background-play', { bubbles: true, detail: this }));
    }
  };

  VideoBackground.prototype.pause = function () {
    //TODO: solve this with ARIA toggle states
    if (this.buttons.hasOwnProperty('play')) {
      const btn_obj = this.buttons.play;
      addClass(btn_obj.element, btn_obj.button_properties.stateClassName);
      removeClass(btn_obj.element.firstChild, btn_obj.button_properties.stateChildClassNames[0]);
      addClass(btn_obj.element.firstChild, btn_obj.button_properties.stateChildClassNames[1]);
    }

    if (this.player) {
      this.player.pause();
      this.element.dispatchEvent(new CustomEvent('video-background-pause', { bubbles: true, detail: this }));
    }
  };

  VideoBackground.prototype.unmute = function () {
    //TODO: solve this with ARIA toggle states
    if (this.buttons.hasOwnProperty('mute')) {
      const btn_obj = this.buttons.mute;
      removeClass(btn_obj.element, btn_obj.button_properties.stateClassName);
      addClass(btn_obj.element.firstChild, btn_obj.button_properties.stateChildClassNames[0]);
      removeClass(btn_obj.element.firstChild, btn_obj.button_properties.stateChildClassNames[1]);
    }

    if (this.player) {
      this.player.muted = false;
      this.element.dispatchEvent(new CustomEvent('video-background-unmute', { bubbles: true, detail: this }));
    }
  };

  VideoBackground.prototype.mute = function () {
    //TODO: solve this with ARIA toggle states
    if (this.buttons.hasOwnProperty('mute')) {
      const btn_obj = this.buttons.mute;
      addClass(btn_obj.element, btn_obj.button_properties.stateClassName);
      removeClass(btn_obj.element.firstChild, btn_obj.button_properties.stateChildClassNames[0]);
      addClass(btn_obj.element.firstChild, btn_obj.button_properties.stateChildClassNames[1]);
    }

    if (this.player) {
      this.player.muted = true;
      this.element.dispatchEvent(new CustomEvent('video-background-mute', { bubbles: true, detail: this }));
    }
  };

  //TODO: refactor states to be equal for all buttons
  VideoBackground.prototype.generateActionButton = function (obj) {
    const btn = document.createElement('button');
    btn.className = obj.className;
    btn.innerHTML = obj.innerHtml;
    addClass(btn.firstChild, obj.stateChildClassNames[0]);

    //TODO: solve this with ARIA toggle states
    if (this.params[obj.condition_parameter] === obj.initialState) {
      addClass(btn, obj.stateClassName);
      removeClass(btn.firstChild, obj.stateChildClassNames[0]);
      addClass(btn.firstChild, obj.stateChildClassNames[1]);
    }

    const self = this;
    btn.addEventListener('click', function(e) {
      if (hasClass(this, obj.stateClassName)) {
        self.state[obj.name] = false;
        self[obj.actions[0]]();
      } else {
        self.state[obj.name] = true;
        self[obj.actions[1]]();
      }
    });

    this.buttons[obj.name] = {
      element: btn,
      button_properties: obj
    };

    this.controls_element.appendChild(btn);
  };

  function VideoBackgrounds(selector, params) {
    this.elements = selector;

    if (typeof selector === 'string') {
      this.elements = document.querySelectorAll(selector);
    }

    this.index = {};
    this.re = {};
    this.re.YOUTUBE = /(?:youtube\.com\/(?:[^\/]+\/.+\/|(?:v|e(?:mbed)?)\/|.*[?&]v=)|youtu\.be\/)([^"&?\/ ]{11})/i;
    this.re.VIMEO = /(?:www\.|player\.)?vimeo.com\/(?:channels\/(?:\w+\/)?|groups\/(?:[^\/]*)\/videos\/|album\/(?:\d+)\/video\/|video\/|)(\d+)(?:[a-zA-Z0-9_\-]+)?/i;
    this.re.VIDEO = /\/[^\/]+\.(mp4|ogg|ogv|ogm|webm|avi)\s?$/i;

    this.__init__ = function () {
      for (let i = 0; i < this.elements.length; i++) {
        const element = this.elements[i];

        const link = element.getAttribute('data-youtube') || element.getAttribute('data-vbg');
        const vid_data = this.getVidID(link);

        if (!vid_data) {
          continue;
        }

        const uid = this.generateUID(vid_data.id);

        if (!uid) {
          continue;
        }

        switch (vid_data.type) {
          case 'YOUTUBE':
            const yb = new YoutubeBackground(element, params, vid_data.id, uid);
            this.index[uid] = yb;
            break;
          case 'VIMEO':
            const vm = new VimeoBackground(element, params, vid_data.id, uid);
            this.index[uid] = vm;
            break;
          case 'VIDEO':
            const vid = new VideoBackground(element, params, vid_data, uid);
            this.index[uid] = vid;
            break;
        }
      }

      this.initYTPlayers(/*function() {
        //TODO: FIX!
        if (params &&
          (params.hasOwnProperty('activity_timeout')
            || params.hasOwnProperty('inactivity_timeout'))) {
          this.activity_monitor = new ActivityMonitor(function () {
              self.playVideos();
            }, function() {
              self.pauseVideos();
            },
            params ? params.activity_timeout : null,
            params ? params.inactivity_timeout : null,
            ['mousemove', 'scroll']
          );
        }
      }*/);
    };

    this.__init__();
  }

  VideoBackgrounds.prototype.getVidID = function (link) {
    if (link !== undefined && link !== null) {
      for (let k in this.re) {
        const pts = link.match(this.re[k]);

        if (pts && pts.length) {
          this.re[k].lastIndex = 0;
          return {
            id: pts[1],
            type: k,
            regex_pts: pts,
            link: link
          };
        }
      }
    }

    return null;
  };


  VideoBackgrounds.prototype.generateUID = function (pref) {
    //index the instance
    let uid = pref +'-'+ getRandomIntInclusive(0, 9999);
    while (this.index.hasOwnProperty(uid)) {
      uid = pref +'-'+ getRandomIntInclusive(0, 9999);
    }

    return uid;
  };

  VideoBackgrounds.prototype.pauseVideos = function () {
    for (let k in this.index) {
      this.index[k].pause();
    }
  };

  VideoBackgrounds.prototype.playVideos = function () {
    for (let k in this.index) {
      this.index[k].play();
    }
  };

  VideoBackgrounds.prototype.initYTPlayers = function (callback) {
    const self = this;

    window.onYouTubeIframeAPIReady = function () {
      for (let k in self.index) {
        if (self.index[k] instanceof YoutubeBackground) {
          self.index[k].initYTPlayer();
        }
      }

      if (callback) {
        setTimeout(callback, 100);
      }
    };

    if (window.hasOwnProperty('YT') && window.YT.loaded) {
      window.onYouTubeIframeAPIReady();
    }
  };

  if (typeof jQuery == 'function') {
    (function ($) {
      $.fn.youtube_background = function (params) {
        const $this = $(this);
        new VideoBackgrounds(this, params);
        return $this;
      };
    })(jQuery);
  }

  window.VideoBackgrounds = VideoBackgrounds;

})();


/***/ }),

/***/ "./jumpapp/.jump-version":
/*!*******************************!*\
  !*** ./jumpapp/.jump-version ***!
  \*******************************/
/***/ ((module) => {

"use strict";
module.exports = "v1.2.3 (1659268610)";

/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			// no module.id needed
/******/ 			// no module.loaded needed
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId](module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/************************************************************************/
/******/ 	/* webpack/runtime/compat get default export */
/******/ 	(() => {
/******/ 		// getDefaultExport function for compatibility with non-harmony modules
/******/ 		__webpack_require__.n = (module) => {
/******/ 			var getter = module && module.__esModule ?
/******/ 				() => (module['default']) :
/******/ 				() => (module);
/******/ 			__webpack_require__.d(getter, { a: getter });
/******/ 			return getter;
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/define property getters */
/******/ 	(() => {
/******/ 		// define getter functions for harmony exports
/******/ 		__webpack_require__.d = (exports, definition) => {
/******/ 			for(var key in definition) {
/******/ 				if(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {
/******/ 					Object.defineProperty(exports, key, { enumerable: true, get: definition[key] });
/******/ 				}
/******/ 			}
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/hasOwnProperty shorthand */
/******/ 	(() => {
/******/ 		__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/make namespace object */
/******/ 	(() => {
/******/ 		// define __esModule on exports
/******/ 		__webpack_require__.r = (exports) => {
/******/ 			if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 				Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 			}
/******/ 			Object.defineProperty(exports, '__esModule', { value: true });
/******/ 		};
/******/ 	})();
/******/ 	
/************************************************************************/
var __webpack_exports__ = {};
// This entry need to be wrapped in an IIFE because it need to be in strict mode.
(() => {
"use strict";
/*!****************************************!*\
  !*** ./jumpapp/assets/js/src/index.js ***!
  \****************************************/
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _classes_Main__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./classes/Main */ "./jumpapp/assets/js/src/classes/Main.js");
/* harmony import */ var _jump_version__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../../.jump-version */ "./jumpapp/.jump-version");
/* harmony import */ var youtube_background__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! youtube-background */ "./node_modules/youtube-background/jquery.youtube-background.js");
/* harmony import */ var youtube_background__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(youtube_background__WEBPACK_IMPORTED_MODULE_2__);
/**
 * Do some fancy UI stuff in a rather unfancy way.
 *
 * @author Dale Davies <dale@daledavies.co.uk>
 * @license MIT
 */





console.info(`%c
----------------------------------

                
                 
              
              
             

https://github.com/daledavies/jump

----------------------------------

     Jump ${_jump_version__WEBPACK_IMPORTED_MODULE_1__}

----------------------------------

`, "font-family:monospace");

let jumpapp = new _classes_Main__WEBPACK_IMPORTED_MODULE_0__["default"]();
jumpapp.init();

new VideoBackgrounds('[data-vbg]');

})();

/******/ })()
;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiaW5kZXguNjg0ZTk4MTEwOTg2ZmQ0NzhlMTQubWluLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7O0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFZTtBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUOztBQUVBOzs7Ozs7Ozs7Ozs7Ozs7OztBQzdGNEI7O0FBRWI7O0FBRWY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FDdkI0QjtBQUNhO0FBQ2Q7QUFDTztBQUNrQjtBQUNwQjs7QUFFakI7O0FBRWY7QUFDQTtBQUNBO0FBQ0EscUNBQXFDO0FBQ3JDLHdDQUF3QztBQUN4QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0NBQWdDLHNEQUFZO0FBQzVDLHlCQUF5Qiw4Q0FBSztBQUM5QiwyQkFBMkIsZ0RBQU87O0FBRWxDO0FBQ0E7QUFDQSw0QkFBNEIsK0NBQUk7QUFDaEM7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTOztBQUVUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQ0FBbUMsaURBQVE7QUFDM0M7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQTtBQUNBO0FBQ0EsU0FBUzs7QUFFVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0EsYUFBYTtBQUNiLGFBQWEseUJBQXlCO0FBQ3RDLFNBQVM7O0FBRVQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiOztBQUVBO0FBQ0E7QUFDQSx5Q0FBeUMsMERBQWlCOztBQUUxRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhOztBQUViO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQjtBQUN0QjtBQUNBO0FBQ0E7QUFDQSxhQUFhOztBQUViO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTs7QUFFYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBLGFBQWE7O0FBRWI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7Ozs7Ozs7Ozs7Ozs7OztBQzVPQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRWU7O0FBRWY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7Ozs7O0FDekhlOztBQUVmO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FB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QSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLFdBQVc7QUFDWDs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBLDRDQUE0QyxTQUFTO0FBQ3JEO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FB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QUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSx3Q0FBd0MsU0FBUztBQUNqRDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxZQUFZLGtDQUFrQzs7QUFFOUM7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTs7QUFFTjtBQUNBO0FBQ0E7O0FBRUEsMkJBQTJCLCtCQUErQjtBQUMxRCxjQUFjLDBCQUEwQjtBQUN4QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87O0FBRVA7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLHlDQUF5QztBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0Esd0NBQXdDLFNBQVM7QUFDakQ7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtB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QUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGlEQUFpRDtBQUNqRDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRFQUE0RSw2QkFBNkI7QUFDekc7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSw2RUFBNkUsNkJBQTZCO0FBQzFHO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsOEVBQThFLDZCQUE2QjtBQUMzRztBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLDRFQUE0RSw2QkFBNkI7QUFDekc7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxrREFBa0Q7QUFDbEQ7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjs7QUFFQTtBQUNBLDRFQUE0RTtBQUM1RTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxpREFBaUQ7QUFDakQ7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBLDRFQUE0RTtBQUM1RTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxpREFBaUQ7QUFDakQ7O0FBRUE7QUFDQSw4RUFBOEUsc0JBQXNCO0FBQ3BHO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBLDRFQUE0RSw2QkFBNkI7QUFDekc7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSw2RUFBNkUsNkJBQTZCO0FBQzFHO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsOEVBQThFLDZCQUE2QjtBQUMzRztBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLDRFQUE0RSw2QkFBNkI7QUFDekc7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSw0R0FBNEcsR0FBRztBQUMvRztBQUNBOztBQUVBO0FBQ0Esc0JBQXNCLDBCQUEwQjtBQUNoRDs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTs7QUFFQSxDQUFDOzs7Ozs7Ozs7Ozs7Ozs7Ozs7VUNqbkNEO1VBQ0E7O1VBRUE7VUFDQTtVQUNBO1VBQ0E7VUFDQTtVQUNBO1VBQ0E7VUFDQTtVQUNBO1VBQ0E7VUFDQTtVQUNBO1VBQ0E7O1VBRUE7VUFDQTs7VUFFQTtVQUNBO1VBQ0E7Ozs7O1dDdEJBO1dBQ0E7V0FDQTtXQUNBO1dBQ0E7V0FDQSxpQ0FBaUMsV0FBVztXQUM1QztXQUNBOzs7OztXQ1BBO1dBQ0E7V0FDQTtXQUNBO1dBQ0EseUNBQXlDLHdDQUF3QztXQUNqRjtXQUNBO1dBQ0E7Ozs7O1dDUEE7Ozs7O1dDQUE7V0FDQTtXQUNBO1dBQ0EsdURBQXVELGlCQUFpQjtXQUN4RTtXQUNBLGdEQUFnRCxhQUFhO1dBQzdEOzs7Ozs7Ozs7Ozs7Ozs7O0FDTkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVrQztBQUNXO0FBQ2pCOztBQUU1QjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUEsWUFBWSwwQ0FBTzs7QUFFbkI7O0FBRUE7O0FBRUEsa0JBQWtCLHFEQUFJO0FBQ3RCOztBQUVBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vanVtcC8uL2p1bXBhcHAvYXNzZXRzL2pzL3NyYy9jbGFzc2VzL0Nsb2NrLmpzIiwid2VicGFjazovL2p1bXAvLi9qdW1wYXBwL2Fzc2V0cy9qcy9zcmMvY2xhc3Nlcy9HcmVldGluZy5qcyIsIndlYnBhY2s6Ly9qdW1wLy4vanVtcGFwcC9hc3NldHMvanMvc3JjL2NsYXNzZXMvTWFpbi5qcyIsIndlYnBhY2s6Ly9qdW1wLy4vanVtcGFwcC9hc3NldHMvanMvc3JjL2NsYXNzZXMvU2VhcmNoU3VnZ2VzdGlvbnMuanMiLCJ3ZWJwYWNrOi8vanVtcC8uL2p1bXBhcHAvYXNzZXRzL2pzL3NyYy9jbGFzc2VzL1dlYXRoZXIuanMiLCJ3ZWJwYWNrOi8vanVtcC8uL25vZGVfbW9kdWxlcy9ldmVudGVtaXR0ZXIzL2luZGV4LmpzIiwid2VicGFjazovL2p1bXAvLi9ub2RlX21vZHVsZXMvZnVzZS5qcy9kaXN0L2Z1c2UuZXNtLmpzIiwid2VicGFjazovL2p1bXAvLi9ub2RlX21vZHVsZXMveW91dHViZS1iYWNrZ3JvdW5kL2pxdWVyeS55b3V0dWJlLWJhY2tncm91bmQuanMiLCJ3ZWJwYWNrOi8vanVtcC93ZWJwYWNrL2Jvb3RzdHJhcCIsIndlYnBhY2s6Ly9qdW1wL3dlYnBhY2svcnVudGltZS9jb21wYXQgZ2V0IGRlZmF1bHQgZXhwb3J0Iiwid2VicGFjazovL2p1bXAvd2VicGFjay9ydW50aW1lL2RlZmluZSBwcm9wZXJ0eSBnZXR0ZXJzIiwid2VicGFjazovL2p1bXAvd2VicGFjay9ydW50aW1lL2hhc093blByb3BlcnR5IHNob3J0aGFuZCIsIndlYnBhY2s6Ly9qdW1wL3dlYnBhY2svcnVudGltZS9tYWtlIG5hbWVzcGFjZSBvYmplY3QiLCJ3ZWJwYWNrOi8vanVtcC8uL2p1bXBhcHAvYXNzZXRzL2pzL3NyYy9pbmRleC5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIENhbGN1bGF0ZSB0aGUgdGltZSwgbG9jYWwgdG8gdGhlIHJlcXVlc3RlZCBsb2NhdGlvbiBmcm9tXG4gKiB0aGUgT3BlbldlYXRoZXIgQVBJLCBieSBwYXNzaW5nIGluIHRoZSBudW1iZXIgb2Ygc2Vjb25kc1xuICogdGhhdCBsb2NhdGlvbiBoYXMgc2hpZnRlZCBmcm9tIFVUQyBiYXNlZCBvbiB0aGUgdGltZXpvbmVzLlxuICpcbiAqIEBhdXRob3IgRGFsZSBEYXZpZXMgPGRhbGVAZGFsZWRhdmllcy5jby51az5cbiAqIEBsaWNlbnNlIE1JVFxuICovXG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIENsb2NrIHtcbiAgICAvKipcbiAgICAgKiBDYWxjdWxhdGUgdGhlIHRpbWUgc2hpZnRlZCBmcm9tIFVUQy5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBib29sZWFuIGFtcG0gUmV0dXJuIDEyIGhvdXIgZm9ybWF0IGlmIHRydWUuXG4gICAgICogQHBhcmFtIG51bWJlciB1dGNzaGlmdCBOdW1iZXIgb2Ygc2Vjb25kcyB0byBzaGlmdCB0aW1lIGZyb20gVVRDLlxuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKGV2ZW50ZW1pdHRlciwgYW1wbSA9IGZhbHNlLCBmb3JjZWxvY2FsdGltZSA9IGZhbHNlKSB7XG4gICAgICAgIHRoaXMuc2V0X3V0Y19zaGlmdCgpO1xuICAgICAgICB0aGlzLmNvbnRlbnRpbnRlcnZhbGlkID0gbnVsbDtcbiAgICAgICAgdGhpcy5ldmVudGVtaXR0ZXIgPSBldmVudGVtaXR0ZXI7XG4gICAgICAgIHRoaXMuYW1wbSA9IGFtcG07XG4gICAgICAgIHRoaXMuZm9yY2Vsb2NhbHRpbWUgPSBmb3JjZWxvY2FsdGltZTtcbiAgICB9XG5cbiAgICBzZXRfdXRjX3NoaWZ0KG5ld3V0Y3NoaWZ0ID0gMCkge1xuICAgICAgICB0aGlzLnV0Y3NoaWZ0ID0gbmV3dXRjc2hpZnQ7XG4gICAgICAgIHRoaXMuc2hpZnRlZHRpbWVzdGFtcCA9IG5ldyBEYXRlKCkuZ2V0VGltZSgpK3RoaXMudXRjc2hpZnQ7XG4gICAgICAgIHRoaXMuc2hpZnRlZGRhdGUgPSBuZXcgRGF0ZSh0aGlzLnNoaWZ0ZWR0aW1lc3RhbXApO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJldHVybiBhIGZvcm1hdHRlZCBzdHJpbmcgcmVwcmVzZW50aW5nIHRpbWUgZm9yIGRpc3BsYXkgaW4gdGVtcGxhdGUuXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyBzdHJpbmcgVGhlIHRpbWUgc3RyaW5nLlxuICAgICAqL1xuICAgIGdldF9mb3JtYXR0ZWRfdGltZSgpIHtcbiAgICAgICAgLy8gV2UgbmVlZCB0byB1c2UgZ2V0VVRDSG91cnMgYW5kIGdldFVUQyBNaW51dGVzIGhlcmUgdG8gc3RvcFxuICAgICAgICAvLyB0aGUgRGF0ZSgpIG9iamVjdCBhZGp1c3RpbmcgdGhlIHJldHVybmVkIHRpbWUgcmVsYXRpdmUgdG8gdGhlXG4gICAgICAgIC8vIGJyb3dzZXIncyBsb2NhbCB0aW1lem9uZS5cbiAgICAgICAgbGV0IGhvdXIgPSB0aGlzLnNoaWZ0ZWRkYXRlLmdldFVUQ0hvdXJzKCk7XG4gICAgICAgIGxldCBtaW51dGVzID0gU3RyaW5nKHRoaXMuc2hpZnRlZGRhdGUuZ2V0VVRDTWludXRlcygpKS5wYWRTdGFydCgyLCAnMCcpO1xuXG4gICAgICAgIC8vIENvbXBsZXRlbHkgaWdub3JlIHRoZSBzaGlmdGVkIGRhdGUgYW5kIGp1c3QgcmV0dXJuIHdoYXRldmVyIGhhcHBlbnMgdG8gYmVcbiAgICAgICAgLy8gaW4gdGhlIGxvY2FsIHRpbWV6b25lLlxuICAgICAgICBpZiAodGhpcy5mb3JjZWxvY2FsdGltZSkge1xuICAgICAgICAgICAgaG91ciA9IG5ldyBEYXRlKCkuZ2V0SG91cnMoKTtcbiAgICAgICAgICAgIG1pbnV0ZXMgPSBTdHJpbmcobmV3IERhdGUoKS5nZXRNaW51dGVzKCkpLnBhZFN0YXJ0KDIsICcwJyk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIXRoaXMuYW1wbSkge1xuICAgICAgICAgICAgcmV0dXJuIFN0cmluZyhob3VyKS5wYWRTdGFydCgyLCAnMCcpICsgXCI6XCIgKyBtaW51dGVzO1xuICAgICAgICB9XG4gICAgICAgIC8vIENvbnZlcnQgdG8gMTIgaG91ciBBTS9QTSBmb3JtYXQgYW5kIHJldHVybi5cbiAgICAgICAgY29uc3Qgc3VmZml4ID0gaG91ciA8PSAxMiA/ICdBTSc6J1BNJztcbiAgICAgICAgaG91ciA9ICgoaG91ciArIDExKSAlIDEyICsgMSk7XG4gICAgICAgIHJldHVybiBob3VyICsgJzonICsgbWludXRlcyArICc8c3Bhbj4nICsgc3VmZml4ICsgJzwvc3Bhbj4nO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJldHVybnMganVzdCB0aGUgaG91ci5cbiAgICAgKlxuICAgICAqIEByZXR1cm5zIG51bWJlciBUaGUgaG91ci5cbiAgICAgKi9cbiAgICBnZXRfaG91cigpIHtcbiAgICAgICAgaWYgKHRoaXMuZm9yY2Vsb2NhbHRpbWUpIHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgRGF0ZSgpLmdldEhvdXJzKCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuc2hpZnRlZGRhdGUuZ2V0VVRDSG91cnMoKTtcbiAgICB9XG5cbiAgICB1cGRhdGVfdGltZSgpIHtcbiAgICAgICAgdGhpcy5zZXRfdXRjX3NoaWZ0KHRoaXMudXRjc2hpZnQpO1xuICAgICAgICB0aGlzLmV2ZW50ZW1pdHRlci5lbWl0KCdjbG9jay11cGRhdGVkJywge1xuICAgICAgICAgICAgZm9ybWF0dGVkX3RpbWU6IHRoaXMuZ2V0X2Zvcm1hdHRlZF90aW1lKCksXG4gICAgICAgICAgICBob3VyOiB0aGlzLmdldF9ob3VyKCksXG4gICAgICAgICAgICB1dGNzaGlmdDogdGhpcy51dGNzaGlmdFxuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICBydW4odXBkYXRlZnJlcXVlbmN5KSB7XG4gICAgICAgIC8vIENsZWFyIGFueSBwcmV2aW91c2x5IHNldCBpbnRlcnZhbHMgZm9yIHVwZGF0aW5nIGNvbnRlbnQuXG4gICAgICAgIGlmICh0aGlzLmNvbnRlbnRpbnRlcnZhbGlkKSB7XG4gICAgICAgICAgICBjbGVhckludGVydmFsKHRoaXMuY29udGVudGludGVydmFsaWQpO1xuICAgICAgICB9XG4gICAgICAgIC8vIFNldCB0aGUgY2xvY2sgYW5kIGdyZWV0aW5nIHRleHQgYXBwcm9wcmlhdGVseSBmb3IgdGhlIHJlcXVlc3RlZCBsb2NhdGlvbi5cbiAgICAgICAgdGhpcy51cGRhdGVfdGltZSgpO1xuICAgICAgICAvLyBVcGRhdGUgdGhlIGNvbnRlbnQgcGVyaW9kaWNhbGx5LCB3ZSBkb24ndCBuZWVkIHRvIGJlIHRvbyBmcmVxdWVudCBhcyB3ZSBhcmVcbiAgICAgICAgLy8gbm90IGRpc3BsYXlpbmcgc2Vjb25kcyBvbiB0aGUgY2xvY2suXG4gICAgICAgIHRoaXMuY29udGVudGludGVydmFsaWQgPSBzZXRJbnRlcnZhbCgoKSA9PiB7XG4gICAgICAgICAgICB0aGlzLnVwZGF0ZV90aW1lKCk7XG4gICAgICAgIH0sIHVwZGF0ZWZyZXF1ZW5jeSk7XG4gICAgfVxuXG59XG4iLCJpbXBvcnQgQ2xvY2sgZnJvbSBcIi4vQ2xvY2tcIjtcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgR3JlZXRpbmcge1xuXG4gICAgY29uc3RydWN0b3IoaG91cikge1xuICAgICAgICB0aGlzLmhvdXIgPSBob3VyO1xuICAgICAgICB0aGlzLmdyZWV0aW5ncyA9IHtcbiAgICAgICAgICAgIDAgIDogJ21vcm5pbmcnLFxuICAgICAgICAgICAgMTIgOiAnYWZ0ZXJub29uJyxcbiAgICAgICAgICAgIDE2IDogJ2V2ZW5pbmcnLFxuICAgICAgICAgICAgMTkgOiAnbmlnaHQnXG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgZ2V0X2dyZWV0aW5nKCkge1xuICAgICAgICBsZXQga2V5cyA9IE9iamVjdC5rZXlzKHRoaXMuZ3JlZXRpbmdzKS5yZXZlcnNlKCk7XG4gICAgICAgIGZvciAobGV0IGVsZW1lbnQgb2Yga2V5cykge1xuICAgICAgICAgICAgaWYgKHRoaXMuaG91ciA+PSBlbGVtZW50KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuZ3JlZXRpbmdzW2VsZW1lbnRdO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgIH1cblxufVxuIiwiaW1wb3J0IENsb2NrIGZyb20gJy4vQ2xvY2snO1xuaW1wb3J0IEV2ZW50RW1pdHRlciBmcm9tICdldmVudGVtaXR0ZXIzJztcbmltcG9ydCBGdXNlIGZyb20gJ2Z1c2UuanMnO1xuaW1wb3J0IEdyZWV0aW5nIGZyb20gJy4vR3JlZXRpbmcnO1xuaW1wb3J0IFNlYXJjaFN1Z2dlc3Rpb25zIGZyb20gJy4vU2VhcmNoU3VnZ2VzdGlvbnMnO1xuaW1wb3J0IFdlYXRoZXIgZnJvbSAnLi9XZWF0aGVyJztcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgTWFpbiB7XG5cbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgdGhpcy5sYXRsb25nID0gW107XG4gICAgICAgIHRoaXMuc3RvcmFnZSA9IHdpbmRvdy5sb2NhbFN0b3JhZ2U7XG4gICAgICAgIHRoaXMuY2xvY2tmcmVxdWVuY3kgPSAxMDAwMDsgLy8gMTAgc2Vjb25kcy5cbiAgICAgICAgdGhpcy53ZWF0aGVyZnJlcXVlbmN5ID0gMzAwMDAwOyAvLyA1IG1pbnV0ZXMuXG4gICAgICAgIHRoaXMudGltZXpvbmVzaGlmdCA9IDA7XG4gICAgICAgIHRoaXMubWV0cmljdGVtcCA9IEpVTVAubWV0cmljdGVtcDtcbiAgICAgICAgLy8gQ2FjaGUgc29tZSBET00gZWxlbWVudHMgdGhhdCB3ZSB3aWxsIGFjY2VzcyBmcmVxdWVudGx5LlxuICAgICAgICB0aGlzLmdyZWV0aW5nZWxtID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvcignLmdyZWV0aW5nIC5jaG9zZW4nKTtcbiAgICAgICAgdGhpcy5ob2xkZXJlbG0gPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKCcudGltZS13ZWF0aGVyJyk7XG4gICAgICAgIHRoaXMudGVtcGVsbSA9IHRoaXMuaG9sZGVyZWxtLnF1ZXJ5U2VsZWN0b3IoJy53ZWF0aGVyLWluZm8gLnRlbXAnKTtcbiAgICAgICAgdGhpcy53ZWF0aGVyZGVzY2VsbSA9IHRoaXMuaG9sZGVyZWxtLnF1ZXJ5U2VsZWN0b3IoJy53ZWF0aGVyLWluZm8gLmRlc2MnKTtcbiAgICAgICAgdGhpcy50aW1lZWxtID0gdGhpcy5ob2xkZXJlbG0ucXVlcnlTZWxlY3RvcignLnRpbWUnKTtcbiAgICAgICAgdGhpcy53ZWF0aGVyZWxtID0gdGhpcy5ob2xkZXJlbG0ucXVlcnlTZWxlY3RvcignLndlYXRoZXInKTtcbiAgICAgICAgdGhpcy53ZWF0aGVyaWNvbmVsbSA9IHRoaXMuaG9sZGVyZWxtLnF1ZXJ5U2VsZWN0b3IoJy53ZWF0aGVyLWljb24nKTtcbiAgICAgICAgdGhpcy5jbGllbnRsb2NhdGlvbmVsbSA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoJy51c2VjbGllbnRsb2NhdGlvbicpO1xuICAgICAgICB0aGlzLnNob3d0YWdzYnV0dG9uZWxtID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvcignLnNob3ctdGFncycpO1xuICAgICAgICB0aGlzLnRhZ3NlbGVjdG9yZWxtID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvcignLnRhZ3MnKTtcbiAgICAgICAgdGhpcy50YWdzc2VsZWN0b3JjbG9zZWJ1dHRvbmVsbSA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoJy50YWdzIC5jbG9zZScpO1xuICAgICAgICB0aGlzLnNob3dzZWFyY2hidXR0b25lbG0gPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKCcuc2VhcmNoJyk7XG4gICAgICAgIC8vIElmIHRoZSB1c2VyIGhhcyBwcmV2aW91c2x5IGFza2VkIGZvciBnZW9sb2NhdGlvbiB3ZSB3aWxsIGhhdmUgc3RvcmVkIHRoZSBsYXRsb25nLlxuICAgICAgICBpZiAodGhpcy5sYXN0cmVxdWVzdGVkbG9jYXRpb24gPSB0aGlzLnN0b3JhZ2UuZ2V0SXRlbSgnbGFzdHJlcXVlc3RlZGxvY2F0aW9uJykpe1xuICAgICAgICAgICAgdGhpcy5sYXRsb25nID0gSlNPTi5wYXJzZSh0aGlzLmxhc3RyZXF1ZXN0ZWRsb2NhdGlvbik7XG4gICAgICAgIH1cbiAgICAgICAgLy8gRmluYWxseSBjcmVhdGUgaW5zdGFuY2VzIG9mIHRoZSBjbGFzc2VzIHdlJ2xsIGJlIHVzaW5nLlxuICAgICAgICB0aGlzLmV2ZW50ZW1pdHRlciA9IG5ldyBFdmVudEVtaXR0ZXIoKTtcbiAgICAgICAgdGhpcy5jbG9jayA9IG5ldyBDbG9jayh0aGlzLmV2ZW50ZW1pdHRlciwgISFKVU1QLmFtcG1jbG9jaywgIUpVTVAub3dtYXBpa2V5KTtcbiAgICAgICAgdGhpcy53ZWF0aGVyID0gbmV3IFdlYXRoZXIodGhpcy5ldmVudGVtaXR0ZXIpO1xuXG4gICAgICAgIGlmICh0aGlzLnNob3dzZWFyY2hidXR0b25lbG0pIHtcbiAgICAgICAgICAgIHRoaXMuc2VhcmNoY2xvc2VidXR0b25lbG0gPSB0aGlzLnNob3dzZWFyY2hidXR0b25lbG0ucXVlcnlTZWxlY3RvcignLmNsb3NlJyk7XG4gICAgICAgICAgICB0aGlzLmZ1c2UgPSBuZXcgRnVzZShKU09OLnBhcnNlKEpVTVAuc2VhcmNoKSwge1xuICAgICAgICAgICAgICAgIHRocmVzaG9sZDogMC4zLFxuICAgICAgICAgICAgICAgIGtleXM6IFsnbmFtZScsICd0YWdzJ11cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogR2V0IGRhdGEgZnJvbSBPV00gYW5kIGRvIHN0dWZmIHdpdGggaXQuXG4gICAgICovXG4gICAgaW5pdCgpIHtcbiAgICAgICAgLy8gTGV0J3MgZGlzcGxheSBzb21lIGltYWdlcyBmcm9tIHVuc3BsYXNoIHRoZW4gc2hhbGwgd2UuLi5cbiAgICAgICAgaWYgKEpVTVAudW5zcGxhc2gpIHtcbiAgICAgICAgICAgIGNvbnN0IGJhY2tncm91bmRlbG0gPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKCcuYmFja2dyb3VuZCcpO1xuICAgICAgICAgICAgaWYgKEpVTVAudW5zcGxhc2hjb2xvcikge1xuICAgICAgICAgICAgICAgIGJhY2tncm91bmRlbG0uc3R5bGUuYmFja2dyb3VuZENvbG9yID0gSlVNUC51bnNwbGFzaGNvbG9yO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZmV0Y2goSlVNUC53d3d1cmwgKyAnL2FwaS91bnNwbGFzaC8nICsgSlVNUC50b2tlbiArICcvJylcbiAgICAgICAgICAgIC50aGVuKHJlc3BvbnNlID0+IHJlc3BvbnNlLmpzb24oKSlcbiAgICAgICAgICAgIC50aGVuKGRhdGEgPT4ge1xuICAgICAgICAgICAgICAgIGlmIChkYXRhLmVycm9yKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoJ0pVTVAgRVJST1I6IFRoZXJlIHdhcyBhbiBpc3N1ZSB3aXRoIHRoZSBVbnNwbGFzaCBBUEkuLi4gJyArIGRhdGEuZXJyb3IpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGJhY2tncm91bmRlbG0uc3R5bGUuYmFja2dyb3VuZEltYWdlID0gJ3VybChcIicgKyBkYXRhLmltYWdlZGF0YXVyaSArICdcIiknO1xuICAgICAgICAgICAgICAgIGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoJy51bnNwbGFzaCcpLmlubmVySFRNTCA9IGRhdGEuYXR0cmlidXRpb247XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIFN0YXJ0IGxpc3RlbmluZyBmb3IgZXZlbnRzIHNvIHdlIGNhbiBkbyBzdHVmZiB3aGVuIG5lZWRlZC5cbiAgICAgICAgdGhpcy5hZGRfZXZlbnRfbGlzdGVuZXJzKCk7XG4gICAgICAgIC8vIElmIHRoZXJlIGlzIG5vIE9XTSBBUEkga2V5IHByb3ZpZGVkIHRoZW4ganVzdCB1cGRhdGUgdGhlIGdyZWV0aW5nXG4gICAgICAgIC8vIGFuZCBjbG9jaywgb3RoZXJ3aXNlIHdlIGNhbiBnbyBnZXQgdGhlIHdlYXRoZXIgZGF0YSBhbmQgc2V0IGV2ZXJ5dGhpbmdcbiAgICAgICAgLy8gdXAgcHJvcGVybHkuXG4gICAgICAgIGlmICghSlVNUC5vd21hcGlrZXkpIHtcbiAgICAgICAgICAgIHRoaXMuZXZlbnRlbWl0dGVyLmVtaXQoJ3Nob3ctY29udGVudCcpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIC8vIFJldHJpZXZlIHdlYXRoZXIgYW5kIHRpbWV6b25lIGRhdGEgZnJvbSBPcGVuIFdlYXRoZXIgTWFwIEFQSS5cbiAgICAgICAgdGhpcy53ZWF0aGVyLmZldGNoX293bV9kYXRhKHRoaXMubGF0bG9uZyk7XG4gICAgICAgIHNldEludGVydmFsKCgpID0+IHtcbiAgICAgICAgICAgIHRoaXMud2VhdGhlci5mZXRjaF9vd21fZGF0YSh0aGlzLmxhdGxvbmcpO1xuICAgICAgICB9LCB0aGlzLndlYXRoZXJmcmVxdWVuY3kpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFVtbS4uLiBhZGRzIGV2ZW50IGxpc3RlbmVyc1xuICAgICAqL1xuICAgIGFkZF9ldmVudF9saXN0ZW5lcnMoKSB7XG4gICAgICAgIHRoaXMuZXZlbnRlbWl0dGVyLm9uKCd3ZWF0aGVyLWxvYWRlZCcsIG93bWRhdGEgPT4ge1xuICAgICAgICAgICAgLy8gVXBkYXRlIHRoZSB0aW1lem9uZSBzaGlmdCBmcm9tIFVUQyB0byB3aGF0ZXZlciBpdCBzaG91bGQgYmUgZm9yIHRoZVxuICAgICAgICAgICAgLy8gcmVxdWVzdGVkIGxvY2F0aW9uLCB0aGVuIHRlbGwgdGhlIGdyZWV0aW5nIGFuZCBjbG9jayB0byB1cGRhdGUuXG4gICAgICAgICAgICB0aGlzLnRpbWV6b25lc2hpZnQgPSBvd21kYXRhLnRpbWV6b25lc2hpZnQ7XG4gICAgICAgICAgICAvLyBEaXNwbGF5IHRoZSB3ZWF0aGVyIGljb24sIGxpbmsgdG8gdGhlIHJlcXVlc3RlZCBsb2NhdGlvbiBpbiBPV01cbiAgICAgICAgICAgIC8vIGFuZCB1cGRhdGUgbG9jYXRpb24gbmFtZSBlbGVtZW50LlxuICAgICAgICAgICAgdGhpcy53ZWF0aGVyZWxtLmhyZWYgPSAnaHR0cHM6Ly9vcGVud2VhdGhlcm1hcC5vcmcvY2l0eS8nICsgb3dtZGF0YS5sb2NhdGlvbmNvZGU7XG4gICAgICAgICAgICB0aGlzLndlYXRoZXJpY29uZWxtLmNsYXNzTGlzdC5hZGQob3dtZGF0YS5pY29uY2xhc3MpO1xuICAgICAgICAgICAgdGhpcy5jbGllbnRsb2NhdGlvbmVsbS5pbm5lckhUTUwgPSBvd21kYXRhLmxvY2F0aW9ubmFtZTtcbiAgICAgICAgICAgIHRoaXMudGVtcGVsbS5pbm5lckhUTUwgPSBvd21kYXRhLnRlbXA7XG4gICAgICAgICAgICB0aGlzLndlYXRoZXJkZXNjZWxtLmlubmVySFRNTCA9IG93bWRhdGEuZGVzY3JpcHRpb247XG4gICAgICAgICAgICB0aGlzLmNsaWVudGxvY2F0aW9uZWxtLmNsYXNzTGlzdC5hZGQoJ2VuYWJsZScpO1xuICAgICAgICAgICAgdGhpcy5ldmVudGVtaXR0ZXIuZW1pdCgnc2hvdy1jb250ZW50Jyk7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIHRoaXMuZXZlbnRlbWl0dGVyLm9uKCdjbG9jay11cGRhdGVkJywgY2xvY2tkYXRhID0+IHtcbiAgICAgICAgICAgIGlmICh0aGlzLnRpbWVlbG0gIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHRoaXMudGltZWVsbS5pbm5lckhUTUwgPSBjbG9ja2RhdGEuZm9ybWF0dGVkX3RpbWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodGhpcy5ncmVldGluZ2VsbSAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgbGV0IGdyZWV0aW5nID0gbmV3IEdyZWV0aW5nKGNsb2NrZGF0YS5ob3VyKTtcbiAgICAgICAgICAgICAgICB0aGlzLmdyZWV0aW5nZWxtLmlubmVySFRNTCA9IGdyZWV0aW5nLmdldF9ncmVldGluZygpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcblxuICAgICAgICB0aGlzLmV2ZW50ZW1pdHRlci5vbignc2hvdy1jb250ZW50JywgKCkgPT4ge1xuICAgICAgICAgICAgdGhpcy5zZXRfY2xvY2soKTtcbiAgICAgICAgICAgIHRoaXMuc2hvd19jb250ZW50KCk7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIC8vIFNob3VsZCBzb21lb25lIGNsaWNrIG9uIHRoZSBsb2NhdGlvbiBidXR0b24gdGhlbiByZXF1ZXN0IHRoZWlyIGxvY2F0aW9uXG4gICAgICAgIC8vIGZyb20gdGhlIGNsaWVudCBhbmQgc3RvcmUgaXQsIHRoZW4gcmVmZXRjaCB3ZWF0aGVyIGRhdGEgdG8gdXBkYXRlIHRoZSBwYWdlLlxuICAgICAgICB0aGlzLmNsaWVudGxvY2F0aW9uZWxtLmFkZEV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgZSA9PiB7XG4gICAgICAgICAgICBuYXZpZ2F0b3IuZ2VvbG9jYXRpb24uZ2V0Q3VycmVudFBvc2l0aW9uKHBvc2l0aW9uID0+IHtcbiAgICAgICAgICAgICAgICB0aGlzLmxhdGxvbmcgPSBbcG9zaXRpb24uY29vcmRzLmxhdGl0dWRlLCBwb3NpdGlvbi5jb29yZHMubG9uZ2l0dWRlXTtcbiAgICAgICAgICAgICAgICB0aGlzLnN0b3JhZ2Uuc2V0SXRlbSgnbGFzdHJlcXVlc3RlZGxvY2F0aW9uJywgSlNPTi5zdHJpbmdpZnkodGhpcy5sYXRsb25nKSk7XG4gICAgICAgICAgICAgICAgdGhpcy53ZWF0aGVyLmZldGNoX293bV9kYXRhKHRoaXMubGF0bG9uZyk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgZXJyb3IgPT4ge1xuICAgICAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoZXJyb3IubWVzc2FnZSk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAge2VuYWJsZUhpZ2hBY2N1cmFjeTogdHJ1ZX0pO1xuICAgICAgICB9KTtcblxuICAgICAgICBpZiAodGhpcy5zaG93dGFnc2J1dHRvbmVsbSkge1xuICAgICAgICAgICAgdGhpcy5zaG93dGFnc2J1dHRvbmVsbS5hZGRFdmVudExpc3RlbmVyKCdjbGljaycsIGUgPT4ge1xuICAgICAgICAgICAgICAgIHRoaXMudGFnc2VsZWN0b3JlbG0uY2xhc3NMaXN0LmFkZCgnZW5hYmxlJyk7XG4gICAgICAgICAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodGhpcy50YWdzc2VsZWN0b3JjbG9zZWJ1dHRvbmVsbSkge1xuICAgICAgICAgICAgdGhpcy50YWdzc2VsZWN0b3JjbG9zZWJ1dHRvbmVsbS5hZGRFdmVudExpc3RlbmVyKCdjbGljaycsIGUgPT4ge1xuICAgICAgICAgICAgICAgIHRoaXMudGFnc2VsZWN0b3JlbG0uY2xhc3NMaXN0LnJlbW92ZSgnZW5hYmxlJyk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0aGlzLnNob3dzZWFyY2hidXR0b25lbG0pIHtcbiAgICAgICAgICAgIGNvbnN0IHNlYXJjaGlucHV0ID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvcignLnNlYXJjaC1mb3JtIGlucHV0Jyk7XG4gICAgICAgICAgICB0aGlzLnNlYXJjaHN1Z2dlc3Rpb25zID0gbmV3IFNlYXJjaFN1Z2dlc3Rpb25zKEpTT04ucGFyc2UoSlVNUC5zZWFyY2hlbmdpbmVzKSwgc2VhcmNoaW5wdXQsIHRoaXMuc2hvd3NlYXJjaGJ1dHRvbmVsbSwgdGhpcy5ldmVudGVtaXR0ZXIpO1xuXG4gICAgICAgICAgICAvLyBXaGVuIHRoZSBzZWFyY2ggaWNvbiBpcyBsaWNrZWQsIHNob3cgdGhlIHNlYXJjaCBiYXIgYW5kIGZvY3VzIG9uIGl0LlxuICAgICAgICAgICAgdGhpcy5zaG93c2VhcmNoYnV0dG9uZWxtLmFkZEV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgZSA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKCFlLnRhcmdldC5jbGFzc0xpc3QuY29udGFpbnMoJ29wZW4nKSkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnNob3dzZWFyY2hidXR0b25lbG0uY2xhc3NMaXN0LmFkZCgnb3BlbicpO1xuICAgICAgICAgICAgICAgICAgICBzZWFyY2hpbnB1dC5mb2N1cygpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAvLyBMaXN0ZW4gZm9yIENUUkwrLyBrZXkgY29tYm8gYW5kIG9wZW4gc2VhcmNoIGJhci5cbiAgICAgICAgICAgIGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ2tleXVwJywgZSA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKGUuY3RybEtleSAmJiBlLnNoaWZ0S2V5ICYmIGUuY29kZSA9PSAnU2xhc2gnKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICghdGhpcy5zaG93c2VhcmNoYnV0dG9uZWxtLmNsYXNzTGlzdC5jb250YWlucygnb3BlbicpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnNob3dzZWFyY2hidXR0b25lbG0uY2xhc3NMaXN0LmFkZCgnb3BlbicpO1xuICAgICAgICAgICAgICAgICAgICAgICAgc2VhcmNoaW5wdXQuZm9jdXMoKTtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuc2VhcmNoX2Nsb3NlKCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgLy8gSGFuZGxlIHRoZSBjbG9zZSBidXR0b24uXG4gICAgICAgICAgICB0aGlzLnNlYXJjaGNsb3NlYnV0dG9uZWxtLmFkZEV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgZSA9PiB7XG4gICAgICAgICAgICAgICAgZS5zdG9wUHJvcGFnYXRpb24oKTtcbiAgICAgICAgICAgICAgICB0aGlzLnNlYXJjaF9jbG9zZSgpO1xuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIC8vIExpc3RlbiBmb3Iga2V5IGV2ZW50cyB0cmlnZ2VyZWQgYnkgdGhlIHNlYXJoIGJhciBhbmQgZG8gc3R1ZmYuXG4gICAgICAgICAgICBzZWFyY2hpbnB1dC5hZGRFdmVudExpc3RlbmVyKCdrZXl1cCcsIGUgPT4ge1xuICAgICAgICAgICAgICAgIC8vIE9uIGFycm93IGRvd24sIGZvY3VzIG9uIHRoZSBmaXJzdCBzZWFyY2ggc3VnZ2VzdGlvbi5cbiAgICAgICAgICAgICAgICBsZXQgc3VnZ2VzdGlvbnNsaXN0ID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvcignLnN1Z2dlc3Rpb24tbGlzdCAuc2VhcmNocHJvdmlkZXJzJyk7XG4gICAgICAgICAgICAgICAgaWYgKGUuY29kZSA9PT0gJ0Fycm93RG93bicpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHN1Z2dlc3Rpb25zbGlzdCAmJiBzdWdnZXN0aW9uc2xpc3QuY2hpbGROb2Rlcy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHN1Z2dlc3Rpb25zbGlzdC5maXJzdENoaWxkLmZpcnN0Q2hpbGQuZm9jdXMoKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vIFBlcmZvcm0gc2VhcmNoLCBsaW1pdCBudW1iZXIgb2YgcmVzdWx0cywgY3JlYXRlIG5ldyBhcnJheSBjb250YWluaW5nIG9ubHkgd2hhdFxuICAgICAgICAgICAgICAgIC8vIHdlIG5lZWQgYW5kIGZpbmFsbHkgZGlzcGxheSB0aGUgc3VnZ2VzdGlvbnMgb24gdGhlIHBhZ2UuXG4gICAgICAgICAgICAgICAgbGV0IHJlc3VsdHMgPSBbXTtcbiAgICAgICAgICAgICAgICBsZXQgc2l0ZXJlc3VsdHMgPSB0aGlzLmZ1c2Uuc2VhcmNoKHNlYXJjaGlucHV0LnZhbHVlKTtcbiAgICAgICAgICAgICAgICBzaXRlcmVzdWx0cy5sZW5ndGggPSA4O1xuICAgICAgICAgICAgICAgIGlmIChzaXRlcmVzdWx0cy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgICAgICAgIHNpdGVyZXN1bHRzLmZvckVhY2goKHJlc3VsdCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0cy5wdXNoKHJlc3VsdC5pdGVtKTtcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHRoaXMuc2VhcmNoc3VnZ2VzdGlvbnMucmVwbGFjZShyZXN1bHRzKTtcbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAvLyBJZiBzb21lb25lIHByZXNzZXMgZW50ZXIgdGhlbiBvcGVuIHVwIHRoZSBmaXJzdCBsaW5rLCB0aGlzIGlzIHRoZSBkZWZhdWx0IHNlYWNoIGVuZ2luZVxuICAgICAgICAgICAgLy8gcHVyZWx5IGJlY2F1c2UgaXQgaXMgYXQgdGhlIHRvcCBvZiB0aGUgbGlzdC5cbiAgICAgICAgICAgIGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoJy5zZWFyY2gtZm9ybScpLmFkZEV2ZW50TGlzdGVuZXIoJ3N1Ym1pdCcsIGUgPT4ge1xuICAgICAgICAgICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICAgICAgICBpZiAoc2VhcmNoaW5wdXQudmFsdWUgIT0gJycpIHtcbiAgICAgICAgICAgICAgICAgICAgZG9jdW1lbnQucXVlcnlTZWxlY3RvcignLnNlYXJjaHByb3ZpZGVycyBsaSBhJykuY2xpY2soKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHNlYXJjaF9jbG9zZSgpIHtcbiAgICAgICAgbGV0IHN1Z2dlc3Rpb25zID0gdGhpcy5zaG93c2VhcmNoYnV0dG9uZWxtLnF1ZXJ5U2VsZWN0b3IoJy5zdWdnZXN0aW9uaG9sZGVyJyk7XG4gICAgICAgIGlmIChzdWdnZXN0aW9ucykge1xuICAgICAgICAgICAgc3VnZ2VzdGlvbnMucmVtb3ZlKCk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5zaG93c2VhcmNoYnV0dG9uZWxtLmNsYXNzTGlzdC5yZW1vdmUoJ3N1Z2dlc3Rpb25zJyk7XG4gICAgICAgIGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoJy5zZWFyY2gnKS5jbGFzc0xpc3QucmVtb3ZlKCdvcGVuJyk7XG4gICAgICAgIGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoJy5zZWFyY2gtZm9ybSBpbnB1dCcpLnZhbHVlID0gJyc7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogT25jZSBldmVyeXRoaW5nIGlzIHNldCB1cCB3ZSBjYW4gcmVtb3ZlIHRoZSAuaGlkZGVuIGNsYXNzIHRvIGRpc3BsYXkgY29udGVudFxuICAgICAqIG9uIHRoZSBwYWdlIHRvIHN0b3AgdGhpbmdzIGp1bXBpbmcgYXJvdW5kIGJldHdlZW4gdGhlIGluaXRpYWwgcGFnZSBsb2FkXG4gICAgICogYW5kIEpTIHJlbmRlcmluZy5cbiAgICAgKi9cbiAgICBzaG93X2NvbnRlbnQoKSB7XG4gICAgICAgIGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3JBbGwoJy5oaWRkZW4nKS5mb3JFYWNoKGZ1bmN0aW9uKGVsZW1lbnQpe1xuICAgICAgICAgICAgZWxlbWVudC5jbGFzc0xpc3QucmVtb3ZlKCdoaWRkZW4nKTtcbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgc2V0X2Nsb2NrKCkge1xuICAgICAgICB0aGlzLmNsb2NrLnNldF91dGNfc2hpZnQodGhpcy50aW1lem9uZXNoaWZ0KTtcbiAgICAgICAgdGhpcy5jbG9jay5ydW4odGhpcy5jbG9ja2ZyZXF1ZW5jeSk7XG4gICAgfVxuXG59XG4iLCIvKipcbiAqIEdlbmVyYXRlIHNlYXJjaCBzdWdnZXN0aW9ucy5cbiAqXG4gKiBAYXV0aG9yIERhbGUgRGF2aWVzIDxkYWxlQGRhbGVkYXZpZXMuY28udWs+XG4gKiBAbGljZW5zZSBNSVRcbiAqL1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBTZWFyY2hTdWdnZXN0aW9ucyB7XG5cbiAgICBjb25zdHJ1Y3RvcihzZWFyY2hlbmdpbmVzLCBpbnB1dGVsbSwgY29udGFpbmVyZWxtLCBldmVudGVtaXR0ZXIpIHtcbiAgICAgICAgdGhpcy5jb250YWluZXJlbG0gPSBjb250YWluZXJlbG07XG4gICAgICAgIHRoaXMuZXZlbnRlbWl0dGVyID0gZXZlbnRlbWl0dGVyO1xuICAgICAgICB0aGlzLmlucHV0ZWxtID0gaW5wdXRlbG07XG4gICAgICAgIHRoaXMuc3VnZ2VzdGlvbnNsaXN0ZWxtID0gY29udGFpbmVyZWxtLnF1ZXJ5U2VsZWN0b3IoJy5zdWdnZXN0aW9uLWxpc3QnKTtcbiAgICAgICAgdGhpcy5zZWFyY2hwcm92aWRlcmxpc3QgPSBudWxsO1xuICAgICAgICB0aGlzLnNlYXJjaGVuZ2luZXMgPSBzZWFyY2hlbmdpbmVzO1xuICAgIH1cblxuICAgIGJ1aWxkX3NlYXJjaHByb3ZpZGVyX2xpc3RfZWxtKHF1ZXJ5KSB7XG4gICAgICAgIGNvbnN0IHNlYXJjaHByb3ZpZGVybGlzdCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3VsJyk7XG4gICAgICAgIHNlYXJjaHByb3ZpZGVybGlzdC5jbGFzc0xpc3QuYWRkKCdzZWFyY2hwcm92aWRlcnMnKTtcbiAgICAgICAgc2VhcmNocHJvdmlkZXJsaXN0LnNldEF0dHJpYnV0ZSgndGFiaW5kZXgnLCAtMSk7XG4gICAgICAgIHRoaXMuc2VhcmNoZW5naW5lcy5mb3JFYWNoKChwcm92aWRlcikgPT4ge1xuICAgICAgICAgICAgY29uc3Qgc2VhcmNocHJvdmlkZXIgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdsaScpO1xuICAgICAgICAgICAgc2VhcmNocHJvdmlkZXIuc2V0QXR0cmlidXRlKCd0YWJpbmRleCcsIC0xKTtcbiAgICAgICAgICAgIHNlYXJjaHByb3ZpZGVyLmlubmVySFRNTCA9ICc8YSB0YXJnZXQ9XCJfYmxhbmtcIiByZWw9XCJub29wZW5lclwiIFxcXG4gICAgICAgICAgICAgICAgaHJlZj1cIicrcHJvdmlkZXIudXJsK2VuY29kZVVSSUNvbXBvbmVudChxdWVyeSkrJ1wiPjxzcGFuPlNlYXJjaCBvbjwvc3Bhbj4gJytwcm92aWRlci5uYW1lKyc8L2E+JztcbiAgICAgICAgICAgIHNlYXJjaHByb3ZpZGVybGlzdC5hcHBlbmRDaGlsZChzZWFyY2hwcm92aWRlcik7XG4gICAgICAgIH0pO1xuICAgICAgICBzZWFyY2hwcm92aWRlcmxpc3QuYWRkRXZlbnRMaXN0ZW5lcigna2V5dXAnLCBlID0+IHtcbiAgICAgICAgICAgIHN3aXRjaCAoZS5jb2RlKSB7XG4gICAgICAgICAgICAgICAgY2FzZSAnQXJyb3dVcCc6XG4gICAgICAgICAgICAgICAgICAgIGlmIChkb2N1bWVudC5hY3RpdmVFbGVtZW50ID09IGUudGFyZ2V0LnBhcmVudE5vZGUucGFyZW50Tm9kZS5maXJzdENoaWxkLmZpcnN0Q2hpbGQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuaW5wdXRlbG0uZm9jdXMoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGRvY3VtZW50LmFjdGl2ZUVsZW1lbnQucGFyZW50Tm9kZS5wcmV2aW91c1NpYmxpbmcuZmlyc3RDaGlsZC5mb2N1cygpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlICdBcnJvd0Rvd24nOlxuICAgICAgICAgICAgICAgICAgICBpZiAoZG9jdW1lbnQuYWN0aXZlRWxlbWVudCA9PSBlLnRhcmdldC5wYXJlbnROb2RlLnBhcmVudE5vZGUubGFzdENoaWxkLmZpcnN0Q2hpbGQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHN1Z2dlc3Rpb25zZWxtID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvcignLnN1Z2dlc3Rpb25ob2xkZXIgLnN1Z2dlc3Rpb25zJyk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoc3VnZ2VzdGlvbnNlbG0pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdWdnZXN0aW9uc2VsbS5maXJzdENoaWxkLmZpcnN0Q2hpbGQuZm9jdXMoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZS50YXJnZXQucGFyZW50Tm9kZS5wYXJlbnROb2RlLmZpcnN0Q2hpbGQuZmlyc3RDaGlsZC5mb2N1cygpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZG9jdW1lbnQuYWN0aXZlRWxlbWVudC5wYXJlbnROb2RlLm5leHRTaWJsaW5nLmZpcnN0Q2hpbGQuZm9jdXMoKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gc2VhcmNocHJvdmlkZXJsaXN0O1xuICAgIH1cblxuICAgIGJ1aWxkX3N1Z2dlc3Rpb25fbGlzdF9lbG0oc2l0ZXJlc3VsdHMpIHtcbiAgICAgICAgY29uc3Qgc3VnZ2VzdGlvbnNsaXN0ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgndWwnKTtcbiAgICAgICAgc3VnZ2VzdGlvbnNsaXN0LmNsYXNzTGlzdC5hZGQoJ3N1Z2dlc3Rpb25zJyk7XG4gICAgICAgIHN1Z2dlc3Rpb25zbGlzdC5zZXRBdHRyaWJ1dGUoJ3RhYmluZGV4JywgLTEpO1xuICAgICAgICBzaXRlcmVzdWx0cy5mb3JFYWNoKChyZXN1bHQpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IHJlc3VsdGl0ZW0gPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdsaScpO1xuICAgICAgICAgICAgcmVzdWx0aXRlbS5zZXRBdHRyaWJ1dGUoJ3RhYmluZGV4JywgLTEpO1xuICAgICAgICAgICAgcmVzdWx0aXRlbS5pbm5lckhUTUwgPSAnPGEgdGFyZ2V0PVwiX2JsYW5rXCIgcmVsPVwibm9vcGVuZXJcIiBocmVmPVwiJytyZXN1bHQudXJsKydcIj5cXFxuICAgICAgICAgICAgICAgIDxpbWcgY2xhc3M9XCJpY29uXCIgc3JjPVwiJytyZXN1bHQuaWNvbnVybCsnXCI+PHNwYW4gY2xhc3M9XCJuYW1lXCI+JytyZXN1bHQubmFtZSsnPC9zcGFuPic7XG4gICAgICAgICAgICBzdWdnZXN0aW9uc2xpc3QuYXBwZW5kQ2hpbGQocmVzdWx0aXRlbSk7XG4gICAgICAgIH0pO1xuICAgICAgICBzdWdnZXN0aW9uc2xpc3QuYWRkRXZlbnRMaXN0ZW5lcigna2V5dXAnLCBlID0+IHtcbiAgICAgICAgICAgIHN3aXRjaCAoZS5jb2RlKSB7XG4gICAgICAgICAgICAgICAgY2FzZSAnQXJyb3dVcCc6XG4gICAgICAgICAgICAgICAgICAgIGlmIChkb2N1bWVudC5hY3RpdmVFbGVtZW50ID09IGUudGFyZ2V0LnBhcmVudE5vZGUucGFyZW50Tm9kZS5maXJzdENoaWxkLmZpcnN0Q2hpbGQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuc2VhcmNocHJvdmlkZXJsaXN0Lmxhc3RDaGlsZC5maXJzdENoaWxkLmZvY3VzKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBkb2N1bWVudC5hY3RpdmVFbGVtZW50LnBhcmVudE5vZGUucHJldmlvdXNTaWJsaW5nLmZpcnN0Q2hpbGQuZm9jdXMoKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAnQXJyb3dEb3duJzpcbiAgICAgICAgICAgICAgICAgICAgaWYgKGRvY3VtZW50LmFjdGl2ZUVsZW1lbnQgPT0gZS50YXJnZXQucGFyZW50Tm9kZS5wYXJlbnROb2RlLmxhc3RDaGlsZC5maXJzdENoaWxkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnNlYXJjaHByb3ZpZGVybGlzdC5maXJzdENoaWxkLmZpcnN0Q2hpbGQuZm9jdXMoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGRvY3VtZW50LmFjdGl2ZUVsZW1lbnQucGFyZW50Tm9kZS5uZXh0U2libGluZy5maXJzdENoaWxkLmZvY3VzKCk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIHN1Z2dlc3Rpb25zbGlzdDtcbiAgICB9XG5cbiAgICByZXBsYWNlKHNpdGVyZXN1bHRzKSB7XG4gICAgICAgIGNvbnN0IG5ld3N1Z2dlc3Rpb25zbGlzdCA9IHRoaXMuYnVpbGRfc3VnZ2VzdGlvbl9saXN0X2VsbShzaXRlcmVzdWx0cyk7XG5cbiAgICAgICAgY29uc3Qgc3VnZ2VzdGlvbmhvbGRlciA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3NwYW4nKTtcbiAgICAgICAgc3VnZ2VzdGlvbmhvbGRlci5jbGFzc0xpc3QuYWRkKCdzdWdnZXN0aW9uaG9sZGVyJyk7XG5cbiAgICAgICAgaWYgKHRoaXMuaW5wdXRlbG0udmFsdWUgIT09ICcnKSB7XG4gICAgICAgICAgICBjb25zdCBzZWFyY2h0aXRsZSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3NwYW4nKTtcbiAgICAgICAgICAgIHNlYXJjaHRpdGxlLmNsYXNzTGlzdC5hZGQoJ3N1Z2dlc3Rpb250aXRsZScpO1xuICAgICAgICAgICAgc2VhcmNodGl0bGUuaW5uZXJIVE1MID0gJ1NlYXJjaCc7XG4gICAgICAgICAgICBzdWdnZXN0aW9uaG9sZGVyLmFwcGVuZENoaWxkKHNlYXJjaHRpdGxlKTtcbiAgICAgICAgICAgIHRoaXMuc2VhcmNocHJvdmlkZXJsaXN0ID0gdGhpcy5idWlsZF9zZWFyY2hwcm92aWRlcl9saXN0X2VsbSh0aGlzLmlucHV0ZWxtLnZhbHVlKTtcbiAgICAgICAgICAgIHN1Z2dlc3Rpb25ob2xkZXIuYXBwZW5kQ2hpbGQodGhpcy5zZWFyY2hwcm92aWRlcmxpc3QpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKG5ld3N1Z2dlc3Rpb25zbGlzdC5jaGlsZE5vZGVzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgIGNvbnN0IHN1Z2dlc3Rpb250aXRsZSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3NwYW4nKTtcbiAgICAgICAgICAgIHN1Z2dlc3Rpb250aXRsZS5jbGFzc0xpc3QuYWRkKCdzdWdnZXN0aW9udGl0bGUnKTtcbiAgICAgICAgICAgIHN1Z2dlc3Rpb250aXRsZS5pbm5lckhUTUwgPSAnU2l0ZXMnO1xuICAgICAgICAgICAgc3VnZ2VzdGlvbmhvbGRlci5hcHBlbmRDaGlsZChzdWdnZXN0aW9udGl0bGUpO1xuICAgICAgICAgICAgc3VnZ2VzdGlvbmhvbGRlci5hcHBlbmRDaGlsZChuZXdzdWdnZXN0aW9uc2xpc3QpXG4gICAgICAgIH1cblxuICAgICAgICBpZiAoc3VnZ2VzdGlvbmhvbGRlci5jaGlsZE5vZGVzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgIHRoaXMuY29udGFpbmVyZWxtLmNsYXNzTGlzdC5hZGQoJ3N1Z2dlc3Rpb25zJyk7XG4gICAgICAgICAgICB0aGlzLnN1Z2dlc3Rpb25zbGlzdGVsbS5yZXBsYWNlQ2hpbGRyZW4oc3VnZ2VzdGlvbmhvbGRlcik7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGlzLmNvbnRhaW5lcmVsbS5jbGFzc0xpc3QucmVtb3ZlKCdzdWdnZXN0aW9ucycpO1xuICAgICAgICAgICAgbGV0IHN1Z2dlc3Rpb25zID0gdGhpcy5jb250YWluZXJlbG0ucXVlcnlTZWxlY3RvcignLnN1Z2dlc3Rpb25ob2xkZXInKTtcbiAgICAgICAgICAgIGlmIChzdWdnZXN0aW9ucykge1xuICAgICAgICAgICAgICAgIHN1Z2dlc3Rpb25zLnJlbW92ZSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxufVxuIiwiZXhwb3J0IGRlZmF1bHQgY2xhc3MgV2VhdGhlciB7XG5cbiAgICAvKipcbiAgICAgKiBSZXNwb25zaWJsZSBmb3IgcmV0cmlldmVpbmcgd2VhdGhlciBkYXRhIGZyb20gT1dNIGFuZCBkb2luZ1xuICAgICAqIHN0dWZmIHdpdGggaXQuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gbGF0bG9uZyBDb21tYSBzZXBhcmF0ZWQgc3RyaW5nIHJlcHJlc2VudGluZyBhIGxhdHRpdHVkZSBhbmQgbG9uZ2l0dWRlLlxuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKGV2ZW50ZW1pdHRlcikge1xuICAgICAgICB0aGlzLmV2ZW50ZW1pdHRlciA9IGV2ZW50ZW1pdHRlcjtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBNYWtlIGFuIGFzeW5jIHJlcXVlc3QgdG8gdGhlIHdlYXRoZXIgQVBJLCBwYXJzZSBhbmQgcmV0dXJuIHRoZSByZXNwb25zZS5cbiAgICAgKi9cbiAgICBmZXRjaF9vd21fZGF0YShsYXRsb25nKSB7XG4gICAgICAgIC8vIElmIHdlIGFyZSBwcm92aWRlZCB3aXRoIGEgbGF0bG9uZyB0aGVuIHRoZSB1c2VyIG11c3QgaGF2ZSBjbGllY2tlZCBvbiB0aGUgbG9jYXRpb25cbiAgICAgICAgLy8gYnV0dG9uIGF0IHNvbWUgcG9pbnQsIHNvIGxldCdzIHVzZSB0aGlzIGluIHRoZSBhcGkgdXJsLi4uXG4gICAgICAgIGxldCBhcGl1cmwgPSBKVU1QLnd3d3VybCArICcvYXBpL3dlYXRoZXIvJyArIEpVTVAudG9rZW4gKyAnLyc7XG4gICAgICAgIGlmIChsYXRsb25nLmxlbmd0aCkge1xuICAgICAgICAgICAgYXBpdXJsICs9IChsYXRsb25nWzBdICsgJy8nICsgbGF0bG9uZ1sxXSArICcvJyk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gR2V0IHNvbWUgZGF0YSBmcm9tIHRoZSB3ZWF0aGVyIGFwaS4uLlxuICAgICAgICBmZXRjaChhcGl1cmwpXG4gICAgICAgIC50aGVuKHJlc3BvbnNlID0+IHJlc3BvbnNlLmpzb24oKSlcbiAgICAgICAgLnRoZW4oZGF0YSA9PiB7XG4gICAgICAgICAgICBpZiAoZGF0YS5lcnJvcikge1xuICAgICAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoJ0pVTVAgRVJST1I6IFRoZXJlIHdhcyBhbiBpc3N1ZSB3aXRoIHRoZSBPV00gQVBJLi4uICcgKyBkYXRhLmVycm9yKTtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoZGF0YS5jb2QgPT09IDQwMSkge1xuICAgICAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoJ0pVTVAgRVJST1I6IFRoZSBPV00gQVBJIGtleSBpcyBpbnZhbGlkLCBjaGVjayBjb25maWcucGhwJyk7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gRGV0ZXJtaW5lIGlmIHdlIHNob3VsZCB1c2UgdGhlIGRheSBvciBuaWdodCB2YXJpYW50IG9mIG91ciB3ZWF0aGVyIGljb24uXG4gICAgICAgICAgICB2YXIgZGF5bmlnaHR2YXJpYW50ID0gJ25pZ2h0JztcbiAgICAgICAgICAgIGlmIChkYXRhLmR0ID4gZGF0YS5zeXMuc3VucmlzZSAmJiBkYXRhLmR0IDwgZGF0YS5zeXMuc3Vuc2V0KSB7XG4gICAgICAgICAgICAgICAgZGF5bmlnaHR2YXJpYW50ID0gJ2RheSdcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuZXZlbnRlbWl0dGVyLmVtaXQoJ3dlYXRoZXItbG9hZGVkJywge1xuICAgICAgICAgICAgICAgIGxvY2F0aW9uY29kZTogZGF0YS5pZCxcbiAgICAgICAgICAgICAgICBsb2NhdGlvbm5hbWU6IGRhdGEubmFtZSxcbiAgICAgICAgICAgICAgICB0ZW1wOiBNYXRoLmNlaWwoZGF0YS5tYWluLnRlbXApICsgJyZkZWc7JyArIChKVU1QLm1ldHJpY3RlbXAgPyAnQycgOiAnRicpLFxuICAgICAgICAgICAgICAgIGRlc2NyaXB0aW9uOiBkYXRhLndlYXRoZXJbMF0ubWFpbixcbiAgICAgICAgICAgICAgICBpY29uY2xhc3M6ICd3aS1vd20tJyArIGRheW5pZ2h0dmFyaWFudCArICctJyArIGRhdGEud2VhdGhlclswXS5pZCxcbiAgICAgICAgICAgICAgICB0aW1lem9uZXNoaWZ0OiBkYXRhLnRpbWV6b25lKjEwMDAsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSlcbiAgICB9XG5cbn1cbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIGhhcyA9IE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHlcbiAgLCBwcmVmaXggPSAnfic7XG5cbi8qKlxuICogQ29uc3RydWN0b3IgdG8gY3JlYXRlIGEgc3RvcmFnZSBmb3Igb3VyIGBFRWAgb2JqZWN0cy5cbiAqIEFuIGBFdmVudHNgIGluc3RhbmNlIGlzIGEgcGxhaW4gb2JqZWN0IHdob3NlIHByb3BlcnRpZXMgYXJlIGV2ZW50IG5hbWVzLlxuICpcbiAqIEBjb25zdHJ1Y3RvclxuICogQHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gRXZlbnRzKCkge31cblxuLy9cbi8vIFdlIHRyeSB0byBub3QgaW5oZXJpdCBmcm9tIGBPYmplY3QucHJvdG90eXBlYC4gSW4gc29tZSBlbmdpbmVzIGNyZWF0aW5nIGFuXG4vLyBpbnN0YW5jZSBpbiB0aGlzIHdheSBpcyBmYXN0ZXIgdGhhbiBjYWxsaW5nIGBPYmplY3QuY3JlYXRlKG51bGwpYCBkaXJlY3RseS5cbi8vIElmIGBPYmplY3QuY3JlYXRlKG51bGwpYCBpcyBub3Qgc3VwcG9ydGVkIHdlIHByZWZpeCB0aGUgZXZlbnQgbmFtZXMgd2l0aCBhXG4vLyBjaGFyYWN0ZXIgdG8gbWFrZSBzdXJlIHRoYXQgdGhlIGJ1aWx0LWluIG9iamVjdCBwcm9wZXJ0aWVzIGFyZSBub3Rcbi8vIG92ZXJyaWRkZW4gb3IgdXNlZCBhcyBhbiBhdHRhY2sgdmVjdG9yLlxuLy9cbmlmIChPYmplY3QuY3JlYXRlKSB7XG4gIEV2ZW50cy5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuXG4gIC8vXG4gIC8vIFRoaXMgaGFjayBpcyBuZWVkZWQgYmVjYXVzZSB0aGUgYF9fcHJvdG9fX2AgcHJvcGVydHkgaXMgc3RpbGwgaW5oZXJpdGVkIGluXG4gIC8vIHNvbWUgb2xkIGJyb3dzZXJzIGxpa2UgQW5kcm9pZCA0LCBpUGhvbmUgNS4xLCBPcGVyYSAxMSBhbmQgU2FmYXJpIDUuXG4gIC8vXG4gIGlmICghbmV3IEV2ZW50cygpLl9fcHJvdG9fXykgcHJlZml4ID0gZmFsc2U7XG59XG5cbi8qKlxuICogUmVwcmVzZW50YXRpb24gb2YgYSBzaW5nbGUgZXZlbnQgbGlzdGVuZXIuXG4gKlxuICogQHBhcmFtIHtGdW5jdGlvbn0gZm4gVGhlIGxpc3RlbmVyIGZ1bmN0aW9uLlxuICogQHBhcmFtIHsqfSBjb250ZXh0IFRoZSBjb250ZXh0IHRvIGludm9rZSB0aGUgbGlzdGVuZXIgd2l0aC5cbiAqIEBwYXJhbSB7Qm9vbGVhbn0gW29uY2U9ZmFsc2VdIFNwZWNpZnkgaWYgdGhlIGxpc3RlbmVyIGlzIGEgb25lLXRpbWUgbGlzdGVuZXIuXG4gKiBAY29uc3RydWN0b3JcbiAqIEBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIEVFKGZuLCBjb250ZXh0LCBvbmNlKSB7XG4gIHRoaXMuZm4gPSBmbjtcbiAgdGhpcy5jb250ZXh0ID0gY29udGV4dDtcbiAgdGhpcy5vbmNlID0gb25jZSB8fCBmYWxzZTtcbn1cblxuLyoqXG4gKiBBZGQgYSBsaXN0ZW5lciBmb3IgYSBnaXZlbiBldmVudC5cbiAqXG4gKiBAcGFyYW0ge0V2ZW50RW1pdHRlcn0gZW1pdHRlciBSZWZlcmVuY2UgdG8gdGhlIGBFdmVudEVtaXR0ZXJgIGluc3RhbmNlLlxuICogQHBhcmFtIHsoU3RyaW5nfFN5bWJvbCl9IGV2ZW50IFRoZSBldmVudCBuYW1lLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gZm4gVGhlIGxpc3RlbmVyIGZ1bmN0aW9uLlxuICogQHBhcmFtIHsqfSBjb250ZXh0IFRoZSBjb250ZXh0IHRvIGludm9rZSB0aGUgbGlzdGVuZXIgd2l0aC5cbiAqIEBwYXJhbSB7Qm9vbGVhbn0gb25jZSBTcGVjaWZ5IGlmIHRoZSBsaXN0ZW5lciBpcyBhIG9uZS10aW1lIGxpc3RlbmVyLlxuICogQHJldHVybnMge0V2ZW50RW1pdHRlcn1cbiAqIEBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIGFkZExpc3RlbmVyKGVtaXR0ZXIsIGV2ZW50LCBmbiwgY29udGV4dCwgb25jZSkge1xuICBpZiAodHlwZW9mIGZuICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignVGhlIGxpc3RlbmVyIG11c3QgYmUgYSBmdW5jdGlvbicpO1xuICB9XG5cbiAgdmFyIGxpc3RlbmVyID0gbmV3IEVFKGZuLCBjb250ZXh0IHx8IGVtaXR0ZXIsIG9uY2UpXG4gICAgLCBldnQgPSBwcmVmaXggPyBwcmVmaXggKyBldmVudCA6IGV2ZW50O1xuXG4gIGlmICghZW1pdHRlci5fZXZlbnRzW2V2dF0pIGVtaXR0ZXIuX2V2ZW50c1tldnRdID0gbGlzdGVuZXIsIGVtaXR0ZXIuX2V2ZW50c0NvdW50Kys7XG4gIGVsc2UgaWYgKCFlbWl0dGVyLl9ldmVudHNbZXZ0XS5mbikgZW1pdHRlci5fZXZlbnRzW2V2dF0ucHVzaChsaXN0ZW5lcik7XG4gIGVsc2UgZW1pdHRlci5fZXZlbnRzW2V2dF0gPSBbZW1pdHRlci5fZXZlbnRzW2V2dF0sIGxpc3RlbmVyXTtcblxuICByZXR1cm4gZW1pdHRlcjtcbn1cblxuLyoqXG4gKiBDbGVhciBldmVudCBieSBuYW1lLlxuICpcbiAqIEBwYXJhbSB7RXZlbnRFbWl0dGVyfSBlbWl0dGVyIFJlZmVyZW5jZSB0byB0aGUgYEV2ZW50RW1pdHRlcmAgaW5zdGFuY2UuXG4gKiBAcGFyYW0geyhTdHJpbmd8U3ltYm9sKX0gZXZ0IFRoZSBFdmVudCBuYW1lLlxuICogQHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gY2xlYXJFdmVudChlbWl0dGVyLCBldnQpIHtcbiAgaWYgKC0tZW1pdHRlci5fZXZlbnRzQ291bnQgPT09IDApIGVtaXR0ZXIuX2V2ZW50cyA9IG5ldyBFdmVudHMoKTtcbiAgZWxzZSBkZWxldGUgZW1pdHRlci5fZXZlbnRzW2V2dF07XG59XG5cbi8qKlxuICogTWluaW1hbCBgRXZlbnRFbWl0dGVyYCBpbnRlcmZhY2UgdGhhdCBpcyBtb2xkZWQgYWdhaW5zdCB0aGUgTm9kZS5qc1xuICogYEV2ZW50RW1pdHRlcmAgaW50ZXJmYWNlLlxuICpcbiAqIEBjb25zdHJ1Y3RvclxuICogQHB1YmxpY1xuICovXG5mdW5jdGlvbiBFdmVudEVtaXR0ZXIoKSB7XG4gIHRoaXMuX2V2ZW50cyA9IG5ldyBFdmVudHMoKTtcbiAgdGhpcy5fZXZlbnRzQ291bnQgPSAwO1xufVxuXG4vKipcbiAqIFJldHVybiBhbiBhcnJheSBsaXN0aW5nIHRoZSBldmVudHMgZm9yIHdoaWNoIHRoZSBlbWl0dGVyIGhhcyByZWdpc3RlcmVkXG4gKiBsaXN0ZW5lcnMuXG4gKlxuICogQHJldHVybnMge0FycmF5fVxuICogQHB1YmxpY1xuICovXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLmV2ZW50TmFtZXMgPSBmdW5jdGlvbiBldmVudE5hbWVzKCkge1xuICB2YXIgbmFtZXMgPSBbXVxuICAgICwgZXZlbnRzXG4gICAgLCBuYW1lO1xuXG4gIGlmICh0aGlzLl9ldmVudHNDb3VudCA9PT0gMCkgcmV0dXJuIG5hbWVzO1xuXG4gIGZvciAobmFtZSBpbiAoZXZlbnRzID0gdGhpcy5fZXZlbnRzKSkge1xuICAgIGlmIChoYXMuY2FsbChldmVudHMsIG5hbWUpKSBuYW1lcy5wdXNoKHByZWZpeCA/IG5hbWUuc2xpY2UoMSkgOiBuYW1lKTtcbiAgfVxuXG4gIGlmIChPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKSB7XG4gICAgcmV0dXJuIG5hbWVzLmNvbmNhdChPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKGV2ZW50cykpO1xuICB9XG5cbiAgcmV0dXJuIG5hbWVzO1xufTtcblxuLyoqXG4gKiBSZXR1cm4gdGhlIGxpc3RlbmVycyByZWdpc3RlcmVkIGZvciBhIGdpdmVuIGV2ZW50LlxuICpcbiAqIEBwYXJhbSB7KFN0cmluZ3xTeW1ib2wpfSBldmVudCBUaGUgZXZlbnQgbmFtZS5cbiAqIEByZXR1cm5zIHtBcnJheX0gVGhlIHJlZ2lzdGVyZWQgbGlzdGVuZXJzLlxuICogQHB1YmxpY1xuICovXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLmxpc3RlbmVycyA9IGZ1bmN0aW9uIGxpc3RlbmVycyhldmVudCkge1xuICB2YXIgZXZ0ID0gcHJlZml4ID8gcHJlZml4ICsgZXZlbnQgOiBldmVudFxuICAgICwgaGFuZGxlcnMgPSB0aGlzLl9ldmVudHNbZXZ0XTtcblxuICBpZiAoIWhhbmRsZXJzKSByZXR1cm4gW107XG4gIGlmIChoYW5kbGVycy5mbikgcmV0dXJuIFtoYW5kbGVycy5mbl07XG5cbiAgZm9yICh2YXIgaSA9IDAsIGwgPSBoYW5kbGVycy5sZW5ndGgsIGVlID0gbmV3IEFycmF5KGwpOyBpIDwgbDsgaSsrKSB7XG4gICAgZWVbaV0gPSBoYW5kbGVyc1tpXS5mbjtcbiAgfVxuXG4gIHJldHVybiBlZTtcbn07XG5cbi8qKlxuICogUmV0dXJuIHRoZSBudW1iZXIgb2YgbGlzdGVuZXJzIGxpc3RlbmluZyB0byBhIGdpdmVuIGV2ZW50LlxuICpcbiAqIEBwYXJhbSB7KFN0cmluZ3xTeW1ib2wpfSBldmVudCBUaGUgZXZlbnQgbmFtZS5cbiAqIEByZXR1cm5zIHtOdW1iZXJ9IFRoZSBudW1iZXIgb2YgbGlzdGVuZXJzLlxuICogQHB1YmxpY1xuICovXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLmxpc3RlbmVyQ291bnQgPSBmdW5jdGlvbiBsaXN0ZW5lckNvdW50KGV2ZW50KSB7XG4gIHZhciBldnQgPSBwcmVmaXggPyBwcmVmaXggKyBldmVudCA6IGV2ZW50XG4gICAgLCBsaXN0ZW5lcnMgPSB0aGlzLl9ldmVudHNbZXZ0XTtcblxuICBpZiAoIWxpc3RlbmVycykgcmV0dXJuIDA7XG4gIGlmIChsaXN0ZW5lcnMuZm4pIHJldHVybiAxO1xuICByZXR1cm4gbGlzdGVuZXJzLmxlbmd0aDtcbn07XG5cbi8qKlxuICogQ2FsbHMgZWFjaCBvZiB0aGUgbGlzdGVuZXJzIHJlZ2lzdGVyZWQgZm9yIGEgZ2l2ZW4gZXZlbnQuXG4gKlxuICogQHBhcmFtIHsoU3RyaW5nfFN5bWJvbCl9IGV2ZW50IFRoZSBldmVudCBuYW1lLlxuICogQHJldHVybnMge0Jvb2xlYW59IGB0cnVlYCBpZiB0aGUgZXZlbnQgaGFkIGxpc3RlbmVycywgZWxzZSBgZmFsc2VgLlxuICogQHB1YmxpY1xuICovXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLmVtaXQgPSBmdW5jdGlvbiBlbWl0KGV2ZW50LCBhMSwgYTIsIGEzLCBhNCwgYTUpIHtcbiAgdmFyIGV2dCA9IHByZWZpeCA/IHByZWZpeCArIGV2ZW50IDogZXZlbnQ7XG5cbiAgaWYgKCF0aGlzLl9ldmVudHNbZXZ0XSkgcmV0dXJuIGZhbHNlO1xuXG4gIHZhciBsaXN0ZW5lcnMgPSB0aGlzLl9ldmVudHNbZXZ0XVxuICAgICwgbGVuID0gYXJndW1lbnRzLmxlbmd0aFxuICAgICwgYXJnc1xuICAgICwgaTtcblxuICBpZiAobGlzdGVuZXJzLmZuKSB7XG4gICAgaWYgKGxpc3RlbmVycy5vbmNlKSB0aGlzLnJlbW92ZUxpc3RlbmVyKGV2ZW50LCBsaXN0ZW5lcnMuZm4sIHVuZGVmaW5lZCwgdHJ1ZSk7XG5cbiAgICBzd2l0Y2ggKGxlbikge1xuICAgICAgY2FzZSAxOiByZXR1cm4gbGlzdGVuZXJzLmZuLmNhbGwobGlzdGVuZXJzLmNvbnRleHQpLCB0cnVlO1xuICAgICAgY2FzZSAyOiByZXR1cm4gbGlzdGVuZXJzLmZuLmNhbGwobGlzdGVuZXJzLmNvbnRleHQsIGExKSwgdHJ1ZTtcbiAgICAgIGNhc2UgMzogcmV0dXJuIGxpc3RlbmVycy5mbi5jYWxsKGxpc3RlbmVycy5jb250ZXh0LCBhMSwgYTIpLCB0cnVlO1xuICAgICAgY2FzZSA0OiByZXR1cm4gbGlzdGVuZXJzLmZuLmNhbGwobGlzdGVuZXJzLmNvbnRleHQsIGExLCBhMiwgYTMpLCB0cnVlO1xuICAgICAgY2FzZSA1OiByZXR1cm4gbGlzdGVuZXJzLmZuLmNhbGwobGlzdGVuZXJzLmNvbnRleHQsIGExLCBhMiwgYTMsIGE0KSwgdHJ1ZTtcbiAgICAgIGNhc2UgNjogcmV0dXJuIGxpc3RlbmVycy5mbi5jYWxsKGxpc3RlbmVycy5jb250ZXh0LCBhMSwgYTIsIGEzLCBhNCwgYTUpLCB0cnVlO1xuICAgIH1cblxuICAgIGZvciAoaSA9IDEsIGFyZ3MgPSBuZXcgQXJyYXkobGVuIC0xKTsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICBhcmdzW2kgLSAxXSA9IGFyZ3VtZW50c1tpXTtcbiAgICB9XG5cbiAgICBsaXN0ZW5lcnMuZm4uYXBwbHkobGlzdGVuZXJzLmNvbnRleHQsIGFyZ3MpO1xuICB9IGVsc2Uge1xuICAgIHZhciBsZW5ndGggPSBsaXN0ZW5lcnMubGVuZ3RoXG4gICAgICAsIGo7XG5cbiAgICBmb3IgKGkgPSAwOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgIGlmIChsaXN0ZW5lcnNbaV0ub25jZSkgdGhpcy5yZW1vdmVMaXN0ZW5lcihldmVudCwgbGlzdGVuZXJzW2ldLmZuLCB1bmRlZmluZWQsIHRydWUpO1xuXG4gICAgICBzd2l0Y2ggKGxlbikge1xuICAgICAgICBjYXNlIDE6IGxpc3RlbmVyc1tpXS5mbi5jYWxsKGxpc3RlbmVyc1tpXS5jb250ZXh0KTsgYnJlYWs7XG4gICAgICAgIGNhc2UgMjogbGlzdGVuZXJzW2ldLmZuLmNhbGwobGlzdGVuZXJzW2ldLmNvbnRleHQsIGExKTsgYnJlYWs7XG4gICAgICAgIGNhc2UgMzogbGlzdGVuZXJzW2ldLmZuLmNhbGwobGlzdGVuZXJzW2ldLmNvbnRleHQsIGExLCBhMik7IGJyZWFrO1xuICAgICAgICBjYXNlIDQ6IGxpc3RlbmVyc1tpXS5mbi5jYWxsKGxpc3RlbmVyc1tpXS5jb250ZXh0LCBhMSwgYTIsIGEzKTsgYnJlYWs7XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgaWYgKCFhcmdzKSBmb3IgKGogPSAxLCBhcmdzID0gbmV3IEFycmF5KGxlbiAtMSk7IGogPCBsZW47IGorKykge1xuICAgICAgICAgICAgYXJnc1tqIC0gMV0gPSBhcmd1bWVudHNbal07XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgbGlzdGVuZXJzW2ldLmZuLmFwcGx5KGxpc3RlbmVyc1tpXS5jb250ZXh0LCBhcmdzKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICByZXR1cm4gdHJ1ZTtcbn07XG5cbi8qKlxuICogQWRkIGEgbGlzdGVuZXIgZm9yIGEgZ2l2ZW4gZXZlbnQuXG4gKlxuICogQHBhcmFtIHsoU3RyaW5nfFN5bWJvbCl9IGV2ZW50IFRoZSBldmVudCBuYW1lLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gZm4gVGhlIGxpc3RlbmVyIGZ1bmN0aW9uLlxuICogQHBhcmFtIHsqfSBbY29udGV4dD10aGlzXSBUaGUgY29udGV4dCB0byBpbnZva2UgdGhlIGxpc3RlbmVyIHdpdGguXG4gKiBAcmV0dXJucyB7RXZlbnRFbWl0dGVyfSBgdGhpc2AuXG4gKiBAcHVibGljXG4gKi9cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUub24gPSBmdW5jdGlvbiBvbihldmVudCwgZm4sIGNvbnRleHQpIHtcbiAgcmV0dXJuIGFkZExpc3RlbmVyKHRoaXMsIGV2ZW50LCBmbiwgY29udGV4dCwgZmFsc2UpO1xufTtcblxuLyoqXG4gKiBBZGQgYSBvbmUtdGltZSBsaXN0ZW5lciBmb3IgYSBnaXZlbiBldmVudC5cbiAqXG4gKiBAcGFyYW0geyhTdHJpbmd8U3ltYm9sKX0gZXZlbnQgVGhlIGV2ZW50IG5hbWUuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmbiBUaGUgbGlzdGVuZXIgZnVuY3Rpb24uXG4gKiBAcGFyYW0geyp9IFtjb250ZXh0PXRoaXNdIFRoZSBjb250ZXh0IHRvIGludm9rZSB0aGUgbGlzdGVuZXIgd2l0aC5cbiAqIEByZXR1cm5zIHtFdmVudEVtaXR0ZXJ9IGB0aGlzYC5cbiAqIEBwdWJsaWNcbiAqL1xuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5vbmNlID0gZnVuY3Rpb24gb25jZShldmVudCwgZm4sIGNvbnRleHQpIHtcbiAgcmV0dXJuIGFkZExpc3RlbmVyKHRoaXMsIGV2ZW50LCBmbiwgY29udGV4dCwgdHJ1ZSk7XG59O1xuXG4vKipcbiAqIFJlbW92ZSB0aGUgbGlzdGVuZXJzIG9mIGEgZ2l2ZW4gZXZlbnQuXG4gKlxuICogQHBhcmFtIHsoU3RyaW5nfFN5bWJvbCl9IGV2ZW50IFRoZSBldmVudCBuYW1lLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gZm4gT25seSByZW1vdmUgdGhlIGxpc3RlbmVycyB0aGF0IG1hdGNoIHRoaXMgZnVuY3Rpb24uXG4gKiBAcGFyYW0geyp9IGNvbnRleHQgT25seSByZW1vdmUgdGhlIGxpc3RlbmVycyB0aGF0IGhhdmUgdGhpcyBjb250ZXh0LlxuICogQHBhcmFtIHtCb29sZWFufSBvbmNlIE9ubHkgcmVtb3ZlIG9uZS10aW1lIGxpc3RlbmVycy5cbiAqIEByZXR1cm5zIHtFdmVudEVtaXR0ZXJ9IGB0aGlzYC5cbiAqIEBwdWJsaWNcbiAqL1xuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5yZW1vdmVMaXN0ZW5lciA9IGZ1bmN0aW9uIHJlbW92ZUxpc3RlbmVyKGV2ZW50LCBmbiwgY29udGV4dCwgb25jZSkge1xuICB2YXIgZXZ0ID0gcHJlZml4ID8gcHJlZml4ICsgZXZlbnQgOiBldmVudDtcblxuICBpZiAoIXRoaXMuX2V2ZW50c1tldnRdKSByZXR1cm4gdGhpcztcbiAgaWYgKCFmbikge1xuICAgIGNsZWFyRXZlbnQodGhpcywgZXZ0KTtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIHZhciBsaXN0ZW5lcnMgPSB0aGlzLl9ldmVudHNbZXZ0XTtcblxuICBpZiAobGlzdGVuZXJzLmZuKSB7XG4gICAgaWYgKFxuICAgICAgbGlzdGVuZXJzLmZuID09PSBmbiAmJlxuICAgICAgKCFvbmNlIHx8IGxpc3RlbmVycy5vbmNlKSAmJlxuICAgICAgKCFjb250ZXh0IHx8IGxpc3RlbmVycy5jb250ZXh0ID09PSBjb250ZXh0KVxuICAgICkge1xuICAgICAgY2xlYXJFdmVudCh0aGlzLCBldnQpO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBmb3IgKHZhciBpID0gMCwgZXZlbnRzID0gW10sIGxlbmd0aCA9IGxpc3RlbmVycy5sZW5ndGg7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgaWYgKFxuICAgICAgICBsaXN0ZW5lcnNbaV0uZm4gIT09IGZuIHx8XG4gICAgICAgIChvbmNlICYmICFsaXN0ZW5lcnNbaV0ub25jZSkgfHxcbiAgICAgICAgKGNvbnRleHQgJiYgbGlzdGVuZXJzW2ldLmNvbnRleHQgIT09IGNvbnRleHQpXG4gICAgICApIHtcbiAgICAgICAgZXZlbnRzLnB1c2gobGlzdGVuZXJzW2ldKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvL1xuICAgIC8vIFJlc2V0IHRoZSBhcnJheSwgb3IgcmVtb3ZlIGl0IGNvbXBsZXRlbHkgaWYgd2UgaGF2ZSBubyBtb3JlIGxpc3RlbmVycy5cbiAgICAvL1xuICAgIGlmIChldmVudHMubGVuZ3RoKSB0aGlzLl9ldmVudHNbZXZ0XSA9IGV2ZW50cy5sZW5ndGggPT09IDEgPyBldmVudHNbMF0gOiBldmVudHM7XG4gICAgZWxzZSBjbGVhckV2ZW50KHRoaXMsIGV2dCk7XG4gIH1cblxuICByZXR1cm4gdGhpcztcbn07XG5cbi8qKlxuICogUmVtb3ZlIGFsbCBsaXN0ZW5lcnMsIG9yIHRob3NlIG9mIHRoZSBzcGVjaWZpZWQgZXZlbnQuXG4gKlxuICogQHBhcmFtIHsoU3RyaW5nfFN5bWJvbCl9IFtldmVudF0gVGhlIGV2ZW50IG5hbWUuXG4gKiBAcmV0dXJucyB7RXZlbnRFbWl0dGVyfSBgdGhpc2AuXG4gKiBAcHVibGljXG4gKi9cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUucmVtb3ZlQWxsTGlzdGVuZXJzID0gZnVuY3Rpb24gcmVtb3ZlQWxsTGlzdGVuZXJzKGV2ZW50KSB7XG4gIHZhciBldnQ7XG5cbiAgaWYgKGV2ZW50KSB7XG4gICAgZXZ0ID0gcHJlZml4ID8gcHJlZml4ICsgZXZlbnQgOiBldmVudDtcbiAgICBpZiAodGhpcy5fZXZlbnRzW2V2dF0pIGNsZWFyRXZlbnQodGhpcywgZXZ0KTtcbiAgfSBlbHNlIHtcbiAgICB0aGlzLl9ldmVudHMgPSBuZXcgRXZlbnRzKCk7XG4gICAgdGhpcy5fZXZlbnRzQ291bnQgPSAwO1xuICB9XG5cbiAgcmV0dXJuIHRoaXM7XG59O1xuXG4vL1xuLy8gQWxpYXMgbWV0aG9kcyBuYW1lcyBiZWNhdXNlIHBlb3BsZSByb2xsIGxpa2UgdGhhdC5cbi8vXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLm9mZiA9IEV2ZW50RW1pdHRlci5wcm90b3R5cGUucmVtb3ZlTGlzdGVuZXI7XG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLmFkZExpc3RlbmVyID0gRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5vbjtcblxuLy9cbi8vIEV4cG9zZSB0aGUgcHJlZml4LlxuLy9cbkV2ZW50RW1pdHRlci5wcmVmaXhlZCA9IHByZWZpeDtcblxuLy9cbi8vIEFsbG93IGBFdmVudEVtaXR0ZXJgIHRvIGJlIGltcG9ydGVkIGFzIG1vZHVsZSBuYW1lc3BhY2UuXG4vL1xuRXZlbnRFbWl0dGVyLkV2ZW50RW1pdHRlciA9IEV2ZW50RW1pdHRlcjtcblxuLy9cbi8vIEV4cG9zZSB0aGUgbW9kdWxlLlxuLy9cbmlmICgndW5kZWZpbmVkJyAhPT0gdHlwZW9mIG1vZHVsZSkge1xuICBtb2R1bGUuZXhwb3J0cyA9IEV2ZW50RW1pdHRlcjtcbn1cbiIsIi8qKlxuICogRnVzZS5qcyB2Ni42LjIgLSBMaWdodHdlaWdodCBmdXp6eS1zZWFyY2ggKGh0dHA6Ly9mdXNlanMuaW8pXG4gKlxuICogQ29weXJpZ2h0IChjKSAyMDIyIEtpcm8gUmlzayAoaHR0cDovL2tpcm8ubWUpXG4gKiBBbGwgUmlnaHRzIFJlc2VydmVkLiBBcGFjaGUgU29mdHdhcmUgTGljZW5zZSAyLjBcbiAqXG4gKiBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqL1xuXG5mdW5jdGlvbiBpc0FycmF5KHZhbHVlKSB7XG4gIHJldHVybiAhQXJyYXkuaXNBcnJheVxuICAgID8gZ2V0VGFnKHZhbHVlKSA9PT0gJ1tvYmplY3QgQXJyYXldJ1xuICAgIDogQXJyYXkuaXNBcnJheSh2YWx1ZSlcbn1cblxuLy8gQWRhcHRlZCBmcm9tOiBodHRwczovL2dpdGh1Yi5jb20vbG9kYXNoL2xvZGFzaC9ibG9iL21hc3Rlci8uaW50ZXJuYWwvYmFzZVRvU3RyaW5nLmpzXG5jb25zdCBJTkZJTklUWSA9IDEgLyAwO1xuZnVuY3Rpb24gYmFzZVRvU3RyaW5nKHZhbHVlKSB7XG4gIC8vIEV4aXQgZWFybHkgZm9yIHN0cmluZ3MgdG8gYXZvaWQgYSBwZXJmb3JtYW5jZSBoaXQgaW4gc29tZSBlbnZpcm9ubWVudHMuXG4gIGlmICh0eXBlb2YgdmFsdWUgPT0gJ3N0cmluZycpIHtcbiAgICByZXR1cm4gdmFsdWVcbiAgfVxuICBsZXQgcmVzdWx0ID0gdmFsdWUgKyAnJztcbiAgcmV0dXJuIHJlc3VsdCA9PSAnMCcgJiYgMSAvIHZhbHVlID09IC1JTkZJTklUWSA/ICctMCcgOiByZXN1bHRcbn1cblxuZnVuY3Rpb24gdG9TdHJpbmcodmFsdWUpIHtcbiAgcmV0dXJuIHZhbHVlID09IG51bGwgPyAnJyA6IGJhc2VUb1N0cmluZyh2YWx1ZSlcbn1cblxuZnVuY3Rpb24gaXNTdHJpbmcodmFsdWUpIHtcbiAgcmV0dXJuIHR5cGVvZiB2YWx1ZSA9PT0gJ3N0cmluZydcbn1cblxuZnVuY3Rpb24gaXNOdW1iZXIodmFsdWUpIHtcbiAgcmV0dXJuIHR5cGVvZiB2YWx1ZSA9PT0gJ251bWJlcidcbn1cblxuLy8gQWRhcHRlZCBmcm9tOiBodHRwczovL2dpdGh1Yi5jb20vbG9kYXNoL2xvZGFzaC9ibG9iL21hc3Rlci9pc0Jvb2xlYW4uanNcbmZ1bmN0aW9uIGlzQm9vbGVhbih2YWx1ZSkge1xuICByZXR1cm4gKFxuICAgIHZhbHVlID09PSB0cnVlIHx8XG4gICAgdmFsdWUgPT09IGZhbHNlIHx8XG4gICAgKGlzT2JqZWN0TGlrZSh2YWx1ZSkgJiYgZ2V0VGFnKHZhbHVlKSA9PSAnW29iamVjdCBCb29sZWFuXScpXG4gIClcbn1cblxuZnVuY3Rpb24gaXNPYmplY3QodmFsdWUpIHtcbiAgcmV0dXJuIHR5cGVvZiB2YWx1ZSA9PT0gJ29iamVjdCdcbn1cblxuLy8gQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgb2JqZWN0LWxpa2UuXG5mdW5jdGlvbiBpc09iamVjdExpa2UodmFsdWUpIHtcbiAgcmV0dXJuIGlzT2JqZWN0KHZhbHVlKSAmJiB2YWx1ZSAhPT0gbnVsbFxufVxuXG5mdW5jdGlvbiBpc0RlZmluZWQodmFsdWUpIHtcbiAgcmV0dXJuIHZhbHVlICE9PSB1bmRlZmluZWQgJiYgdmFsdWUgIT09IG51bGxcbn1cblxuZnVuY3Rpb24gaXNCbGFuayh2YWx1ZSkge1xuICByZXR1cm4gIXZhbHVlLnRyaW0oKS5sZW5ndGhcbn1cblxuLy8gR2V0cyB0aGUgYHRvU3RyaW5nVGFnYCBvZiBgdmFsdWVgLlxuLy8gQWRhcHRlZCBmcm9tOiBodHRwczovL2dpdGh1Yi5jb20vbG9kYXNoL2xvZGFzaC9ibG9iL21hc3Rlci8uaW50ZXJuYWwvZ2V0VGFnLmpzXG5mdW5jdGlvbiBnZXRUYWcodmFsdWUpIHtcbiAgcmV0dXJuIHZhbHVlID09IG51bGxcbiAgICA/IHZhbHVlID09PSB1bmRlZmluZWRcbiAgICAgID8gJ1tvYmplY3QgVW5kZWZpbmVkXSdcbiAgICAgIDogJ1tvYmplY3QgTnVsbF0nXG4gICAgOiBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwodmFsdWUpXG59XG5cbmNvbnN0IEVYVEVOREVEX1NFQVJDSF9VTkFWQUlMQUJMRSA9ICdFeHRlbmRlZCBzZWFyY2ggaXMgbm90IGF2YWlsYWJsZSc7XG5cbmNvbnN0IElOQ09SUkVDVF9JTkRFWF9UWVBFID0gXCJJbmNvcnJlY3QgJ2luZGV4JyB0eXBlXCI7XG5cbmNvbnN0IExPR0lDQUxfU0VBUkNIX0lOVkFMSURfUVVFUllfRk9SX0tFWSA9IChrZXkpID0+XG4gIGBJbnZhbGlkIHZhbHVlIGZvciBrZXkgJHtrZXl9YDtcblxuY29uc3QgUEFUVEVSTl9MRU5HVEhfVE9PX0xBUkdFID0gKG1heCkgPT5cbiAgYFBhdHRlcm4gbGVuZ3RoIGV4Y2VlZHMgbWF4IG9mICR7bWF4fS5gO1xuXG5jb25zdCBNSVNTSU5HX0tFWV9QUk9QRVJUWSA9IChuYW1lKSA9PiBgTWlzc2luZyAke25hbWV9IHByb3BlcnR5IGluIGtleWA7XG5cbmNvbnN0IElOVkFMSURfS0VZX1dFSUdIVF9WQUxVRSA9IChrZXkpID0+XG4gIGBQcm9wZXJ0eSAnd2VpZ2h0JyBpbiBrZXkgJyR7a2V5fScgbXVzdCBiZSBhIHBvc2l0aXZlIGludGVnZXJgO1xuXG5jb25zdCBoYXNPd24gPSBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5O1xuXG5jbGFzcyBLZXlTdG9yZSB7XG4gIGNvbnN0cnVjdG9yKGtleXMpIHtcbiAgICB0aGlzLl9rZXlzID0gW107XG4gICAgdGhpcy5fa2V5TWFwID0ge307XG5cbiAgICBsZXQgdG90YWxXZWlnaHQgPSAwO1xuXG4gICAga2V5cy5mb3JFYWNoKChrZXkpID0+IHtcbiAgICAgIGxldCBvYmogPSBjcmVhdGVLZXkoa2V5KTtcblxuICAgICAgdG90YWxXZWlnaHQgKz0gb2JqLndlaWdodDtcblxuICAgICAgdGhpcy5fa2V5cy5wdXNoKG9iaik7XG4gICAgICB0aGlzLl9rZXlNYXBbb2JqLmlkXSA9IG9iajtcblxuICAgICAgdG90YWxXZWlnaHQgKz0gb2JqLndlaWdodDtcbiAgICB9KTtcblxuICAgIC8vIE5vcm1hbGl6ZSB3ZWlnaHRzIHNvIHRoYXQgdGhlaXIgc3VtIGlzIGVxdWFsIHRvIDFcbiAgICB0aGlzLl9rZXlzLmZvckVhY2goKGtleSkgPT4ge1xuICAgICAga2V5LndlaWdodCAvPSB0b3RhbFdlaWdodDtcbiAgICB9KTtcbiAgfVxuICBnZXQoa2V5SWQpIHtcbiAgICByZXR1cm4gdGhpcy5fa2V5TWFwW2tleUlkXVxuICB9XG4gIGtleXMoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2tleXNcbiAgfVxuICB0b0pTT04oKSB7XG4gICAgcmV0dXJuIEpTT04uc3RyaW5naWZ5KHRoaXMuX2tleXMpXG4gIH1cbn1cblxuZnVuY3Rpb24gY3JlYXRlS2V5KGtleSkge1xuICBsZXQgcGF0aCA9IG51bGw7XG4gIGxldCBpZCA9IG51bGw7XG4gIGxldCBzcmMgPSBudWxsO1xuICBsZXQgd2VpZ2h0ID0gMTtcbiAgbGV0IGdldEZuID0gbnVsbDtcblxuICBpZiAoaXNTdHJpbmcoa2V5KSB8fCBpc0FycmF5KGtleSkpIHtcbiAgICBzcmMgPSBrZXk7XG4gICAgcGF0aCA9IGNyZWF0ZUtleVBhdGgoa2V5KTtcbiAgICBpZCA9IGNyZWF0ZUtleUlkKGtleSk7XG4gIH0gZWxzZSB7XG4gICAgaWYgKCFoYXNPd24uY2FsbChrZXksICduYW1lJykpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihNSVNTSU5HX0tFWV9QUk9QRVJUWSgnbmFtZScpKVxuICAgIH1cblxuICAgIGNvbnN0IG5hbWUgPSBrZXkubmFtZTtcbiAgICBzcmMgPSBuYW1lO1xuXG4gICAgaWYgKGhhc093bi5jYWxsKGtleSwgJ3dlaWdodCcpKSB7XG4gICAgICB3ZWlnaHQgPSBrZXkud2VpZ2h0O1xuXG4gICAgICBpZiAod2VpZ2h0IDw9IDApIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKElOVkFMSURfS0VZX1dFSUdIVF9WQUxVRShuYW1lKSlcbiAgICAgIH1cbiAgICB9XG5cbiAgICBwYXRoID0gY3JlYXRlS2V5UGF0aChuYW1lKTtcbiAgICBpZCA9IGNyZWF0ZUtleUlkKG5hbWUpO1xuICAgIGdldEZuID0ga2V5LmdldEZuO1xuICB9XG5cbiAgcmV0dXJuIHsgcGF0aCwgaWQsIHdlaWdodCwgc3JjLCBnZXRGbiB9XG59XG5cbmZ1bmN0aW9uIGNyZWF0ZUtleVBhdGgoa2V5KSB7XG4gIHJldHVybiBpc0FycmF5KGtleSkgPyBrZXkgOiBrZXkuc3BsaXQoJy4nKVxufVxuXG5mdW5jdGlvbiBjcmVhdGVLZXlJZChrZXkpIHtcbiAgcmV0dXJuIGlzQXJyYXkoa2V5KSA/IGtleS5qb2luKCcuJykgOiBrZXlcbn1cblxuZnVuY3Rpb24gZ2V0KG9iaiwgcGF0aCkge1xuICBsZXQgbGlzdCA9IFtdO1xuICBsZXQgYXJyID0gZmFsc2U7XG5cbiAgY29uc3QgZGVlcEdldCA9IChvYmosIHBhdGgsIGluZGV4KSA9PiB7XG4gICAgaWYgKCFpc0RlZmluZWQob2JqKSkge1xuICAgICAgcmV0dXJuXG4gICAgfVxuICAgIGlmICghcGF0aFtpbmRleF0pIHtcbiAgICAgIC8vIElmIHRoZXJlJ3Mgbm8gcGF0aCBsZWZ0LCB3ZSd2ZSBhcnJpdmVkIGF0IHRoZSBvYmplY3Qgd2UgY2FyZSBhYm91dC5cbiAgICAgIGxpc3QucHVzaChvYmopO1xuICAgIH0gZWxzZSB7XG4gICAgICBsZXQga2V5ID0gcGF0aFtpbmRleF07XG5cbiAgICAgIGNvbnN0IHZhbHVlID0gb2JqW2tleV07XG5cbiAgICAgIGlmICghaXNEZWZpbmVkKHZhbHVlKSkge1xuICAgICAgICByZXR1cm5cbiAgICAgIH1cblxuICAgICAgLy8gSWYgd2UncmUgYXQgdGhlIGxhc3QgdmFsdWUgaW4gdGhlIHBhdGgsIGFuZCBpZiBpdCdzIGEgc3RyaW5nL251bWJlci9ib29sLFxuICAgICAgLy8gYWRkIGl0IHRvIHRoZSBsaXN0XG4gICAgICBpZiAoXG4gICAgICAgIGluZGV4ID09PSBwYXRoLmxlbmd0aCAtIDEgJiZcbiAgICAgICAgKGlzU3RyaW5nKHZhbHVlKSB8fCBpc051bWJlcih2YWx1ZSkgfHwgaXNCb29sZWFuKHZhbHVlKSlcbiAgICAgICkge1xuICAgICAgICBsaXN0LnB1c2godG9TdHJpbmcodmFsdWUpKTtcbiAgICAgIH0gZWxzZSBpZiAoaXNBcnJheSh2YWx1ZSkpIHtcbiAgICAgICAgYXJyID0gdHJ1ZTtcbiAgICAgICAgLy8gU2VhcmNoIGVhY2ggaXRlbSBpbiB0aGUgYXJyYXkuXG4gICAgICAgIGZvciAobGV0IGkgPSAwLCBsZW4gPSB2YWx1ZS5sZW5ndGg7IGkgPCBsZW47IGkgKz0gMSkge1xuICAgICAgICAgIGRlZXBHZXQodmFsdWVbaV0sIHBhdGgsIGluZGV4ICsgMSk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAocGF0aC5sZW5ndGgpIHtcbiAgICAgICAgLy8gQW4gb2JqZWN0LiBSZWN1cnNlIGZ1cnRoZXIuXG4gICAgICAgIGRlZXBHZXQodmFsdWUsIHBhdGgsIGluZGV4ICsgMSk7XG4gICAgICB9XG4gICAgfVxuICB9O1xuXG4gIC8vIEJhY2t3YXJkcyBjb21wYXRpYmlsaXR5IChzaW5jZSBwYXRoIHVzZWQgdG8gYmUgYSBzdHJpbmcpXG4gIGRlZXBHZXQob2JqLCBpc1N0cmluZyhwYXRoKSA/IHBhdGguc3BsaXQoJy4nKSA6IHBhdGgsIDApO1xuXG4gIHJldHVybiBhcnIgPyBsaXN0IDogbGlzdFswXVxufVxuXG5jb25zdCBNYXRjaE9wdGlvbnMgPSB7XG4gIC8vIFdoZXRoZXIgdGhlIG1hdGNoZXMgc2hvdWxkIGJlIGluY2x1ZGVkIGluIHRoZSByZXN1bHQgc2V0LiBXaGVuIGB0cnVlYCwgZWFjaCByZWNvcmQgaW4gdGhlIHJlc3VsdFxuICAvLyBzZXQgd2lsbCBpbmNsdWRlIHRoZSBpbmRpY2VzIG9mIHRoZSBtYXRjaGVkIGNoYXJhY3RlcnMuXG4gIC8vIFRoZXNlIGNhbiBjb25zZXF1ZW50bHkgYmUgdXNlZCBmb3IgaGlnaGxpZ2h0aW5nIHB1cnBvc2VzLlxuICBpbmNsdWRlTWF0Y2hlczogZmFsc2UsXG4gIC8vIFdoZW4gYHRydWVgLCB0aGUgbWF0Y2hpbmcgZnVuY3Rpb24gd2lsbCBjb250aW51ZSB0byB0aGUgZW5kIG9mIGEgc2VhcmNoIHBhdHRlcm4gZXZlbiBpZlxuICAvLyBhIHBlcmZlY3QgbWF0Y2ggaGFzIGFscmVhZHkgYmVlbiBsb2NhdGVkIGluIHRoZSBzdHJpbmcuXG4gIGZpbmRBbGxNYXRjaGVzOiBmYWxzZSxcbiAgLy8gTWluaW11bSBudW1iZXIgb2YgY2hhcmFjdGVycyB0aGF0IG11c3QgYmUgbWF0Y2hlZCBiZWZvcmUgYSByZXN1bHQgaXMgY29uc2lkZXJlZCBhIG1hdGNoXG4gIG1pbk1hdGNoQ2hhckxlbmd0aDogMVxufTtcblxuY29uc3QgQmFzaWNPcHRpb25zID0ge1xuICAvLyBXaGVuIGB0cnVlYCwgdGhlIGFsZ29yaXRobSBjb250aW51ZXMgc2VhcmNoaW5nIHRvIHRoZSBlbmQgb2YgdGhlIGlucHV0IGV2ZW4gaWYgYSBwZXJmZWN0XG4gIC8vIG1hdGNoIGlzIGZvdW5kIGJlZm9yZSB0aGUgZW5kIG9mIHRoZSBzYW1lIGlucHV0LlxuICBpc0Nhc2VTZW5zaXRpdmU6IGZhbHNlLFxuICAvLyBXaGVuIHRydWUsIHRoZSBtYXRjaGluZyBmdW5jdGlvbiB3aWxsIGNvbnRpbnVlIHRvIHRoZSBlbmQgb2YgYSBzZWFyY2ggcGF0dGVybiBldmVuIGlmXG4gIGluY2x1ZGVTY29yZTogZmFsc2UsXG4gIC8vIExpc3Qgb2YgcHJvcGVydGllcyB0aGF0IHdpbGwgYmUgc2VhcmNoZWQuIFRoaXMgYWxzbyBzdXBwb3J0cyBuZXN0ZWQgcHJvcGVydGllcy5cbiAga2V5czogW10sXG4gIC8vIFdoZXRoZXIgdG8gc29ydCB0aGUgcmVzdWx0IGxpc3QsIGJ5IHNjb3JlXG4gIHNob3VsZFNvcnQ6IHRydWUsXG4gIC8vIERlZmF1bHQgc29ydCBmdW5jdGlvbjogc29ydCBieSBhc2NlbmRpbmcgc2NvcmUsIGFzY2VuZGluZyBpbmRleFxuICBzb3J0Rm46IChhLCBiKSA9PlxuICAgIGEuc2NvcmUgPT09IGIuc2NvcmUgPyAoYS5pZHggPCBiLmlkeCA/IC0xIDogMSkgOiBhLnNjb3JlIDwgYi5zY29yZSA/IC0xIDogMVxufTtcblxuY29uc3QgRnV6enlPcHRpb25zID0ge1xuICAvLyBBcHByb3hpbWF0ZWx5IHdoZXJlIGluIHRoZSB0ZXh0IGlzIHRoZSBwYXR0ZXJuIGV4cGVjdGVkIHRvIGJlIGZvdW5kP1xuICBsb2NhdGlvbjogMCxcbiAgLy8gQXQgd2hhdCBwb2ludCBkb2VzIHRoZSBtYXRjaCBhbGdvcml0aG0gZ2l2ZSB1cC4gQSB0aHJlc2hvbGQgb2YgJzAuMCcgcmVxdWlyZXMgYSBwZXJmZWN0IG1hdGNoXG4gIC8vIChvZiBib3RoIGxldHRlcnMgYW5kIGxvY2F0aW9uKSwgYSB0aHJlc2hvbGQgb2YgJzEuMCcgd291bGQgbWF0Y2ggYW55dGhpbmcuXG4gIHRocmVzaG9sZDogMC42LFxuICAvLyBEZXRlcm1pbmVzIGhvdyBjbG9zZSB0aGUgbWF0Y2ggbXVzdCBiZSB0byB0aGUgZnV6enkgbG9jYXRpb24gKHNwZWNpZmllZCBhYm92ZSkuXG4gIC8vIEFuIGV4YWN0IGxldHRlciBtYXRjaCB3aGljaCBpcyAnZGlzdGFuY2UnIGNoYXJhY3RlcnMgYXdheSBmcm9tIHRoZSBmdXp6eSBsb2NhdGlvblxuICAvLyB3b3VsZCBzY29yZSBhcyBhIGNvbXBsZXRlIG1pc21hdGNoLiBBIGRpc3RhbmNlIG9mICcwJyByZXF1aXJlcyB0aGUgbWF0Y2ggYmUgYXRcbiAgLy8gdGhlIGV4YWN0IGxvY2F0aW9uIHNwZWNpZmllZCwgYSB0aHJlc2hvbGQgb2YgJzEwMDAnIHdvdWxkIHJlcXVpcmUgYSBwZXJmZWN0IG1hdGNoXG4gIC8vIHRvIGJlIHdpdGhpbiA4MDAgY2hhcmFjdGVycyBvZiB0aGUgZnV6enkgbG9jYXRpb24gdG8gYmUgZm91bmQgdXNpbmcgYSAwLjggdGhyZXNob2xkLlxuICBkaXN0YW5jZTogMTAwXG59O1xuXG5jb25zdCBBZHZhbmNlZE9wdGlvbnMgPSB7XG4gIC8vIFdoZW4gYHRydWVgLCBpdCBlbmFibGVzIHRoZSB1c2Ugb2YgdW5peC1saWtlIHNlYXJjaCBjb21tYW5kc1xuICB1c2VFeHRlbmRlZFNlYXJjaDogZmFsc2UsXG4gIC8vIFRoZSBnZXQgZnVuY3Rpb24gdG8gdXNlIHdoZW4gZmV0Y2hpbmcgYW4gb2JqZWN0J3MgcHJvcGVydGllcy5cbiAgLy8gVGhlIGRlZmF1bHQgd2lsbCBzZWFyY2ggbmVzdGVkIHBhdGhzICppZSBmb28uYmFyLmJheipcbiAgZ2V0Rm46IGdldCxcbiAgLy8gV2hlbiBgdHJ1ZWAsIHNlYXJjaCB3aWxsIGlnbm9yZSBgbG9jYXRpb25gIGFuZCBgZGlzdGFuY2VgLCBzbyBpdCB3b24ndCBtYXR0ZXJcbiAgLy8gd2hlcmUgaW4gdGhlIHN0cmluZyB0aGUgcGF0dGVybiBhcHBlYXJzLlxuICAvLyBNb3JlIGluZm86IGh0dHBzOi8vZnVzZWpzLmlvL2NvbmNlcHRzL3Njb3JpbmctdGhlb3J5Lmh0bWwjZnV6emluZXNzLXNjb3JlXG4gIGlnbm9yZUxvY2F0aW9uOiBmYWxzZSxcbiAgLy8gV2hlbiBgdHJ1ZWAsIHRoZSBjYWxjdWxhdGlvbiBmb3IgdGhlIHJlbGV2YW5jZSBzY29yZSAodXNlZCBmb3Igc29ydGluZykgd2lsbFxuICAvLyBpZ25vcmUgdGhlIGZpZWxkLWxlbmd0aCBub3JtLlxuICAvLyBNb3JlIGluZm86IGh0dHBzOi8vZnVzZWpzLmlvL2NvbmNlcHRzL3Njb3JpbmctdGhlb3J5Lmh0bWwjZmllbGQtbGVuZ3RoLW5vcm1cbiAgaWdub3JlRmllbGROb3JtOiBmYWxzZSxcbiAgLy8gVGhlIHdlaWdodCB0byBkZXRlcm1pbmUgaG93IG11Y2ggZmllbGQgbGVuZ3RoIG5vcm0gZWZmZWN0cyBzY29yaW5nLlxuICBmaWVsZE5vcm1XZWlnaHQ6IDFcbn07XG5cbnZhciBDb25maWcgPSB7XG4gIC4uLkJhc2ljT3B0aW9ucyxcbiAgLi4uTWF0Y2hPcHRpb25zLFxuICAuLi5GdXp6eU9wdGlvbnMsXG4gIC4uLkFkdmFuY2VkT3B0aW9uc1xufTtcblxuY29uc3QgU1BBQ0UgPSAvW14gXSsvZztcblxuLy8gRmllbGQtbGVuZ3RoIG5vcm06IHRoZSBzaG9ydGVyIHRoZSBmaWVsZCwgdGhlIGhpZ2hlciB0aGUgd2VpZ2h0LlxuLy8gU2V0IHRvIDMgZGVjaW1hbHMgdG8gcmVkdWNlIGluZGV4IHNpemUuXG5mdW5jdGlvbiBub3JtKHdlaWdodCA9IDEsIG1hbnRpc3NhID0gMykge1xuICBjb25zdCBjYWNoZSA9IG5ldyBNYXAoKTtcbiAgY29uc3QgbSA9IE1hdGgucG93KDEwLCBtYW50aXNzYSk7XG5cbiAgcmV0dXJuIHtcbiAgICBnZXQodmFsdWUpIHtcbiAgICAgIGNvbnN0IG51bVRva2VucyA9IHZhbHVlLm1hdGNoKFNQQUNFKS5sZW5ndGg7XG5cbiAgICAgIGlmIChjYWNoZS5oYXMobnVtVG9rZW5zKSkge1xuICAgICAgICByZXR1cm4gY2FjaGUuZ2V0KG51bVRva2VucylcbiAgICAgIH1cblxuICAgICAgLy8gRGVmYXVsdCBmdW5jdGlvbiBpcyAxL3NxcnQoeCksIHdlaWdodCBtYWtlcyB0aGF0IHZhcmlhYmxlXG4gICAgICBjb25zdCBub3JtID0gMSAvIE1hdGgucG93KG51bVRva2VucywgMC41ICogd2VpZ2h0KTtcblxuICAgICAgLy8gSW4gcGxhY2Ugb2YgYHRvRml4ZWQobWFudGlzc2EpYCwgZm9yIGZhc3RlciBjb21wdXRhdGlvblxuICAgICAgY29uc3QgbiA9IHBhcnNlRmxvYXQoTWF0aC5yb3VuZChub3JtICogbSkgLyBtKTtcblxuICAgICAgY2FjaGUuc2V0KG51bVRva2Vucywgbik7XG5cbiAgICAgIHJldHVybiBuXG4gICAgfSxcbiAgICBjbGVhcigpIHtcbiAgICAgIGNhY2hlLmNsZWFyKCk7XG4gICAgfVxuICB9XG59XG5cbmNsYXNzIEZ1c2VJbmRleCB7XG4gIGNvbnN0cnVjdG9yKHtcbiAgICBnZXRGbiA9IENvbmZpZy5nZXRGbixcbiAgICBmaWVsZE5vcm1XZWlnaHQgPSBDb25maWcuZmllbGROb3JtV2VpZ2h0XG4gIH0gPSB7fSkge1xuICAgIHRoaXMubm9ybSA9IG5vcm0oZmllbGROb3JtV2VpZ2h0LCAzKTtcbiAgICB0aGlzLmdldEZuID0gZ2V0Rm47XG4gICAgdGhpcy5pc0NyZWF0ZWQgPSBmYWxzZTtcblxuICAgIHRoaXMuc2V0SW5kZXhSZWNvcmRzKCk7XG4gIH1cbiAgc2V0U291cmNlcyhkb2NzID0gW10pIHtcbiAgICB0aGlzLmRvY3MgPSBkb2NzO1xuICB9XG4gIHNldEluZGV4UmVjb3JkcyhyZWNvcmRzID0gW10pIHtcbiAgICB0aGlzLnJlY29yZHMgPSByZWNvcmRzO1xuICB9XG4gIHNldEtleXMoa2V5cyA9IFtdKSB7XG4gICAgdGhpcy5rZXlzID0ga2V5cztcbiAgICB0aGlzLl9rZXlzTWFwID0ge307XG4gICAga2V5cy5mb3JFYWNoKChrZXksIGlkeCkgPT4ge1xuICAgICAgdGhpcy5fa2V5c01hcFtrZXkuaWRdID0gaWR4O1xuICAgIH0pO1xuICB9XG4gIGNyZWF0ZSgpIHtcbiAgICBpZiAodGhpcy5pc0NyZWF0ZWQgfHwgIXRoaXMuZG9jcy5sZW5ndGgpIHtcbiAgICAgIHJldHVyblxuICAgIH1cblxuICAgIHRoaXMuaXNDcmVhdGVkID0gdHJ1ZTtcblxuICAgIC8vIExpc3QgaXMgQXJyYXk8U3RyaW5nPlxuICAgIGlmIChpc1N0cmluZyh0aGlzLmRvY3NbMF0pKSB7XG4gICAgICB0aGlzLmRvY3MuZm9yRWFjaCgoZG9jLCBkb2NJbmRleCkgPT4ge1xuICAgICAgICB0aGlzLl9hZGRTdHJpbmcoZG9jLCBkb2NJbmRleCk7XG4gICAgICB9KTtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gTGlzdCBpcyBBcnJheTxPYmplY3Q+XG4gICAgICB0aGlzLmRvY3MuZm9yRWFjaCgoZG9jLCBkb2NJbmRleCkgPT4ge1xuICAgICAgICB0aGlzLl9hZGRPYmplY3QoZG9jLCBkb2NJbmRleCk7XG4gICAgICB9KTtcbiAgICB9XG5cbiAgICB0aGlzLm5vcm0uY2xlYXIoKTtcbiAgfVxuICAvLyBBZGRzIGEgZG9jIHRvIHRoZSBlbmQgb2YgdGhlIGluZGV4XG4gIGFkZChkb2MpIHtcbiAgICBjb25zdCBpZHggPSB0aGlzLnNpemUoKTtcblxuICAgIGlmIChpc1N0cmluZyhkb2MpKSB7XG4gICAgICB0aGlzLl9hZGRTdHJpbmcoZG9jLCBpZHgpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLl9hZGRPYmplY3QoZG9jLCBpZHgpO1xuICAgIH1cbiAgfVxuICAvLyBSZW1vdmVzIHRoZSBkb2MgYXQgdGhlIHNwZWNpZmllZCBpbmRleCBvZiB0aGUgaW5kZXhcbiAgcmVtb3ZlQXQoaWR4KSB7XG4gICAgdGhpcy5yZWNvcmRzLnNwbGljZShpZHgsIDEpO1xuXG4gICAgLy8gQ2hhbmdlIHJlZiBpbmRleCBvZiBldmVyeSBzdWJzcXVlbnQgZG9jXG4gICAgZm9yIChsZXQgaSA9IGlkeCwgbGVuID0gdGhpcy5zaXplKCk7IGkgPCBsZW47IGkgKz0gMSkge1xuICAgICAgdGhpcy5yZWNvcmRzW2ldLmkgLT0gMTtcbiAgICB9XG4gIH1cbiAgZ2V0VmFsdWVGb3JJdGVtQXRLZXlJZChpdGVtLCBrZXlJZCkge1xuICAgIHJldHVybiBpdGVtW3RoaXMuX2tleXNNYXBba2V5SWRdXVxuICB9XG4gIHNpemUoKSB7XG4gICAgcmV0dXJuIHRoaXMucmVjb3Jkcy5sZW5ndGhcbiAgfVxuICBfYWRkU3RyaW5nKGRvYywgZG9jSW5kZXgpIHtcbiAgICBpZiAoIWlzRGVmaW5lZChkb2MpIHx8IGlzQmxhbmsoZG9jKSkge1xuICAgICAgcmV0dXJuXG4gICAgfVxuXG4gICAgbGV0IHJlY29yZCA9IHtcbiAgICAgIHY6IGRvYyxcbiAgICAgIGk6IGRvY0luZGV4LFxuICAgICAgbjogdGhpcy5ub3JtLmdldChkb2MpXG4gICAgfTtcblxuICAgIHRoaXMucmVjb3Jkcy5wdXNoKHJlY29yZCk7XG4gIH1cbiAgX2FkZE9iamVjdChkb2MsIGRvY0luZGV4KSB7XG4gICAgbGV0IHJlY29yZCA9IHsgaTogZG9jSW5kZXgsICQ6IHt9IH07XG5cbiAgICAvLyBJdGVyYXRlIG92ZXIgZXZlcnkga2V5IChpLmUsIHBhdGgpLCBhbmQgZmV0Y2ggdGhlIHZhbHVlIGF0IHRoYXQga2V5XG4gICAgdGhpcy5rZXlzLmZvckVhY2goKGtleSwga2V5SW5kZXgpID0+IHtcbiAgICAgIGxldCB2YWx1ZSA9IGtleS5nZXRGbiA/IGtleS5nZXRGbihkb2MpIDogdGhpcy5nZXRGbihkb2MsIGtleS5wYXRoKTtcblxuICAgICAgaWYgKCFpc0RlZmluZWQodmFsdWUpKSB7XG4gICAgICAgIHJldHVyblxuICAgICAgfVxuXG4gICAgICBpZiAoaXNBcnJheSh2YWx1ZSkpIHtcbiAgICAgICAgbGV0IHN1YlJlY29yZHMgPSBbXTtcbiAgICAgICAgY29uc3Qgc3RhY2sgPSBbeyBuZXN0ZWRBcnJJbmRleDogLTEsIHZhbHVlIH1dO1xuXG4gICAgICAgIHdoaWxlIChzdGFjay5sZW5ndGgpIHtcbiAgICAgICAgICBjb25zdCB7IG5lc3RlZEFyckluZGV4LCB2YWx1ZSB9ID0gc3RhY2sucG9wKCk7XG5cbiAgICAgICAgICBpZiAoIWlzRGVmaW5lZCh2YWx1ZSkpIHtcbiAgICAgICAgICAgIGNvbnRpbnVlXG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKGlzU3RyaW5nKHZhbHVlKSAmJiAhaXNCbGFuayh2YWx1ZSkpIHtcbiAgICAgICAgICAgIGxldCBzdWJSZWNvcmQgPSB7XG4gICAgICAgICAgICAgIHY6IHZhbHVlLFxuICAgICAgICAgICAgICBpOiBuZXN0ZWRBcnJJbmRleCxcbiAgICAgICAgICAgICAgbjogdGhpcy5ub3JtLmdldCh2YWx1ZSlcbiAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgIHN1YlJlY29yZHMucHVzaChzdWJSZWNvcmQpO1xuICAgICAgICAgIH0gZWxzZSBpZiAoaXNBcnJheSh2YWx1ZSkpIHtcbiAgICAgICAgICAgIHZhbHVlLmZvckVhY2goKGl0ZW0sIGspID0+IHtcbiAgICAgICAgICAgICAgc3RhY2sucHVzaCh7XG4gICAgICAgICAgICAgICAgbmVzdGVkQXJySW5kZXg6IGssXG4gICAgICAgICAgICAgICAgdmFsdWU6IGl0ZW1cbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9IGVsc2UgO1xuICAgICAgICB9XG4gICAgICAgIHJlY29yZC4kW2tleUluZGV4XSA9IHN1YlJlY29yZHM7XG4gICAgICB9IGVsc2UgaWYgKGlzU3RyaW5nKHZhbHVlKSAmJiAhaXNCbGFuayh2YWx1ZSkpIHtcbiAgICAgICAgbGV0IHN1YlJlY29yZCA9IHtcbiAgICAgICAgICB2OiB2YWx1ZSxcbiAgICAgICAgICBuOiB0aGlzLm5vcm0uZ2V0KHZhbHVlKVxuICAgICAgICB9O1xuXG4gICAgICAgIHJlY29yZC4kW2tleUluZGV4XSA9IHN1YlJlY29yZDtcbiAgICAgIH1cbiAgICB9KTtcblxuICAgIHRoaXMucmVjb3Jkcy5wdXNoKHJlY29yZCk7XG4gIH1cbiAgdG9KU09OKCkge1xuICAgIHJldHVybiB7XG4gICAgICBrZXlzOiB0aGlzLmtleXMsXG4gICAgICByZWNvcmRzOiB0aGlzLnJlY29yZHNcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gY3JlYXRlSW5kZXgoXG4gIGtleXMsXG4gIGRvY3MsXG4gIHsgZ2V0Rm4gPSBDb25maWcuZ2V0Rm4sIGZpZWxkTm9ybVdlaWdodCA9IENvbmZpZy5maWVsZE5vcm1XZWlnaHQgfSA9IHt9XG4pIHtcbiAgY29uc3QgbXlJbmRleCA9IG5ldyBGdXNlSW5kZXgoeyBnZXRGbiwgZmllbGROb3JtV2VpZ2h0IH0pO1xuICBteUluZGV4LnNldEtleXMoa2V5cy5tYXAoY3JlYXRlS2V5KSk7XG4gIG15SW5kZXguc2V0U291cmNlcyhkb2NzKTtcbiAgbXlJbmRleC5jcmVhdGUoKTtcbiAgcmV0dXJuIG15SW5kZXhcbn1cblxuZnVuY3Rpb24gcGFyc2VJbmRleChcbiAgZGF0YSxcbiAgeyBnZXRGbiA9IENvbmZpZy5nZXRGbiwgZmllbGROb3JtV2VpZ2h0ID0gQ29uZmlnLmZpZWxkTm9ybVdlaWdodCB9ID0ge31cbikge1xuICBjb25zdCB7IGtleXMsIHJlY29yZHMgfSA9IGRhdGE7XG4gIGNvbnN0IG15SW5kZXggPSBuZXcgRnVzZUluZGV4KHsgZ2V0Rm4sIGZpZWxkTm9ybVdlaWdodCB9KTtcbiAgbXlJbmRleC5zZXRLZXlzKGtleXMpO1xuICBteUluZGV4LnNldEluZGV4UmVjb3JkcyhyZWNvcmRzKTtcbiAgcmV0dXJuIG15SW5kZXhcbn1cblxuZnVuY3Rpb24gY29tcHV0ZVNjb3JlJDEoXG4gIHBhdHRlcm4sXG4gIHtcbiAgICBlcnJvcnMgPSAwLFxuICAgIGN1cnJlbnRMb2NhdGlvbiA9IDAsXG4gICAgZXhwZWN0ZWRMb2NhdGlvbiA9IDAsXG4gICAgZGlzdGFuY2UgPSBDb25maWcuZGlzdGFuY2UsXG4gICAgaWdub3JlTG9jYXRpb24gPSBDb25maWcuaWdub3JlTG9jYXRpb25cbiAgfSA9IHt9XG4pIHtcbiAgY29uc3QgYWNjdXJhY3kgPSBlcnJvcnMgLyBwYXR0ZXJuLmxlbmd0aDtcblxuICBpZiAoaWdub3JlTG9jYXRpb24pIHtcbiAgICByZXR1cm4gYWNjdXJhY3lcbiAgfVxuXG4gIGNvbnN0IHByb3hpbWl0eSA9IE1hdGguYWJzKGV4cGVjdGVkTG9jYXRpb24gLSBjdXJyZW50TG9jYXRpb24pO1xuXG4gIGlmICghZGlzdGFuY2UpIHtcbiAgICAvLyBEb2RnZSBkaXZpZGUgYnkgemVybyBlcnJvci5cbiAgICByZXR1cm4gcHJveGltaXR5ID8gMS4wIDogYWNjdXJhY3lcbiAgfVxuXG4gIHJldHVybiBhY2N1cmFjeSArIHByb3hpbWl0eSAvIGRpc3RhbmNlXG59XG5cbmZ1bmN0aW9uIGNvbnZlcnRNYXNrVG9JbmRpY2VzKFxuICBtYXRjaG1hc2sgPSBbXSxcbiAgbWluTWF0Y2hDaGFyTGVuZ3RoID0gQ29uZmlnLm1pbk1hdGNoQ2hhckxlbmd0aFxuKSB7XG4gIGxldCBpbmRpY2VzID0gW107XG4gIGxldCBzdGFydCA9IC0xO1xuICBsZXQgZW5kID0gLTE7XG4gIGxldCBpID0gMDtcblxuICBmb3IgKGxldCBsZW4gPSBtYXRjaG1hc2subGVuZ3RoOyBpIDwgbGVuOyBpICs9IDEpIHtcbiAgICBsZXQgbWF0Y2ggPSBtYXRjaG1hc2tbaV07XG4gICAgaWYgKG1hdGNoICYmIHN0YXJ0ID09PSAtMSkge1xuICAgICAgc3RhcnQgPSBpO1xuICAgIH0gZWxzZSBpZiAoIW1hdGNoICYmIHN0YXJ0ICE9PSAtMSkge1xuICAgICAgZW5kID0gaSAtIDE7XG4gICAgICBpZiAoZW5kIC0gc3RhcnQgKyAxID49IG1pbk1hdGNoQ2hhckxlbmd0aCkge1xuICAgICAgICBpbmRpY2VzLnB1c2goW3N0YXJ0LCBlbmRdKTtcbiAgICAgIH1cbiAgICAgIHN0YXJ0ID0gLTE7XG4gICAgfVxuICB9XG5cbiAgLy8gKGktMSAtIHN0YXJ0KSArIDEgPT4gaSAtIHN0YXJ0XG4gIGlmIChtYXRjaG1hc2tbaSAtIDFdICYmIGkgLSBzdGFydCA+PSBtaW5NYXRjaENoYXJMZW5ndGgpIHtcbiAgICBpbmRpY2VzLnB1c2goW3N0YXJ0LCBpIC0gMV0pO1xuICB9XG5cbiAgcmV0dXJuIGluZGljZXNcbn1cblxuLy8gTWFjaGluZSB3b3JkIHNpemVcbmNvbnN0IE1BWF9CSVRTID0gMzI7XG5cbmZ1bmN0aW9uIHNlYXJjaChcbiAgdGV4dCxcbiAgcGF0dGVybixcbiAgcGF0dGVybkFscGhhYmV0LFxuICB7XG4gICAgbG9jYXRpb24gPSBDb25maWcubG9jYXRpb24sXG4gICAgZGlzdGFuY2UgPSBDb25maWcuZGlzdGFuY2UsXG4gICAgdGhyZXNob2xkID0gQ29uZmlnLnRocmVzaG9sZCxcbiAgICBmaW5kQWxsTWF0Y2hlcyA9IENvbmZpZy5maW5kQWxsTWF0Y2hlcyxcbiAgICBtaW5NYXRjaENoYXJMZW5ndGggPSBDb25maWcubWluTWF0Y2hDaGFyTGVuZ3RoLFxuICAgIGluY2x1ZGVNYXRjaGVzID0gQ29uZmlnLmluY2x1ZGVNYXRjaGVzLFxuICAgIGlnbm9yZUxvY2F0aW9uID0gQ29uZmlnLmlnbm9yZUxvY2F0aW9uXG4gIH0gPSB7fVxuKSB7XG4gIGlmIChwYXR0ZXJuLmxlbmd0aCA+IE1BWF9CSVRTKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFBBVFRFUk5fTEVOR1RIX1RPT19MQVJHRShNQVhfQklUUykpXG4gIH1cblxuICBjb25zdCBwYXR0ZXJuTGVuID0gcGF0dGVybi5sZW5ndGg7XG4gIC8vIFNldCBzdGFydGluZyBsb2NhdGlvbiBhdCBiZWdpbm5pbmcgdGV4dCBhbmQgaW5pdGlhbGl6ZSB0aGUgYWxwaGFiZXQuXG4gIGNvbnN0IHRleHRMZW4gPSB0ZXh0Lmxlbmd0aDtcbiAgLy8gSGFuZGxlIHRoZSBjYXNlIHdoZW4gbG9jYXRpb24gPiB0ZXh0Lmxlbmd0aFxuICBjb25zdCBleHBlY3RlZExvY2F0aW9uID0gTWF0aC5tYXgoMCwgTWF0aC5taW4obG9jYXRpb24sIHRleHRMZW4pKTtcbiAgLy8gSGlnaGVzdCBzY29yZSBiZXlvbmQgd2hpY2ggd2UgZ2l2ZSB1cC5cbiAgbGV0IGN1cnJlbnRUaHJlc2hvbGQgPSB0aHJlc2hvbGQ7XG4gIC8vIElzIHRoZXJlIGEgbmVhcmJ5IGV4YWN0IG1hdGNoPyAoc3BlZWR1cClcbiAgbGV0IGJlc3RMb2NhdGlvbiA9IGV4cGVjdGVkTG9jYXRpb247XG5cbiAgLy8gUGVyZm9ybWFuY2U6IG9ubHkgY29tcHV0ZXIgbWF0Y2hlcyB3aGVuIHRoZSBtaW5NYXRjaENoYXJMZW5ndGggPiAxXG4gIC8vIE9SIGlmIGBpbmNsdWRlTWF0Y2hlc2AgaXMgdHJ1ZS5cbiAgY29uc3QgY29tcHV0ZU1hdGNoZXMgPSBtaW5NYXRjaENoYXJMZW5ndGggPiAxIHx8IGluY2x1ZGVNYXRjaGVzO1xuICAvLyBBIG1hc2sgb2YgdGhlIG1hdGNoZXMsIHVzZWQgZm9yIGJ1aWxkaW5nIHRoZSBpbmRpY2VzXG4gIGNvbnN0IG1hdGNoTWFzayA9IGNvbXB1dGVNYXRjaGVzID8gQXJyYXkodGV4dExlbikgOiBbXTtcblxuICBsZXQgaW5kZXg7XG5cbiAgLy8gR2V0IGFsbCBleGFjdCBtYXRjaGVzLCBoZXJlIGZvciBzcGVlZCB1cFxuICB3aGlsZSAoKGluZGV4ID0gdGV4dC5pbmRleE9mKHBhdHRlcm4sIGJlc3RMb2NhdGlvbikpID4gLTEpIHtcbiAgICBsZXQgc2NvcmUgPSBjb21wdXRlU2NvcmUkMShwYXR0ZXJuLCB7XG4gICAgICBjdXJyZW50TG9jYXRpb246IGluZGV4LFxuICAgICAgZXhwZWN0ZWRMb2NhdGlvbixcbiAgICAgIGRpc3RhbmNlLFxuICAgICAgaWdub3JlTG9jYXRpb25cbiAgICB9KTtcblxuICAgIGN1cnJlbnRUaHJlc2hvbGQgPSBNYXRoLm1pbihzY29yZSwgY3VycmVudFRocmVzaG9sZCk7XG4gICAgYmVzdExvY2F0aW9uID0gaW5kZXggKyBwYXR0ZXJuTGVuO1xuXG4gICAgaWYgKGNvbXB1dGVNYXRjaGVzKSB7XG4gICAgICBsZXQgaSA9IDA7XG4gICAgICB3aGlsZSAoaSA8IHBhdHRlcm5MZW4pIHtcbiAgICAgICAgbWF0Y2hNYXNrW2luZGV4ICsgaV0gPSAxO1xuICAgICAgICBpICs9IDE7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgLy8gUmVzZXQgdGhlIGJlc3QgbG9jYXRpb25cbiAgYmVzdExvY2F0aW9uID0gLTE7XG5cbiAgbGV0IGxhc3RCaXRBcnIgPSBbXTtcbiAgbGV0IGZpbmFsU2NvcmUgPSAxO1xuICBsZXQgYmluTWF4ID0gcGF0dGVybkxlbiArIHRleHRMZW47XG5cbiAgY29uc3QgbWFzayA9IDEgPDwgKHBhdHRlcm5MZW4gLSAxKTtcblxuICBmb3IgKGxldCBpID0gMDsgaSA8IHBhdHRlcm5MZW47IGkgKz0gMSkge1xuICAgIC8vIFNjYW4gZm9yIHRoZSBiZXN0IG1hdGNoOyBlYWNoIGl0ZXJhdGlvbiBhbGxvd3MgZm9yIG9uZSBtb3JlIGVycm9yLlxuICAgIC8vIFJ1biBhIGJpbmFyeSBzZWFyY2ggdG8gZGV0ZXJtaW5lIGhvdyBmYXIgZnJvbSB0aGUgbWF0Y2ggbG9jYXRpb24gd2UgY2FuIHN0cmF5XG4gICAgLy8gYXQgdGhpcyBlcnJvciBsZXZlbC5cbiAgICBsZXQgYmluTWluID0gMDtcbiAgICBsZXQgYmluTWlkID0gYmluTWF4O1xuXG4gICAgd2hpbGUgKGJpbk1pbiA8IGJpbk1pZCkge1xuICAgICAgY29uc3Qgc2NvcmUgPSBjb21wdXRlU2NvcmUkMShwYXR0ZXJuLCB7XG4gICAgICAgIGVycm9yczogaSxcbiAgICAgICAgY3VycmVudExvY2F0aW9uOiBleHBlY3RlZExvY2F0aW9uICsgYmluTWlkLFxuICAgICAgICBleHBlY3RlZExvY2F0aW9uLFxuICAgICAgICBkaXN0YW5jZSxcbiAgICAgICAgaWdub3JlTG9jYXRpb25cbiAgICAgIH0pO1xuXG4gICAgICBpZiAoc2NvcmUgPD0gY3VycmVudFRocmVzaG9sZCkge1xuICAgICAgICBiaW5NaW4gPSBiaW5NaWQ7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBiaW5NYXggPSBiaW5NaWQ7XG4gICAgICB9XG5cbiAgICAgIGJpbk1pZCA9IE1hdGguZmxvb3IoKGJpbk1heCAtIGJpbk1pbikgLyAyICsgYmluTWluKTtcbiAgICB9XG5cbiAgICAvLyBVc2UgdGhlIHJlc3VsdCBmcm9tIHRoaXMgaXRlcmF0aW9uIGFzIHRoZSBtYXhpbXVtIGZvciB0aGUgbmV4dC5cbiAgICBiaW5NYXggPSBiaW5NaWQ7XG5cbiAgICBsZXQgc3RhcnQgPSBNYXRoLm1heCgxLCBleHBlY3RlZExvY2F0aW9uIC0gYmluTWlkICsgMSk7XG4gICAgbGV0IGZpbmlzaCA9IGZpbmRBbGxNYXRjaGVzXG4gICAgICA/IHRleHRMZW5cbiAgICAgIDogTWF0aC5taW4oZXhwZWN0ZWRMb2NhdGlvbiArIGJpbk1pZCwgdGV4dExlbikgKyBwYXR0ZXJuTGVuO1xuXG4gICAgLy8gSW5pdGlhbGl6ZSB0aGUgYml0IGFycmF5XG4gICAgbGV0IGJpdEFyciA9IEFycmF5KGZpbmlzaCArIDIpO1xuXG4gICAgYml0QXJyW2ZpbmlzaCArIDFdID0gKDEgPDwgaSkgLSAxO1xuXG4gICAgZm9yIChsZXQgaiA9IGZpbmlzaDsgaiA+PSBzdGFydDsgaiAtPSAxKSB7XG4gICAgICBsZXQgY3VycmVudExvY2F0aW9uID0gaiAtIDE7XG4gICAgICBsZXQgY2hhck1hdGNoID0gcGF0dGVybkFscGhhYmV0W3RleHQuY2hhckF0KGN1cnJlbnRMb2NhdGlvbildO1xuXG4gICAgICBpZiAoY29tcHV0ZU1hdGNoZXMpIHtcbiAgICAgICAgLy8gU3BlZWQgdXA6IHF1aWNrIGJvb2wgdG8gaW50IGNvbnZlcnNpb24gKGkuZSwgYGNoYXJNYXRjaCA/IDEgOiAwYClcbiAgICAgICAgbWF0Y2hNYXNrW2N1cnJlbnRMb2NhdGlvbl0gPSArISFjaGFyTWF0Y2g7XG4gICAgICB9XG5cbiAgICAgIC8vIEZpcnN0IHBhc3M6IGV4YWN0IG1hdGNoXG4gICAgICBiaXRBcnJbal0gPSAoKGJpdEFycltqICsgMV0gPDwgMSkgfCAxKSAmIGNoYXJNYXRjaDtcblxuICAgICAgLy8gU3Vic2VxdWVudCBwYXNzZXM6IGZ1enp5IG1hdGNoXG4gICAgICBpZiAoaSkge1xuICAgICAgICBiaXRBcnJbal0gfD1cbiAgICAgICAgICAoKGxhc3RCaXRBcnJbaiArIDFdIHwgbGFzdEJpdEFycltqXSkgPDwgMSkgfCAxIHwgbGFzdEJpdEFycltqICsgMV07XG4gICAgICB9XG5cbiAgICAgIGlmIChiaXRBcnJbal0gJiBtYXNrKSB7XG4gICAgICAgIGZpbmFsU2NvcmUgPSBjb21wdXRlU2NvcmUkMShwYXR0ZXJuLCB7XG4gICAgICAgICAgZXJyb3JzOiBpLFxuICAgICAgICAgIGN1cnJlbnRMb2NhdGlvbixcbiAgICAgICAgICBleHBlY3RlZExvY2F0aW9uLFxuICAgICAgICAgIGRpc3RhbmNlLFxuICAgICAgICAgIGlnbm9yZUxvY2F0aW9uXG4gICAgICAgIH0pO1xuXG4gICAgICAgIC8vIFRoaXMgbWF0Y2ggd2lsbCBhbG1vc3QgY2VydGFpbmx5IGJlIGJldHRlciB0aGFuIGFueSBleGlzdGluZyBtYXRjaC5cbiAgICAgICAgLy8gQnV0IGNoZWNrIGFueXdheS5cbiAgICAgICAgaWYgKGZpbmFsU2NvcmUgPD0gY3VycmVudFRocmVzaG9sZCkge1xuICAgICAgICAgIC8vIEluZGVlZCBpdCBpc1xuICAgICAgICAgIGN1cnJlbnRUaHJlc2hvbGQgPSBmaW5hbFNjb3JlO1xuICAgICAgICAgIGJlc3RMb2NhdGlvbiA9IGN1cnJlbnRMb2NhdGlvbjtcblxuICAgICAgICAgIC8vIEFscmVhZHkgcGFzc2VkIGBsb2NgLCBkb3duaGlsbCBmcm9tIGhlcmUgb24gaW4uXG4gICAgICAgICAgaWYgKGJlc3RMb2NhdGlvbiA8PSBleHBlY3RlZExvY2F0aW9uKSB7XG4gICAgICAgICAgICBicmVha1xuICAgICAgICAgIH1cblxuICAgICAgICAgIC8vIFdoZW4gcGFzc2luZyBgYmVzdExvY2F0aW9uYCwgZG9uJ3QgZXhjZWVkIG91ciBjdXJyZW50IGRpc3RhbmNlIGZyb20gYGV4cGVjdGVkTG9jYXRpb25gLlxuICAgICAgICAgIHN0YXJ0ID0gTWF0aC5tYXgoMSwgMiAqIGV4cGVjdGVkTG9jYXRpb24gLSBiZXN0TG9jYXRpb24pO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gTm8gaG9wZSBmb3IgYSAoYmV0dGVyKSBtYXRjaCBhdCBncmVhdGVyIGVycm9yIGxldmVscy5cbiAgICBjb25zdCBzY29yZSA9IGNvbXB1dGVTY29yZSQxKHBhdHRlcm4sIHtcbiAgICAgIGVycm9yczogaSArIDEsXG4gICAgICBjdXJyZW50TG9jYXRpb246IGV4cGVjdGVkTG9jYXRpb24sXG4gICAgICBleHBlY3RlZExvY2F0aW9uLFxuICAgICAgZGlzdGFuY2UsXG4gICAgICBpZ25vcmVMb2NhdGlvblxuICAgIH0pO1xuXG4gICAgaWYgKHNjb3JlID4gY3VycmVudFRocmVzaG9sZCkge1xuICAgICAgYnJlYWtcbiAgICB9XG5cbiAgICBsYXN0Qml0QXJyID0gYml0QXJyO1xuICB9XG5cbiAgY29uc3QgcmVzdWx0ID0ge1xuICAgIGlzTWF0Y2g6IGJlc3RMb2NhdGlvbiA+PSAwLFxuICAgIC8vIENvdW50IGV4YWN0IG1hdGNoZXMgKHRob3NlIHdpdGggYSBzY29yZSBvZiAwKSB0byBiZSBcImFsbW9zdFwiIGV4YWN0XG4gICAgc2NvcmU6IE1hdGgubWF4KDAuMDAxLCBmaW5hbFNjb3JlKVxuICB9O1xuXG4gIGlmIChjb21wdXRlTWF0Y2hlcykge1xuICAgIGNvbnN0IGluZGljZXMgPSBjb252ZXJ0TWFza1RvSW5kaWNlcyhtYXRjaE1hc2ssIG1pbk1hdGNoQ2hhckxlbmd0aCk7XG4gICAgaWYgKCFpbmRpY2VzLmxlbmd0aCkge1xuICAgICAgcmVzdWx0LmlzTWF0Y2ggPSBmYWxzZTtcbiAgICB9IGVsc2UgaWYgKGluY2x1ZGVNYXRjaGVzKSB7XG4gICAgICByZXN1bHQuaW5kaWNlcyA9IGluZGljZXM7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHJlc3VsdFxufVxuXG5mdW5jdGlvbiBjcmVhdGVQYXR0ZXJuQWxwaGFiZXQocGF0dGVybikge1xuICBsZXQgbWFzayA9IHt9O1xuXG4gIGZvciAobGV0IGkgPSAwLCBsZW4gPSBwYXR0ZXJuLmxlbmd0aDsgaSA8IGxlbjsgaSArPSAxKSB7XG4gICAgY29uc3QgY2hhciA9IHBhdHRlcm4uY2hhckF0KGkpO1xuICAgIG1hc2tbY2hhcl0gPSAobWFza1tjaGFyXSB8fCAwKSB8ICgxIDw8IChsZW4gLSBpIC0gMSkpO1xuICB9XG5cbiAgcmV0dXJuIG1hc2tcbn1cblxuY2xhc3MgQml0YXBTZWFyY2gge1xuICBjb25zdHJ1Y3RvcihcbiAgICBwYXR0ZXJuLFxuICAgIHtcbiAgICAgIGxvY2F0aW9uID0gQ29uZmlnLmxvY2F0aW9uLFxuICAgICAgdGhyZXNob2xkID0gQ29uZmlnLnRocmVzaG9sZCxcbiAgICAgIGRpc3RhbmNlID0gQ29uZmlnLmRpc3RhbmNlLFxuICAgICAgaW5jbHVkZU1hdGNoZXMgPSBDb25maWcuaW5jbHVkZU1hdGNoZXMsXG4gICAgICBmaW5kQWxsTWF0Y2hlcyA9IENvbmZpZy5maW5kQWxsTWF0Y2hlcyxcbiAgICAgIG1pbk1hdGNoQ2hhckxlbmd0aCA9IENvbmZpZy5taW5NYXRjaENoYXJMZW5ndGgsXG4gICAgICBpc0Nhc2VTZW5zaXRpdmUgPSBDb25maWcuaXNDYXNlU2Vuc2l0aXZlLFxuICAgICAgaWdub3JlTG9jYXRpb24gPSBDb25maWcuaWdub3JlTG9jYXRpb25cbiAgICB9ID0ge31cbiAgKSB7XG4gICAgdGhpcy5vcHRpb25zID0ge1xuICAgICAgbG9jYXRpb24sXG4gICAgICB0aHJlc2hvbGQsXG4gICAgICBkaXN0YW5jZSxcbiAgICAgIGluY2x1ZGVNYXRjaGVzLFxuICAgICAgZmluZEFsbE1hdGNoZXMsXG4gICAgICBtaW5NYXRjaENoYXJMZW5ndGgsXG4gICAgICBpc0Nhc2VTZW5zaXRpdmUsXG4gICAgICBpZ25vcmVMb2NhdGlvblxuICAgIH07XG5cbiAgICB0aGlzLnBhdHRlcm4gPSBpc0Nhc2VTZW5zaXRpdmUgPyBwYXR0ZXJuIDogcGF0dGVybi50b0xvd2VyQ2FzZSgpO1xuXG4gICAgdGhpcy5jaHVua3MgPSBbXTtcblxuICAgIGlmICghdGhpcy5wYXR0ZXJuLmxlbmd0aCkge1xuICAgICAgcmV0dXJuXG4gICAgfVxuXG4gICAgY29uc3QgYWRkQ2h1bmsgPSAocGF0dGVybiwgc3RhcnRJbmRleCkgPT4ge1xuICAgICAgdGhpcy5jaHVua3MucHVzaCh7XG4gICAgICAgIHBhdHRlcm4sXG4gICAgICAgIGFscGhhYmV0OiBjcmVhdGVQYXR0ZXJuQWxwaGFiZXQocGF0dGVybiksXG4gICAgICAgIHN0YXJ0SW5kZXhcbiAgICAgIH0pO1xuICAgIH07XG5cbiAgICBjb25zdCBsZW4gPSB0aGlzLnBhdHRlcm4ubGVuZ3RoO1xuXG4gICAgaWYgKGxlbiA+IE1BWF9CSVRTKSB7XG4gICAgICBsZXQgaSA9IDA7XG4gICAgICBjb25zdCByZW1haW5kZXIgPSBsZW4gJSBNQVhfQklUUztcbiAgICAgIGNvbnN0IGVuZCA9IGxlbiAtIHJlbWFpbmRlcjtcblxuICAgICAgd2hpbGUgKGkgPCBlbmQpIHtcbiAgICAgICAgYWRkQ2h1bmsodGhpcy5wYXR0ZXJuLnN1YnN0cihpLCBNQVhfQklUUyksIGkpO1xuICAgICAgICBpICs9IE1BWF9CSVRTO1xuICAgICAgfVxuXG4gICAgICBpZiAocmVtYWluZGVyKSB7XG4gICAgICAgIGNvbnN0IHN0YXJ0SW5kZXggPSBsZW4gLSBNQVhfQklUUztcbiAgICAgICAgYWRkQ2h1bmsodGhpcy5wYXR0ZXJuLnN1YnN0cihzdGFydEluZGV4KSwgc3RhcnRJbmRleCk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGFkZENodW5rKHRoaXMucGF0dGVybiwgMCk7XG4gICAgfVxuICB9XG5cbiAgc2VhcmNoSW4odGV4dCkge1xuICAgIGNvbnN0IHsgaXNDYXNlU2Vuc2l0aXZlLCBpbmNsdWRlTWF0Y2hlcyB9ID0gdGhpcy5vcHRpb25zO1xuXG4gICAgaWYgKCFpc0Nhc2VTZW5zaXRpdmUpIHtcbiAgICAgIHRleHQgPSB0ZXh0LnRvTG93ZXJDYXNlKCk7XG4gICAgfVxuXG4gICAgLy8gRXhhY3QgbWF0Y2hcbiAgICBpZiAodGhpcy5wYXR0ZXJuID09PSB0ZXh0KSB7XG4gICAgICBsZXQgcmVzdWx0ID0ge1xuICAgICAgICBpc01hdGNoOiB0cnVlLFxuICAgICAgICBzY29yZTogMFxuICAgICAgfTtcblxuICAgICAgaWYgKGluY2x1ZGVNYXRjaGVzKSB7XG4gICAgICAgIHJlc3VsdC5pbmRpY2VzID0gW1swLCB0ZXh0Lmxlbmd0aCAtIDFdXTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHJlc3VsdFxuICAgIH1cblxuICAgIC8vIE90aGVyd2lzZSwgdXNlIEJpdGFwIGFsZ29yaXRobVxuICAgIGNvbnN0IHtcbiAgICAgIGxvY2F0aW9uLFxuICAgICAgZGlzdGFuY2UsXG4gICAgICB0aHJlc2hvbGQsXG4gICAgICBmaW5kQWxsTWF0Y2hlcyxcbiAgICAgIG1pbk1hdGNoQ2hhckxlbmd0aCxcbiAgICAgIGlnbm9yZUxvY2F0aW9uXG4gICAgfSA9IHRoaXMub3B0aW9ucztcblxuICAgIGxldCBhbGxJbmRpY2VzID0gW107XG4gICAgbGV0IHRvdGFsU2NvcmUgPSAwO1xuICAgIGxldCBoYXNNYXRjaGVzID0gZmFsc2U7XG5cbiAgICB0aGlzLmNodW5rcy5mb3JFYWNoKCh7IHBhdHRlcm4sIGFscGhhYmV0LCBzdGFydEluZGV4IH0pID0+IHtcbiAgICAgIGNvbnN0IHsgaXNNYXRjaCwgc2NvcmUsIGluZGljZXMgfSA9IHNlYXJjaCh0ZXh0LCBwYXR0ZXJuLCBhbHBoYWJldCwge1xuICAgICAgICBsb2NhdGlvbjogbG9jYXRpb24gKyBzdGFydEluZGV4LFxuICAgICAgICBkaXN0YW5jZSxcbiAgICAgICAgdGhyZXNob2xkLFxuICAgICAgICBmaW5kQWxsTWF0Y2hlcyxcbiAgICAgICAgbWluTWF0Y2hDaGFyTGVuZ3RoLFxuICAgICAgICBpbmNsdWRlTWF0Y2hlcyxcbiAgICAgICAgaWdub3JlTG9jYXRpb25cbiAgICAgIH0pO1xuXG4gICAgICBpZiAoaXNNYXRjaCkge1xuICAgICAgICBoYXNNYXRjaGVzID0gdHJ1ZTtcbiAgICAgIH1cblxuICAgICAgdG90YWxTY29yZSArPSBzY29yZTtcblxuICAgICAgaWYgKGlzTWF0Y2ggJiYgaW5kaWNlcykge1xuICAgICAgICBhbGxJbmRpY2VzID0gWy4uLmFsbEluZGljZXMsIC4uLmluZGljZXNdO1xuICAgICAgfVxuICAgIH0pO1xuXG4gICAgbGV0IHJlc3VsdCA9IHtcbiAgICAgIGlzTWF0Y2g6IGhhc01hdGNoZXMsXG4gICAgICBzY29yZTogaGFzTWF0Y2hlcyA/IHRvdGFsU2NvcmUgLyB0aGlzLmNodW5rcy5sZW5ndGggOiAxXG4gICAgfTtcblxuICAgIGlmIChoYXNNYXRjaGVzICYmIGluY2x1ZGVNYXRjaGVzKSB7XG4gICAgICByZXN1bHQuaW5kaWNlcyA9IGFsbEluZGljZXM7XG4gICAgfVxuXG4gICAgcmV0dXJuIHJlc3VsdFxuICB9XG59XG5cbmNsYXNzIEJhc2VNYXRjaCB7XG4gIGNvbnN0cnVjdG9yKHBhdHRlcm4pIHtcbiAgICB0aGlzLnBhdHRlcm4gPSBwYXR0ZXJuO1xuICB9XG4gIHN0YXRpYyBpc011bHRpTWF0Y2gocGF0dGVybikge1xuICAgIHJldHVybiBnZXRNYXRjaChwYXR0ZXJuLCB0aGlzLm11bHRpUmVnZXgpXG4gIH1cbiAgc3RhdGljIGlzU2luZ2xlTWF0Y2gocGF0dGVybikge1xuICAgIHJldHVybiBnZXRNYXRjaChwYXR0ZXJuLCB0aGlzLnNpbmdsZVJlZ2V4KVxuICB9XG4gIHNlYXJjaCgvKnRleHQqLykge31cbn1cblxuZnVuY3Rpb24gZ2V0TWF0Y2gocGF0dGVybiwgZXhwKSB7XG4gIGNvbnN0IG1hdGNoZXMgPSBwYXR0ZXJuLm1hdGNoKGV4cCk7XG4gIHJldHVybiBtYXRjaGVzID8gbWF0Y2hlc1sxXSA6IG51bGxcbn1cblxuLy8gVG9rZW46ICdmaWxlXG5cbmNsYXNzIEV4YWN0TWF0Y2ggZXh0ZW5kcyBCYXNlTWF0Y2gge1xuICBjb25zdHJ1Y3RvcihwYXR0ZXJuKSB7XG4gICAgc3VwZXIocGF0dGVybik7XG4gIH1cbiAgc3RhdGljIGdldCB0eXBlKCkge1xuICAgIHJldHVybiAnZXhhY3QnXG4gIH1cbiAgc3RhdGljIGdldCBtdWx0aVJlZ2V4KCkge1xuICAgIHJldHVybiAvXj1cIiguKilcIiQvXG4gIH1cbiAgc3RhdGljIGdldCBzaW5nbGVSZWdleCgpIHtcbiAgICByZXR1cm4gL149KC4qKSQvXG4gIH1cbiAgc2VhcmNoKHRleHQpIHtcbiAgICBjb25zdCBpc01hdGNoID0gdGV4dCA9PT0gdGhpcy5wYXR0ZXJuO1xuXG4gICAgcmV0dXJuIHtcbiAgICAgIGlzTWF0Y2gsXG4gICAgICBzY29yZTogaXNNYXRjaCA/IDAgOiAxLFxuICAgICAgaW5kaWNlczogWzAsIHRoaXMucGF0dGVybi5sZW5ndGggLSAxXVxuICAgIH1cbiAgfVxufVxuXG4vLyBUb2tlbjogIWZpcmVcblxuY2xhc3MgSW52ZXJzZUV4YWN0TWF0Y2ggZXh0ZW5kcyBCYXNlTWF0Y2gge1xuICBjb25zdHJ1Y3RvcihwYXR0ZXJuKSB7XG4gICAgc3VwZXIocGF0dGVybik7XG4gIH1cbiAgc3RhdGljIGdldCB0eXBlKCkge1xuICAgIHJldHVybiAnaW52ZXJzZS1leGFjdCdcbiAgfVxuICBzdGF0aWMgZ2V0IG11bHRpUmVnZXgoKSB7XG4gICAgcmV0dXJuIC9eIVwiKC4qKVwiJC9cbiAgfVxuICBzdGF0aWMgZ2V0IHNpbmdsZVJlZ2V4KCkge1xuICAgIHJldHVybiAvXiEoLiopJC9cbiAgfVxuICBzZWFyY2godGV4dCkge1xuICAgIGNvbnN0IGluZGV4ID0gdGV4dC5pbmRleE9mKHRoaXMucGF0dGVybik7XG4gICAgY29uc3QgaXNNYXRjaCA9IGluZGV4ID09PSAtMTtcblxuICAgIHJldHVybiB7XG4gICAgICBpc01hdGNoLFxuICAgICAgc2NvcmU6IGlzTWF0Y2ggPyAwIDogMSxcbiAgICAgIGluZGljZXM6IFswLCB0ZXh0Lmxlbmd0aCAtIDFdXG4gICAgfVxuICB9XG59XG5cbi8vIFRva2VuOiBeZmlsZVxuXG5jbGFzcyBQcmVmaXhFeGFjdE1hdGNoIGV4dGVuZHMgQmFzZU1hdGNoIHtcbiAgY29uc3RydWN0b3IocGF0dGVybikge1xuICAgIHN1cGVyKHBhdHRlcm4pO1xuICB9XG4gIHN0YXRpYyBnZXQgdHlwZSgpIHtcbiAgICByZXR1cm4gJ3ByZWZpeC1leGFjdCdcbiAgfVxuICBzdGF0aWMgZ2V0IG11bHRpUmVnZXgoKSB7XG4gICAgcmV0dXJuIC9eXFxeXCIoLiopXCIkL1xuICB9XG4gIHN0YXRpYyBnZXQgc2luZ2xlUmVnZXgoKSB7XG4gICAgcmV0dXJuIC9eXFxeKC4qKSQvXG4gIH1cbiAgc2VhcmNoKHRleHQpIHtcbiAgICBjb25zdCBpc01hdGNoID0gdGV4dC5zdGFydHNXaXRoKHRoaXMucGF0dGVybik7XG5cbiAgICByZXR1cm4ge1xuICAgICAgaXNNYXRjaCxcbiAgICAgIHNjb3JlOiBpc01hdGNoID8gMCA6IDEsXG4gICAgICBpbmRpY2VzOiBbMCwgdGhpcy5wYXR0ZXJuLmxlbmd0aCAtIDFdXG4gICAgfVxuICB9XG59XG5cbi8vIFRva2VuOiAhXmZpcmVcblxuY2xhc3MgSW52ZXJzZVByZWZpeEV4YWN0TWF0Y2ggZXh0ZW5kcyBCYXNlTWF0Y2gge1xuICBjb25zdHJ1Y3RvcihwYXR0ZXJuKSB7XG4gICAgc3VwZXIocGF0dGVybik7XG4gIH1cbiAgc3RhdGljIGdldCB0eXBlKCkge1xuICAgIHJldHVybiAnaW52ZXJzZS1wcmVmaXgtZXhhY3QnXG4gIH1cbiAgc3RhdGljIGdldCBtdWx0aVJlZ2V4KCkge1xuICAgIHJldHVybiAvXiFcXF5cIiguKilcIiQvXG4gIH1cbiAgc3RhdGljIGdldCBzaW5nbGVSZWdleCgpIHtcbiAgICByZXR1cm4gL14hXFxeKC4qKSQvXG4gIH1cbiAgc2VhcmNoKHRleHQpIHtcbiAgICBjb25zdCBpc01hdGNoID0gIXRleHQuc3RhcnRzV2l0aCh0aGlzLnBhdHRlcm4pO1xuXG4gICAgcmV0dXJuIHtcbiAgICAgIGlzTWF0Y2gsXG4gICAgICBzY29yZTogaXNNYXRjaCA/IDAgOiAxLFxuICAgICAgaW5kaWNlczogWzAsIHRleHQubGVuZ3RoIC0gMV1cbiAgICB9XG4gIH1cbn1cblxuLy8gVG9rZW46IC5maWxlJFxuXG5jbGFzcyBTdWZmaXhFeGFjdE1hdGNoIGV4dGVuZHMgQmFzZU1hdGNoIHtcbiAgY29uc3RydWN0b3IocGF0dGVybikge1xuICAgIHN1cGVyKHBhdHRlcm4pO1xuICB9XG4gIHN0YXRpYyBnZXQgdHlwZSgpIHtcbiAgICByZXR1cm4gJ3N1ZmZpeC1leGFjdCdcbiAgfVxuICBzdGF0aWMgZ2V0IG11bHRpUmVnZXgoKSB7XG4gICAgcmV0dXJuIC9eXCIoLiopXCJcXCQkL1xuICB9XG4gIHN0YXRpYyBnZXQgc2luZ2xlUmVnZXgoKSB7XG4gICAgcmV0dXJuIC9eKC4qKVxcJCQvXG4gIH1cbiAgc2VhcmNoKHRleHQpIHtcbiAgICBjb25zdCBpc01hdGNoID0gdGV4dC5lbmRzV2l0aCh0aGlzLnBhdHRlcm4pO1xuXG4gICAgcmV0dXJuIHtcbiAgICAgIGlzTWF0Y2gsXG4gICAgICBzY29yZTogaXNNYXRjaCA/IDAgOiAxLFxuICAgICAgaW5kaWNlczogW3RleHQubGVuZ3RoIC0gdGhpcy5wYXR0ZXJuLmxlbmd0aCwgdGV4dC5sZW5ndGggLSAxXVxuICAgIH1cbiAgfVxufVxuXG4vLyBUb2tlbjogIS5maWxlJFxuXG5jbGFzcyBJbnZlcnNlU3VmZml4RXhhY3RNYXRjaCBleHRlbmRzIEJhc2VNYXRjaCB7XG4gIGNvbnN0cnVjdG9yKHBhdHRlcm4pIHtcbiAgICBzdXBlcihwYXR0ZXJuKTtcbiAgfVxuICBzdGF0aWMgZ2V0IHR5cGUoKSB7XG4gICAgcmV0dXJuICdpbnZlcnNlLXN1ZmZpeC1leGFjdCdcbiAgfVxuICBzdGF0aWMgZ2V0IG11bHRpUmVnZXgoKSB7XG4gICAgcmV0dXJuIC9eIVwiKC4qKVwiXFwkJC9cbiAgfVxuICBzdGF0aWMgZ2V0IHNpbmdsZVJlZ2V4KCkge1xuICAgIHJldHVybiAvXiEoLiopXFwkJC9cbiAgfVxuICBzZWFyY2godGV4dCkge1xuICAgIGNvbnN0IGlzTWF0Y2ggPSAhdGV4dC5lbmRzV2l0aCh0aGlzLnBhdHRlcm4pO1xuICAgIHJldHVybiB7XG4gICAgICBpc01hdGNoLFxuICAgICAgc2NvcmU6IGlzTWF0Y2ggPyAwIDogMSxcbiAgICAgIGluZGljZXM6IFswLCB0ZXh0Lmxlbmd0aCAtIDFdXG4gICAgfVxuICB9XG59XG5cbmNsYXNzIEZ1enp5TWF0Y2ggZXh0ZW5kcyBCYXNlTWF0Y2gge1xuICBjb25zdHJ1Y3RvcihcbiAgICBwYXR0ZXJuLFxuICAgIHtcbiAgICAgIGxvY2F0aW9uID0gQ29uZmlnLmxvY2F0aW9uLFxuICAgICAgdGhyZXNob2xkID0gQ29uZmlnLnRocmVzaG9sZCxcbiAgICAgIGRpc3RhbmNlID0gQ29uZmlnLmRpc3RhbmNlLFxuICAgICAgaW5jbHVkZU1hdGNoZXMgPSBDb25maWcuaW5jbHVkZU1hdGNoZXMsXG4gICAgICBmaW5kQWxsTWF0Y2hlcyA9IENvbmZpZy5maW5kQWxsTWF0Y2hlcyxcbiAgICAgIG1pbk1hdGNoQ2hhckxlbmd0aCA9IENvbmZpZy5taW5NYXRjaENoYXJMZW5ndGgsXG4gICAgICBpc0Nhc2VTZW5zaXRpdmUgPSBDb25maWcuaXNDYXNlU2Vuc2l0aXZlLFxuICAgICAgaWdub3JlTG9jYXRpb24gPSBDb25maWcuaWdub3JlTG9jYXRpb25cbiAgICB9ID0ge31cbiAgKSB7XG4gICAgc3VwZXIocGF0dGVybik7XG4gICAgdGhpcy5fYml0YXBTZWFyY2ggPSBuZXcgQml0YXBTZWFyY2gocGF0dGVybiwge1xuICAgICAgbG9jYXRpb24sXG4gICAgICB0aHJlc2hvbGQsXG4gICAgICBkaXN0YW5jZSxcbiAgICAgIGluY2x1ZGVNYXRjaGVzLFxuICAgICAgZmluZEFsbE1hdGNoZXMsXG4gICAgICBtaW5NYXRjaENoYXJMZW5ndGgsXG4gICAgICBpc0Nhc2VTZW5zaXRpdmUsXG4gICAgICBpZ25vcmVMb2NhdGlvblxuICAgIH0pO1xuICB9XG4gIHN0YXRpYyBnZXQgdHlwZSgpIHtcbiAgICByZXR1cm4gJ2Z1enp5J1xuICB9XG4gIHN0YXRpYyBnZXQgbXVsdGlSZWdleCgpIHtcbiAgICByZXR1cm4gL15cIiguKilcIiQvXG4gIH1cbiAgc3RhdGljIGdldCBzaW5nbGVSZWdleCgpIHtcbiAgICByZXR1cm4gL14oLiopJC9cbiAgfVxuICBzZWFyY2godGV4dCkge1xuICAgIHJldHVybiB0aGlzLl9iaXRhcFNlYXJjaC5zZWFyY2hJbih0ZXh0KVxuICB9XG59XG5cbi8vIFRva2VuOiAnZmlsZVxuXG5jbGFzcyBJbmNsdWRlTWF0Y2ggZXh0ZW5kcyBCYXNlTWF0Y2gge1xuICBjb25zdHJ1Y3RvcihwYXR0ZXJuKSB7XG4gICAgc3VwZXIocGF0dGVybik7XG4gIH1cbiAgc3RhdGljIGdldCB0eXBlKCkge1xuICAgIHJldHVybiAnaW5jbHVkZSdcbiAgfVxuICBzdGF0aWMgZ2V0IG11bHRpUmVnZXgoKSB7XG4gICAgcmV0dXJuIC9eJ1wiKC4qKVwiJC9cbiAgfVxuICBzdGF0aWMgZ2V0IHNpbmdsZVJlZ2V4KCkge1xuICAgIHJldHVybiAvXicoLiopJC9cbiAgfVxuICBzZWFyY2godGV4dCkge1xuICAgIGxldCBsb2NhdGlvbiA9IDA7XG4gICAgbGV0IGluZGV4O1xuXG4gICAgY29uc3QgaW5kaWNlcyA9IFtdO1xuICAgIGNvbnN0IHBhdHRlcm5MZW4gPSB0aGlzLnBhdHRlcm4ubGVuZ3RoO1xuXG4gICAgLy8gR2V0IGFsbCBleGFjdCBtYXRjaGVzXG4gICAgd2hpbGUgKChpbmRleCA9IHRleHQuaW5kZXhPZih0aGlzLnBhdHRlcm4sIGxvY2F0aW9uKSkgPiAtMSkge1xuICAgICAgbG9jYXRpb24gPSBpbmRleCArIHBhdHRlcm5MZW47XG4gICAgICBpbmRpY2VzLnB1c2goW2luZGV4LCBsb2NhdGlvbiAtIDFdKTtcbiAgICB9XG5cbiAgICBjb25zdCBpc01hdGNoID0gISFpbmRpY2VzLmxlbmd0aDtcblxuICAgIHJldHVybiB7XG4gICAgICBpc01hdGNoLFxuICAgICAgc2NvcmU6IGlzTWF0Y2ggPyAwIDogMSxcbiAgICAgIGluZGljZXNcbiAgICB9XG4gIH1cbn1cblxuLy8g4p2XT3JkZXIgaXMgaW1wb3J0YW50LiBETyBOT1QgQ0hBTkdFLlxuY29uc3Qgc2VhcmNoZXJzID0gW1xuICBFeGFjdE1hdGNoLFxuICBJbmNsdWRlTWF0Y2gsXG4gIFByZWZpeEV4YWN0TWF0Y2gsXG4gIEludmVyc2VQcmVmaXhFeGFjdE1hdGNoLFxuICBJbnZlcnNlU3VmZml4RXhhY3RNYXRjaCxcbiAgU3VmZml4RXhhY3RNYXRjaCxcbiAgSW52ZXJzZUV4YWN0TWF0Y2gsXG4gIEZ1enp5TWF0Y2hcbl07XG5cbmNvbnN0IHNlYXJjaGVyc0xlbiA9IHNlYXJjaGVycy5sZW5ndGg7XG5cbi8vIFJlZ2V4IHRvIHNwbGl0IGJ5IHNwYWNlcywgYnV0IGtlZXAgYW55dGhpbmcgaW4gcXVvdGVzIHRvZ2V0aGVyXG5jb25zdCBTUEFDRV9SRSA9IC8gKyg/PSg/OlteXFxcIl0qXFxcIlteXFxcIl0qXFxcIikqW15cXFwiXSokKS87XG5jb25zdCBPUl9UT0tFTiA9ICd8JztcblxuLy8gUmV0dXJuIGEgMkQgYXJyYXkgcmVwcmVzZW50YXRpb24gb2YgdGhlIHF1ZXJ5LCBmb3Igc2ltcGxlciBwYXJzaW5nLlxuLy8gRXhhbXBsZTpcbi8vIFwiXmNvcmUgZ28kIHwgcmIkIHwgcHkkIHh5JFwiID0+IFtbXCJeY29yZVwiLCBcImdvJFwiXSwgW1wicmIkXCJdLCBbXCJweSRcIiwgXCJ4eSRcIl1dXG5mdW5jdGlvbiBwYXJzZVF1ZXJ5KHBhdHRlcm4sIG9wdGlvbnMgPSB7fSkge1xuICByZXR1cm4gcGF0dGVybi5zcGxpdChPUl9UT0tFTikubWFwKChpdGVtKSA9PiB7XG4gICAgbGV0IHF1ZXJ5ID0gaXRlbVxuICAgICAgLnRyaW0oKVxuICAgICAgLnNwbGl0KFNQQUNFX1JFKVxuICAgICAgLmZpbHRlcigoaXRlbSkgPT4gaXRlbSAmJiAhIWl0ZW0udHJpbSgpKTtcblxuICAgIGxldCByZXN1bHRzID0gW107XG4gICAgZm9yIChsZXQgaSA9IDAsIGxlbiA9IHF1ZXJ5Lmxlbmd0aDsgaSA8IGxlbjsgaSArPSAxKSB7XG4gICAgICBjb25zdCBxdWVyeUl0ZW0gPSBxdWVyeVtpXTtcblxuICAgICAgLy8gMS4gSGFuZGxlIG11bHRpcGxlIHF1ZXJ5IG1hdGNoIChpLmUsIG9uY2UgdGhhdCBhcmUgcXVvdGVkLCBsaWtlIGBcImhlbGxvIHdvcmxkXCJgKVxuICAgICAgbGV0IGZvdW5kID0gZmFsc2U7XG4gICAgICBsZXQgaWR4ID0gLTE7XG4gICAgICB3aGlsZSAoIWZvdW5kICYmICsraWR4IDwgc2VhcmNoZXJzTGVuKSB7XG4gICAgICAgIGNvbnN0IHNlYXJjaGVyID0gc2VhcmNoZXJzW2lkeF07XG4gICAgICAgIGxldCB0b2tlbiA9IHNlYXJjaGVyLmlzTXVsdGlNYXRjaChxdWVyeUl0ZW0pO1xuICAgICAgICBpZiAodG9rZW4pIHtcbiAgICAgICAgICByZXN1bHRzLnB1c2gobmV3IHNlYXJjaGVyKHRva2VuLCBvcHRpb25zKSk7XG4gICAgICAgICAgZm91bmQgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmIChmb3VuZCkge1xuICAgICAgICBjb250aW51ZVxuICAgICAgfVxuXG4gICAgICAvLyAyLiBIYW5kbGUgc2luZ2xlIHF1ZXJ5IG1hdGNoZXMgKGkuZSwgb25jZSB0aGF0IGFyZSAqbm90KiBxdW90ZWQpXG4gICAgICBpZHggPSAtMTtcbiAgICAgIHdoaWxlICgrK2lkeCA8IHNlYXJjaGVyc0xlbikge1xuICAgICAgICBjb25zdCBzZWFyY2hlciA9IHNlYXJjaGVyc1tpZHhdO1xuICAgICAgICBsZXQgdG9rZW4gPSBzZWFyY2hlci5pc1NpbmdsZU1hdGNoKHF1ZXJ5SXRlbSk7XG4gICAgICAgIGlmICh0b2tlbikge1xuICAgICAgICAgIHJlc3VsdHMucHVzaChuZXcgc2VhcmNoZXIodG9rZW4sIG9wdGlvbnMpKTtcbiAgICAgICAgICBicmVha1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHJlc3VsdHNcbiAgfSlcbn1cblxuLy8gVGhlc2UgZXh0ZW5kZWQgbWF0Y2hlcnMgY2FuIHJldHVybiBhbiBhcnJheSBvZiBtYXRjaGVzLCBhcyBvcHBvc2VkXG4vLyB0byBhIHNpbmdsIG1hdGNoXG5jb25zdCBNdWx0aU1hdGNoU2V0ID0gbmV3IFNldChbRnV6enlNYXRjaC50eXBlLCBJbmNsdWRlTWF0Y2gudHlwZV0pO1xuXG4vKipcbiAqIENvbW1hbmQtbGlrZSBzZWFyY2hpbmdcbiAqID09PT09PT09PT09PT09PT09PT09PT1cbiAqXG4gKiBHaXZlbiBtdWx0aXBsZSBzZWFyY2ggdGVybXMgZGVsaW1pdGVkIGJ5IHNwYWNlcy5lLmcuIGBeanNjcmlwdCAucHl0aG9uJCBydWJ5ICFqYXZhYCxcbiAqIHNlYXJjaCBpbiBhIGdpdmVuIHRleHQuXG4gKlxuICogU2VhcmNoIHN5bnRheDpcbiAqXG4gKiB8IFRva2VuICAgICAgIHwgTWF0Y2ggdHlwZSAgICAgICAgICAgICAgICAgfCBEZXNjcmlwdGlvbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB8XG4gKiB8IC0tLS0tLS0tLS0tIHwgLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gfCAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSB8XG4gKiB8IGBqc2NyaXB0YCAgIHwgZnV6enktbWF0Y2ggICAgICAgICAgICAgICAgfCBJdGVtcyB0aGF0IGZ1enp5IG1hdGNoIGBqc2NyaXB0YCAgICAgICB8XG4gKiB8IGA9c2NoZW1lYCAgIHwgZXhhY3QtbWF0Y2ggICAgICAgICAgICAgICAgfCBJdGVtcyB0aGF0IGFyZSBgc2NoZW1lYCAgICAgICAgICAgICAgICB8XG4gKiB8IGAncHl0aG9uYCAgIHwgaW5jbHVkZS1tYXRjaCAgICAgICAgICAgICAgfCBJdGVtcyB0aGF0IGluY2x1ZGUgYHB5dGhvbmAgICAgICAgICAgICB8XG4gKiB8IGAhcnVieWAgICAgIHwgaW52ZXJzZS1leGFjdC1tYXRjaCAgICAgICAgfCBJdGVtcyB0aGF0IGRvIG5vdCBpbmNsdWRlIGBydWJ5YCAgICAgICB8XG4gKiB8IGBeamF2YWAgICAgIHwgcHJlZml4LWV4YWN0LW1hdGNoICAgICAgICAgfCBJdGVtcyB0aGF0IHN0YXJ0IHdpdGggYGphdmFgICAgICAgICAgICB8XG4gKiB8IGAhXmVhcmxhbmdgIHwgaW52ZXJzZS1wcmVmaXgtZXhhY3QtbWF0Y2ggfCBJdGVtcyB0aGF0IGRvIG5vdCBzdGFydCB3aXRoIGBlYXJsYW5nYCB8XG4gKiB8IGAuanMkYCAgICAgIHwgc3VmZml4LWV4YWN0LW1hdGNoICAgICAgICAgfCBJdGVtcyB0aGF0IGVuZCB3aXRoIGAuanNgICAgICAgICAgICAgICB8XG4gKiB8IGAhLmdvJGAgICAgIHwgaW52ZXJzZS1zdWZmaXgtZXhhY3QtbWF0Y2ggfCBJdGVtcyB0aGF0IGRvIG5vdCBlbmQgd2l0aCBgLmdvYCAgICAgICB8XG4gKlxuICogQSBzaW5nbGUgcGlwZSBjaGFyYWN0ZXIgYWN0cyBhcyBhbiBPUiBvcGVyYXRvci4gRm9yIGV4YW1wbGUsIHRoZSBmb2xsb3dpbmdcbiAqIHF1ZXJ5IG1hdGNoZXMgZW50cmllcyB0aGF0IHN0YXJ0IHdpdGggYGNvcmVgIGFuZCBlbmQgd2l0aCBlaXRoZXJgZ29gLCBgcmJgLFxuICogb3JgcHlgLlxuICpcbiAqIGBgYFxuICogXmNvcmUgZ28kIHwgcmIkIHwgcHkkXG4gKiBgYGBcbiAqL1xuY2xhc3MgRXh0ZW5kZWRTZWFyY2gge1xuICBjb25zdHJ1Y3RvcihcbiAgICBwYXR0ZXJuLFxuICAgIHtcbiAgICAgIGlzQ2FzZVNlbnNpdGl2ZSA9IENvbmZpZy5pc0Nhc2VTZW5zaXRpdmUsXG4gICAgICBpbmNsdWRlTWF0Y2hlcyA9IENvbmZpZy5pbmNsdWRlTWF0Y2hlcyxcbiAgICAgIG1pbk1hdGNoQ2hhckxlbmd0aCA9IENvbmZpZy5taW5NYXRjaENoYXJMZW5ndGgsXG4gICAgICBpZ25vcmVMb2NhdGlvbiA9IENvbmZpZy5pZ25vcmVMb2NhdGlvbixcbiAgICAgIGZpbmRBbGxNYXRjaGVzID0gQ29uZmlnLmZpbmRBbGxNYXRjaGVzLFxuICAgICAgbG9jYXRpb24gPSBDb25maWcubG9jYXRpb24sXG4gICAgICB0aHJlc2hvbGQgPSBDb25maWcudGhyZXNob2xkLFxuICAgICAgZGlzdGFuY2UgPSBDb25maWcuZGlzdGFuY2VcbiAgICB9ID0ge31cbiAgKSB7XG4gICAgdGhpcy5xdWVyeSA9IG51bGw7XG4gICAgdGhpcy5vcHRpb25zID0ge1xuICAgICAgaXNDYXNlU2Vuc2l0aXZlLFxuICAgICAgaW5jbHVkZU1hdGNoZXMsXG4gICAgICBtaW5NYXRjaENoYXJMZW5ndGgsXG4gICAgICBmaW5kQWxsTWF0Y2hlcyxcbiAgICAgIGlnbm9yZUxvY2F0aW9uLFxuICAgICAgbG9jYXRpb24sXG4gICAgICB0aHJlc2hvbGQsXG4gICAgICBkaXN0YW5jZVxuICAgIH07XG5cbiAgICB0aGlzLnBhdHRlcm4gPSBpc0Nhc2VTZW5zaXRpdmUgPyBwYXR0ZXJuIDogcGF0dGVybi50b0xvd2VyQ2FzZSgpO1xuICAgIHRoaXMucXVlcnkgPSBwYXJzZVF1ZXJ5KHRoaXMucGF0dGVybiwgdGhpcy5vcHRpb25zKTtcbiAgfVxuXG4gIHN0YXRpYyBjb25kaXRpb24oXywgb3B0aW9ucykge1xuICAgIHJldHVybiBvcHRpb25zLnVzZUV4dGVuZGVkU2VhcmNoXG4gIH1cblxuICBzZWFyY2hJbih0ZXh0KSB7XG4gICAgY29uc3QgcXVlcnkgPSB0aGlzLnF1ZXJ5O1xuXG4gICAgaWYgKCFxdWVyeSkge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgaXNNYXRjaDogZmFsc2UsXG4gICAgICAgIHNjb3JlOiAxXG4gICAgICB9XG4gICAgfVxuXG4gICAgY29uc3QgeyBpbmNsdWRlTWF0Y2hlcywgaXNDYXNlU2Vuc2l0aXZlIH0gPSB0aGlzLm9wdGlvbnM7XG5cbiAgICB0ZXh0ID0gaXNDYXNlU2Vuc2l0aXZlID8gdGV4dCA6IHRleHQudG9Mb3dlckNhc2UoKTtcblxuICAgIGxldCBudW1NYXRjaGVzID0gMDtcbiAgICBsZXQgYWxsSW5kaWNlcyA9IFtdO1xuICAgIGxldCB0b3RhbFNjb3JlID0gMDtcblxuICAgIC8vIE9Sc1xuICAgIGZvciAobGV0IGkgPSAwLCBxTGVuID0gcXVlcnkubGVuZ3RoOyBpIDwgcUxlbjsgaSArPSAxKSB7XG4gICAgICBjb25zdCBzZWFyY2hlcnMgPSBxdWVyeVtpXTtcblxuICAgICAgLy8gUmVzZXQgaW5kaWNlc1xuICAgICAgYWxsSW5kaWNlcy5sZW5ndGggPSAwO1xuICAgICAgbnVtTWF0Y2hlcyA9IDA7XG5cbiAgICAgIC8vIEFORHNcbiAgICAgIGZvciAobGV0IGogPSAwLCBwTGVuID0gc2VhcmNoZXJzLmxlbmd0aDsgaiA8IHBMZW47IGogKz0gMSkge1xuICAgICAgICBjb25zdCBzZWFyY2hlciA9IHNlYXJjaGVyc1tqXTtcbiAgICAgICAgY29uc3QgeyBpc01hdGNoLCBpbmRpY2VzLCBzY29yZSB9ID0gc2VhcmNoZXIuc2VhcmNoKHRleHQpO1xuXG4gICAgICAgIGlmIChpc01hdGNoKSB7XG4gICAgICAgICAgbnVtTWF0Y2hlcyArPSAxO1xuICAgICAgICAgIHRvdGFsU2NvcmUgKz0gc2NvcmU7XG4gICAgICAgICAgaWYgKGluY2x1ZGVNYXRjaGVzKSB7XG4gICAgICAgICAgICBjb25zdCB0eXBlID0gc2VhcmNoZXIuY29uc3RydWN0b3IudHlwZTtcbiAgICAgICAgICAgIGlmIChNdWx0aU1hdGNoU2V0Lmhhcyh0eXBlKSkge1xuICAgICAgICAgICAgICBhbGxJbmRpY2VzID0gWy4uLmFsbEluZGljZXMsIC4uLmluZGljZXNdO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgYWxsSW5kaWNlcy5wdXNoKGluZGljZXMpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0b3RhbFNjb3JlID0gMDtcbiAgICAgICAgICBudW1NYXRjaGVzID0gMDtcbiAgICAgICAgICBhbGxJbmRpY2VzLmxlbmd0aCA9IDA7XG4gICAgICAgICAgYnJlYWtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICAvLyBPUiBjb25kaXRpb24sIHNvIGlmIFRSVUUsIHJldHVyblxuICAgICAgaWYgKG51bU1hdGNoZXMpIHtcbiAgICAgICAgbGV0IHJlc3VsdCA9IHtcbiAgICAgICAgICBpc01hdGNoOiB0cnVlLFxuICAgICAgICAgIHNjb3JlOiB0b3RhbFNjb3JlIC8gbnVtTWF0Y2hlc1xuICAgICAgICB9O1xuXG4gICAgICAgIGlmIChpbmNsdWRlTWF0Y2hlcykge1xuICAgICAgICAgIHJlc3VsdC5pbmRpY2VzID0gYWxsSW5kaWNlcztcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiByZXN1bHRcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBOb3RoaW5nIHdhcyBtYXRjaGVkXG4gICAgcmV0dXJuIHtcbiAgICAgIGlzTWF0Y2g6IGZhbHNlLFxuICAgICAgc2NvcmU6IDFcbiAgICB9XG4gIH1cbn1cblxuY29uc3QgcmVnaXN0ZXJlZFNlYXJjaGVycyA9IFtdO1xuXG5mdW5jdGlvbiByZWdpc3RlciguLi5hcmdzKSB7XG4gIHJlZ2lzdGVyZWRTZWFyY2hlcnMucHVzaCguLi5hcmdzKTtcbn1cblxuZnVuY3Rpb24gY3JlYXRlU2VhcmNoZXIocGF0dGVybiwgb3B0aW9ucykge1xuICBmb3IgKGxldCBpID0gMCwgbGVuID0gcmVnaXN0ZXJlZFNlYXJjaGVycy5sZW5ndGg7IGkgPCBsZW47IGkgKz0gMSkge1xuICAgIGxldCBzZWFyY2hlckNsYXNzID0gcmVnaXN0ZXJlZFNlYXJjaGVyc1tpXTtcbiAgICBpZiAoc2VhcmNoZXJDbGFzcy5jb25kaXRpb24ocGF0dGVybiwgb3B0aW9ucykpIHtcbiAgICAgIHJldHVybiBuZXcgc2VhcmNoZXJDbGFzcyhwYXR0ZXJuLCBvcHRpb25zKVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiBuZXcgQml0YXBTZWFyY2gocGF0dGVybiwgb3B0aW9ucylcbn1cblxuY29uc3QgTG9naWNhbE9wZXJhdG9yID0ge1xuICBBTkQ6ICckYW5kJyxcbiAgT1I6ICckb3InXG59O1xuXG5jb25zdCBLZXlUeXBlID0ge1xuICBQQVRIOiAnJHBhdGgnLFxuICBQQVRURVJOOiAnJHZhbCdcbn07XG5cbmNvbnN0IGlzRXhwcmVzc2lvbiA9IChxdWVyeSkgPT5cbiAgISEocXVlcnlbTG9naWNhbE9wZXJhdG9yLkFORF0gfHwgcXVlcnlbTG9naWNhbE9wZXJhdG9yLk9SXSk7XG5cbmNvbnN0IGlzUGF0aCA9IChxdWVyeSkgPT4gISFxdWVyeVtLZXlUeXBlLlBBVEhdO1xuXG5jb25zdCBpc0xlYWYgPSAocXVlcnkpID0+XG4gICFpc0FycmF5KHF1ZXJ5KSAmJiBpc09iamVjdChxdWVyeSkgJiYgIWlzRXhwcmVzc2lvbihxdWVyeSk7XG5cbmNvbnN0IGNvbnZlcnRUb0V4cGxpY2l0ID0gKHF1ZXJ5KSA9PiAoe1xuICBbTG9naWNhbE9wZXJhdG9yLkFORF06IE9iamVjdC5rZXlzKHF1ZXJ5KS5tYXAoKGtleSkgPT4gKHtcbiAgICBba2V5XTogcXVlcnlba2V5XVxuICB9KSlcbn0pO1xuXG4vLyBXaGVuIGBhdXRvYCBpcyBgdHJ1ZWAsIHRoZSBwYXJzZSBmdW5jdGlvbiB3aWxsIGluZmVyIGFuZCBpbml0aWFsaXplIGFuZCBhZGRcbi8vIHRoZSBhcHByb3ByaWF0ZSBgU2VhcmNoZXJgIGluc3RhbmNlXG5mdW5jdGlvbiBwYXJzZShxdWVyeSwgb3B0aW9ucywgeyBhdXRvID0gdHJ1ZSB9ID0ge30pIHtcbiAgY29uc3QgbmV4dCA9IChxdWVyeSkgPT4ge1xuICAgIGxldCBrZXlzID0gT2JqZWN0LmtleXMocXVlcnkpO1xuXG4gICAgY29uc3QgaXNRdWVyeVBhdGggPSBpc1BhdGgocXVlcnkpO1xuXG4gICAgaWYgKCFpc1F1ZXJ5UGF0aCAmJiBrZXlzLmxlbmd0aCA+IDEgJiYgIWlzRXhwcmVzc2lvbihxdWVyeSkpIHtcbiAgICAgIHJldHVybiBuZXh0KGNvbnZlcnRUb0V4cGxpY2l0KHF1ZXJ5KSlcbiAgICB9XG5cbiAgICBpZiAoaXNMZWFmKHF1ZXJ5KSkge1xuICAgICAgY29uc3Qga2V5ID0gaXNRdWVyeVBhdGggPyBxdWVyeVtLZXlUeXBlLlBBVEhdIDoga2V5c1swXTtcblxuICAgICAgY29uc3QgcGF0dGVybiA9IGlzUXVlcnlQYXRoID8gcXVlcnlbS2V5VHlwZS5QQVRURVJOXSA6IHF1ZXJ5W2tleV07XG5cbiAgICAgIGlmICghaXNTdHJpbmcocGF0dGVybikpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKExPR0lDQUxfU0VBUkNIX0lOVkFMSURfUVVFUllfRk9SX0tFWShrZXkpKVxuICAgICAgfVxuXG4gICAgICBjb25zdCBvYmogPSB7XG4gICAgICAgIGtleUlkOiBjcmVhdGVLZXlJZChrZXkpLFxuICAgICAgICBwYXR0ZXJuXG4gICAgICB9O1xuXG4gICAgICBpZiAoYXV0bykge1xuICAgICAgICBvYmouc2VhcmNoZXIgPSBjcmVhdGVTZWFyY2hlcihwYXR0ZXJuLCBvcHRpb25zKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIG9ialxuICAgIH1cblxuICAgIGxldCBub2RlID0ge1xuICAgICAgY2hpbGRyZW46IFtdLFxuICAgICAgb3BlcmF0b3I6IGtleXNbMF1cbiAgICB9O1xuXG4gICAga2V5cy5mb3JFYWNoKChrZXkpID0+IHtcbiAgICAgIGNvbnN0IHZhbHVlID0gcXVlcnlba2V5XTtcblxuICAgICAgaWYgKGlzQXJyYXkodmFsdWUpKSB7XG4gICAgICAgIHZhbHVlLmZvckVhY2goKGl0ZW0pID0+IHtcbiAgICAgICAgICBub2RlLmNoaWxkcmVuLnB1c2gobmV4dChpdGVtKSk7XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH0pO1xuXG4gICAgcmV0dXJuIG5vZGVcbiAgfTtcblxuICBpZiAoIWlzRXhwcmVzc2lvbihxdWVyeSkpIHtcbiAgICBxdWVyeSA9IGNvbnZlcnRUb0V4cGxpY2l0KHF1ZXJ5KTtcbiAgfVxuXG4gIHJldHVybiBuZXh0KHF1ZXJ5KVxufVxuXG4vLyBQcmFjdGljYWwgc2NvcmluZyBmdW5jdGlvblxuZnVuY3Rpb24gY29tcHV0ZVNjb3JlKFxuICByZXN1bHRzLFxuICB7IGlnbm9yZUZpZWxkTm9ybSA9IENvbmZpZy5pZ25vcmVGaWVsZE5vcm0gfVxuKSB7XG4gIHJlc3VsdHMuZm9yRWFjaCgocmVzdWx0KSA9PiB7XG4gICAgbGV0IHRvdGFsU2NvcmUgPSAxO1xuXG4gICAgcmVzdWx0Lm1hdGNoZXMuZm9yRWFjaCgoeyBrZXksIG5vcm0sIHNjb3JlIH0pID0+IHtcbiAgICAgIGNvbnN0IHdlaWdodCA9IGtleSA/IGtleS53ZWlnaHQgOiBudWxsO1xuXG4gICAgICB0b3RhbFNjb3JlICo9IE1hdGgucG93KFxuICAgICAgICBzY29yZSA9PT0gMCAmJiB3ZWlnaHQgPyBOdW1iZXIuRVBTSUxPTiA6IHNjb3JlLFxuICAgICAgICAod2VpZ2h0IHx8IDEpICogKGlnbm9yZUZpZWxkTm9ybSA/IDEgOiBub3JtKVxuICAgICAgKTtcbiAgICB9KTtcblxuICAgIHJlc3VsdC5zY29yZSA9IHRvdGFsU2NvcmU7XG4gIH0pO1xufVxuXG5mdW5jdGlvbiB0cmFuc2Zvcm1NYXRjaGVzKHJlc3VsdCwgZGF0YSkge1xuICBjb25zdCBtYXRjaGVzID0gcmVzdWx0Lm1hdGNoZXM7XG4gIGRhdGEubWF0Y2hlcyA9IFtdO1xuXG4gIGlmICghaXNEZWZpbmVkKG1hdGNoZXMpKSB7XG4gICAgcmV0dXJuXG4gIH1cblxuICBtYXRjaGVzLmZvckVhY2goKG1hdGNoKSA9PiB7XG4gICAgaWYgKCFpc0RlZmluZWQobWF0Y2guaW5kaWNlcykgfHwgIW1hdGNoLmluZGljZXMubGVuZ3RoKSB7XG4gICAgICByZXR1cm5cbiAgICB9XG5cbiAgICBjb25zdCB7IGluZGljZXMsIHZhbHVlIH0gPSBtYXRjaDtcblxuICAgIGxldCBvYmogPSB7XG4gICAgICBpbmRpY2VzLFxuICAgICAgdmFsdWVcbiAgICB9O1xuXG4gICAgaWYgKG1hdGNoLmtleSkge1xuICAgICAgb2JqLmtleSA9IG1hdGNoLmtleS5zcmM7XG4gICAgfVxuXG4gICAgaWYgKG1hdGNoLmlkeCA+IC0xKSB7XG4gICAgICBvYmoucmVmSW5kZXggPSBtYXRjaC5pZHg7XG4gICAgfVxuXG4gICAgZGF0YS5tYXRjaGVzLnB1c2gob2JqKTtcbiAgfSk7XG59XG5cbmZ1bmN0aW9uIHRyYW5zZm9ybVNjb3JlKHJlc3VsdCwgZGF0YSkge1xuICBkYXRhLnNjb3JlID0gcmVzdWx0LnNjb3JlO1xufVxuXG5mdW5jdGlvbiBmb3JtYXQoXG4gIHJlc3VsdHMsXG4gIGRvY3MsXG4gIHtcbiAgICBpbmNsdWRlTWF0Y2hlcyA9IENvbmZpZy5pbmNsdWRlTWF0Y2hlcyxcbiAgICBpbmNsdWRlU2NvcmUgPSBDb25maWcuaW5jbHVkZVNjb3JlXG4gIH0gPSB7fVxuKSB7XG4gIGNvbnN0IHRyYW5zZm9ybWVycyA9IFtdO1xuXG4gIGlmIChpbmNsdWRlTWF0Y2hlcykgdHJhbnNmb3JtZXJzLnB1c2godHJhbnNmb3JtTWF0Y2hlcyk7XG4gIGlmIChpbmNsdWRlU2NvcmUpIHRyYW5zZm9ybWVycy5wdXNoKHRyYW5zZm9ybVNjb3JlKTtcblxuICByZXR1cm4gcmVzdWx0cy5tYXAoKHJlc3VsdCkgPT4ge1xuICAgIGNvbnN0IHsgaWR4IH0gPSByZXN1bHQ7XG5cbiAgICBjb25zdCBkYXRhID0ge1xuICAgICAgaXRlbTogZG9jc1tpZHhdLFxuICAgICAgcmVmSW5kZXg6IGlkeFxuICAgIH07XG5cbiAgICBpZiAodHJhbnNmb3JtZXJzLmxlbmd0aCkge1xuICAgICAgdHJhbnNmb3JtZXJzLmZvckVhY2goKHRyYW5zZm9ybWVyKSA9PiB7XG4gICAgICAgIHRyYW5zZm9ybWVyKHJlc3VsdCwgZGF0YSk7XG4gICAgICB9KTtcbiAgICB9XG5cbiAgICByZXR1cm4gZGF0YVxuICB9KVxufVxuXG5jbGFzcyBGdXNlIHtcbiAgY29uc3RydWN0b3IoZG9jcywgb3B0aW9ucyA9IHt9LCBpbmRleCkge1xuICAgIHRoaXMub3B0aW9ucyA9IHsgLi4uQ29uZmlnLCAuLi5vcHRpb25zIH07XG5cbiAgICBpZiAoXG4gICAgICB0aGlzLm9wdGlvbnMudXNlRXh0ZW5kZWRTZWFyY2ggJiZcbiAgICAgICF0cnVlXG4gICAgKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoRVhURU5ERURfU0VBUkNIX1VOQVZBSUxBQkxFKVxuICAgIH1cblxuICAgIHRoaXMuX2tleVN0b3JlID0gbmV3IEtleVN0b3JlKHRoaXMub3B0aW9ucy5rZXlzKTtcblxuICAgIHRoaXMuc2V0Q29sbGVjdGlvbihkb2NzLCBpbmRleCk7XG4gIH1cblxuICBzZXRDb2xsZWN0aW9uKGRvY3MsIGluZGV4KSB7XG4gICAgdGhpcy5fZG9jcyA9IGRvY3M7XG5cbiAgICBpZiAoaW5kZXggJiYgIShpbmRleCBpbnN0YW5jZW9mIEZ1c2VJbmRleCkpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihJTkNPUlJFQ1RfSU5ERVhfVFlQRSlcbiAgICB9XG5cbiAgICB0aGlzLl9teUluZGV4ID1cbiAgICAgIGluZGV4IHx8XG4gICAgICBjcmVhdGVJbmRleCh0aGlzLm9wdGlvbnMua2V5cywgdGhpcy5fZG9jcywge1xuICAgICAgICBnZXRGbjogdGhpcy5vcHRpb25zLmdldEZuLFxuICAgICAgICBmaWVsZE5vcm1XZWlnaHQ6IHRoaXMub3B0aW9ucy5maWVsZE5vcm1XZWlnaHRcbiAgICAgIH0pO1xuICB9XG5cbiAgYWRkKGRvYykge1xuICAgIGlmICghaXNEZWZpbmVkKGRvYykpIHtcbiAgICAgIHJldHVyblxuICAgIH1cblxuICAgIHRoaXMuX2RvY3MucHVzaChkb2MpO1xuICAgIHRoaXMuX215SW5kZXguYWRkKGRvYyk7XG4gIH1cblxuICByZW1vdmUocHJlZGljYXRlID0gKC8qIGRvYywgaWR4ICovKSA9PiBmYWxzZSkge1xuICAgIGNvbnN0IHJlc3VsdHMgPSBbXTtcblxuICAgIGZvciAobGV0IGkgPSAwLCBsZW4gPSB0aGlzLl9kb2NzLmxlbmd0aDsgaSA8IGxlbjsgaSArPSAxKSB7XG4gICAgICBjb25zdCBkb2MgPSB0aGlzLl9kb2NzW2ldO1xuICAgICAgaWYgKHByZWRpY2F0ZShkb2MsIGkpKSB7XG4gICAgICAgIHRoaXMucmVtb3ZlQXQoaSk7XG4gICAgICAgIGkgLT0gMTtcbiAgICAgICAgbGVuIC09IDE7XG5cbiAgICAgICAgcmVzdWx0cy5wdXNoKGRvYyk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHJlc3VsdHNcbiAgfVxuXG4gIHJlbW92ZUF0KGlkeCkge1xuICAgIHRoaXMuX2RvY3Muc3BsaWNlKGlkeCwgMSk7XG4gICAgdGhpcy5fbXlJbmRleC5yZW1vdmVBdChpZHgpO1xuICB9XG5cbiAgZ2V0SW5kZXgoKSB7XG4gICAgcmV0dXJuIHRoaXMuX215SW5kZXhcbiAgfVxuXG4gIHNlYXJjaChxdWVyeSwgeyBsaW1pdCA9IC0xIH0gPSB7fSkge1xuICAgIGNvbnN0IHtcbiAgICAgIGluY2x1ZGVNYXRjaGVzLFxuICAgICAgaW5jbHVkZVNjb3JlLFxuICAgICAgc2hvdWxkU29ydCxcbiAgICAgIHNvcnRGbixcbiAgICAgIGlnbm9yZUZpZWxkTm9ybVxuICAgIH0gPSB0aGlzLm9wdGlvbnM7XG5cbiAgICBsZXQgcmVzdWx0cyA9IGlzU3RyaW5nKHF1ZXJ5KVxuICAgICAgPyBpc1N0cmluZyh0aGlzLl9kb2NzWzBdKVxuICAgICAgICA/IHRoaXMuX3NlYXJjaFN0cmluZ0xpc3QocXVlcnkpXG4gICAgICAgIDogdGhpcy5fc2VhcmNoT2JqZWN0TGlzdChxdWVyeSlcbiAgICAgIDogdGhpcy5fc2VhcmNoTG9naWNhbChxdWVyeSk7XG5cbiAgICBjb21wdXRlU2NvcmUocmVzdWx0cywgeyBpZ25vcmVGaWVsZE5vcm0gfSk7XG5cbiAgICBpZiAoc2hvdWxkU29ydCkge1xuICAgICAgcmVzdWx0cy5zb3J0KHNvcnRGbik7XG4gICAgfVxuXG4gICAgaWYgKGlzTnVtYmVyKGxpbWl0KSAmJiBsaW1pdCA+IC0xKSB7XG4gICAgICByZXN1bHRzID0gcmVzdWx0cy5zbGljZSgwLCBsaW1pdCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIGZvcm1hdChyZXN1bHRzLCB0aGlzLl9kb2NzLCB7XG4gICAgICBpbmNsdWRlTWF0Y2hlcyxcbiAgICAgIGluY2x1ZGVTY29yZVxuICAgIH0pXG4gIH1cblxuICBfc2VhcmNoU3RyaW5nTGlzdChxdWVyeSkge1xuICAgIGNvbnN0IHNlYXJjaGVyID0gY3JlYXRlU2VhcmNoZXIocXVlcnksIHRoaXMub3B0aW9ucyk7XG4gICAgY29uc3QgeyByZWNvcmRzIH0gPSB0aGlzLl9teUluZGV4O1xuICAgIGNvbnN0IHJlc3VsdHMgPSBbXTtcblxuICAgIC8vIEl0ZXJhdGUgb3ZlciBldmVyeSBzdHJpbmcgaW4gdGhlIGluZGV4XG4gICAgcmVjb3Jkcy5mb3JFYWNoKCh7IHY6IHRleHQsIGk6IGlkeCwgbjogbm9ybSB9KSA9PiB7XG4gICAgICBpZiAoIWlzRGVmaW5lZCh0ZXh0KSkge1xuICAgICAgICByZXR1cm5cbiAgICAgIH1cblxuICAgICAgY29uc3QgeyBpc01hdGNoLCBzY29yZSwgaW5kaWNlcyB9ID0gc2VhcmNoZXIuc2VhcmNoSW4odGV4dCk7XG5cbiAgICAgIGlmIChpc01hdGNoKSB7XG4gICAgICAgIHJlc3VsdHMucHVzaCh7XG4gICAgICAgICAgaXRlbTogdGV4dCxcbiAgICAgICAgICBpZHgsXG4gICAgICAgICAgbWF0Y2hlczogW3sgc2NvcmUsIHZhbHVlOiB0ZXh0LCBub3JtLCBpbmRpY2VzIH1dXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH0pO1xuXG4gICAgcmV0dXJuIHJlc3VsdHNcbiAgfVxuXG4gIF9zZWFyY2hMb2dpY2FsKHF1ZXJ5KSB7XG5cbiAgICBjb25zdCBleHByZXNzaW9uID0gcGFyc2UocXVlcnksIHRoaXMub3B0aW9ucyk7XG5cbiAgICBjb25zdCBldmFsdWF0ZSA9IChub2RlLCBpdGVtLCBpZHgpID0+IHtcbiAgICAgIGlmICghbm9kZS5jaGlsZHJlbikge1xuICAgICAgICBjb25zdCB7IGtleUlkLCBzZWFyY2hlciB9ID0gbm9kZTtcblxuICAgICAgICBjb25zdCBtYXRjaGVzID0gdGhpcy5fZmluZE1hdGNoZXMoe1xuICAgICAgICAgIGtleTogdGhpcy5fa2V5U3RvcmUuZ2V0KGtleUlkKSxcbiAgICAgICAgICB2YWx1ZTogdGhpcy5fbXlJbmRleC5nZXRWYWx1ZUZvckl0ZW1BdEtleUlkKGl0ZW0sIGtleUlkKSxcbiAgICAgICAgICBzZWFyY2hlclxuICAgICAgICB9KTtcblxuICAgICAgICBpZiAobWF0Y2hlcyAmJiBtYXRjaGVzLmxlbmd0aCkge1xuICAgICAgICAgIHJldHVybiBbXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgIGlkeCxcbiAgICAgICAgICAgICAgaXRlbSxcbiAgICAgICAgICAgICAgbWF0Y2hlc1xuICAgICAgICAgICAgfVxuICAgICAgICAgIF1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBbXVxuICAgICAgfVxuXG4gICAgICBjb25zdCByZXMgPSBbXTtcbiAgICAgIGZvciAobGV0IGkgPSAwLCBsZW4gPSBub2RlLmNoaWxkcmVuLmxlbmd0aDsgaSA8IGxlbjsgaSArPSAxKSB7XG4gICAgICAgIGNvbnN0IGNoaWxkID0gbm9kZS5jaGlsZHJlbltpXTtcbiAgICAgICAgY29uc3QgcmVzdWx0ID0gZXZhbHVhdGUoY2hpbGQsIGl0ZW0sIGlkeCk7XG4gICAgICAgIGlmIChyZXN1bHQubGVuZ3RoKSB7XG4gICAgICAgICAgcmVzLnB1c2goLi4ucmVzdWx0KTtcbiAgICAgICAgfSBlbHNlIGlmIChub2RlLm9wZXJhdG9yID09PSBMb2dpY2FsT3BlcmF0b3IuQU5EKSB7XG4gICAgICAgICAgcmV0dXJuIFtdXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiByZXNcbiAgICB9O1xuXG4gICAgY29uc3QgcmVjb3JkcyA9IHRoaXMuX215SW5kZXgucmVjb3JkcztcbiAgICBjb25zdCByZXN1bHRNYXAgPSB7fTtcbiAgICBjb25zdCByZXN1bHRzID0gW107XG5cbiAgICByZWNvcmRzLmZvckVhY2goKHsgJDogaXRlbSwgaTogaWR4IH0pID0+IHtcbiAgICAgIGlmIChpc0RlZmluZWQoaXRlbSkpIHtcbiAgICAgICAgbGV0IGV4cFJlc3VsdHMgPSBldmFsdWF0ZShleHByZXNzaW9uLCBpdGVtLCBpZHgpO1xuXG4gICAgICAgIGlmIChleHBSZXN1bHRzLmxlbmd0aCkge1xuICAgICAgICAgIC8vIERlZHVwZSB3aGVuIGFkZGluZ1xuICAgICAgICAgIGlmICghcmVzdWx0TWFwW2lkeF0pIHtcbiAgICAgICAgICAgIHJlc3VsdE1hcFtpZHhdID0geyBpZHgsIGl0ZW0sIG1hdGNoZXM6IFtdIH07XG4gICAgICAgICAgICByZXN1bHRzLnB1c2gocmVzdWx0TWFwW2lkeF0pO1xuICAgICAgICAgIH1cbiAgICAgICAgICBleHBSZXN1bHRzLmZvckVhY2goKHsgbWF0Y2hlcyB9KSA9PiB7XG4gICAgICAgICAgICByZXN1bHRNYXBbaWR4XS5tYXRjaGVzLnB1c2goLi4ubWF0Y2hlcyk7XG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9KTtcblxuICAgIHJldHVybiByZXN1bHRzXG4gIH1cblxuICBfc2VhcmNoT2JqZWN0TGlzdChxdWVyeSkge1xuICAgIGNvbnN0IHNlYXJjaGVyID0gY3JlYXRlU2VhcmNoZXIocXVlcnksIHRoaXMub3B0aW9ucyk7XG4gICAgY29uc3QgeyBrZXlzLCByZWNvcmRzIH0gPSB0aGlzLl9teUluZGV4O1xuICAgIGNvbnN0IHJlc3VsdHMgPSBbXTtcblxuICAgIC8vIExpc3QgaXMgQXJyYXk8T2JqZWN0PlxuICAgIHJlY29yZHMuZm9yRWFjaCgoeyAkOiBpdGVtLCBpOiBpZHggfSkgPT4ge1xuICAgICAgaWYgKCFpc0RlZmluZWQoaXRlbSkpIHtcbiAgICAgICAgcmV0dXJuXG4gICAgICB9XG5cbiAgICAgIGxldCBtYXRjaGVzID0gW107XG5cbiAgICAgIC8vIEl0ZXJhdGUgb3ZlciBldmVyeSBrZXkgKGkuZSwgcGF0aCksIGFuZCBmZXRjaCB0aGUgdmFsdWUgYXQgdGhhdCBrZXlcbiAgICAgIGtleXMuZm9yRWFjaCgoa2V5LCBrZXlJbmRleCkgPT4ge1xuICAgICAgICBtYXRjaGVzLnB1c2goXG4gICAgICAgICAgLi4udGhpcy5fZmluZE1hdGNoZXMoe1xuICAgICAgICAgICAga2V5LFxuICAgICAgICAgICAgdmFsdWU6IGl0ZW1ba2V5SW5kZXhdLFxuICAgICAgICAgICAgc2VhcmNoZXJcbiAgICAgICAgICB9KVxuICAgICAgICApO1xuICAgICAgfSk7XG5cbiAgICAgIGlmIChtYXRjaGVzLmxlbmd0aCkge1xuICAgICAgICByZXN1bHRzLnB1c2goe1xuICAgICAgICAgIGlkeCxcbiAgICAgICAgICBpdGVtLFxuICAgICAgICAgIG1hdGNoZXNcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfSk7XG5cbiAgICByZXR1cm4gcmVzdWx0c1xuICB9XG4gIF9maW5kTWF0Y2hlcyh7IGtleSwgdmFsdWUsIHNlYXJjaGVyIH0pIHtcbiAgICBpZiAoIWlzRGVmaW5lZCh2YWx1ZSkpIHtcbiAgICAgIHJldHVybiBbXVxuICAgIH1cblxuICAgIGxldCBtYXRjaGVzID0gW107XG5cbiAgICBpZiAoaXNBcnJheSh2YWx1ZSkpIHtcbiAgICAgIHZhbHVlLmZvckVhY2goKHsgdjogdGV4dCwgaTogaWR4LCBuOiBub3JtIH0pID0+IHtcbiAgICAgICAgaWYgKCFpc0RlZmluZWQodGV4dCkpIHtcbiAgICAgICAgICByZXR1cm5cbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IHsgaXNNYXRjaCwgc2NvcmUsIGluZGljZXMgfSA9IHNlYXJjaGVyLnNlYXJjaEluKHRleHQpO1xuXG4gICAgICAgIGlmIChpc01hdGNoKSB7XG4gICAgICAgICAgbWF0Y2hlcy5wdXNoKHtcbiAgICAgICAgICAgIHNjb3JlLFxuICAgICAgICAgICAga2V5LFxuICAgICAgICAgICAgdmFsdWU6IHRleHQsXG4gICAgICAgICAgICBpZHgsXG4gICAgICAgICAgICBub3JtLFxuICAgICAgICAgICAgaW5kaWNlc1xuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9IGVsc2Uge1xuICAgICAgY29uc3QgeyB2OiB0ZXh0LCBuOiBub3JtIH0gPSB2YWx1ZTtcblxuICAgICAgY29uc3QgeyBpc01hdGNoLCBzY29yZSwgaW5kaWNlcyB9ID0gc2VhcmNoZXIuc2VhcmNoSW4odGV4dCk7XG5cbiAgICAgIGlmIChpc01hdGNoKSB7XG4gICAgICAgIG1hdGNoZXMucHVzaCh7IHNjb3JlLCBrZXksIHZhbHVlOiB0ZXh0LCBub3JtLCBpbmRpY2VzIH0pO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBtYXRjaGVzXG4gIH1cbn1cblxuRnVzZS52ZXJzaW9uID0gJzYuNi4yJztcbkZ1c2UuY3JlYXRlSW5kZXggPSBjcmVhdGVJbmRleDtcbkZ1c2UucGFyc2VJbmRleCA9IHBhcnNlSW5kZXg7XG5GdXNlLmNvbmZpZyA9IENvbmZpZztcblxue1xuICBGdXNlLnBhcnNlUXVlcnkgPSBwYXJzZTtcbn1cblxue1xuICByZWdpc3RlcihFeHRlbmRlZFNlYXJjaCk7XG59XG5cbmV4cG9ydCB7IEZ1c2UgYXMgZGVmYXVsdCB9O1xuIiwiLyoqXG4gKiBqcXVlcnkueW91dHViZS1iYWNrZ3JvdW5kIHYxLjAuMTQgfCBOaWtvbGEgU3RhbWF0b3ZpYyA8QHN0YW1hdD4gfCBNSVRcbiAqL1xuXG4oZnVuY3Rpb24gKCkge1xuICAndXNlIHN0cmljdCc7XG5cbiAgZnVuY3Rpb24gaGFzQ2xhc3MoZWxlbWVudCwgY2xhc3NOYW1lKSB7XG4gICAgaWYgKGVsZW1lbnQuY2xhc3NMaXN0KSB7XG4gICAgICByZXR1cm4gZWxlbWVudC5jbGFzc0xpc3QuY29udGFpbnMoY2xhc3NOYW1lKTtcbiAgICB9XG4gICAgcmV0dXJuIG5ldyBSZWdFeHAoJ1xcXFxiJysgY2xhc3NOYW1lKydcXFxcYicpLnRlc3QoZWxlbWVudC5jbGFzc05hbWUpO1xuICB9XG5cbiAgZnVuY3Rpb24gYWRkQ2xhc3MoZWxlbWVudCwgY2xhc3NOYW1lcykge1xuICAgIGlmIChlbGVtZW50LmNsYXNzTGlzdCkge1xuICAgICAgY29uc3QgY2xhc3NlcyA9IGNsYXNzTmFtZXMuc3BsaXQoJyAnKTtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY2xhc3Nlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICBjb25zdCBlbF9jbGFzcyA9IGNsYXNzZXNbaV07XG4gICAgICAgIGVsZW1lbnQuY2xhc3NMaXN0LmFkZChlbF9jbGFzcyk7XG4gICAgICB9XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgaWYgKCFoYXNDbGFzcyhlbGVtZW50LCBjbGFzc05hbWUpKSB7XG4gICAgICBlbGVtZW50LmNsYXNzTmFtZSArPSAnICcgKyBjbGFzc05hbWU7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gcmVtb3ZlQ2xhc3MoZWxlbWVudCwgY2xhc3NOYW1lKSB7XG4gICAgaWYgKGVsZW1lbnQuY2xhc3NMaXN0KSB7XG4gICAgICBlbGVtZW50LmNsYXNzTGlzdC5yZW1vdmUoY2xhc3NOYW1lKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBlbGVtZW50LmNsYXNzTmFtZSA9IGVsZW1lbnQuY2xhc3NOYW1lLnJlcGxhY2UobmV3IFJlZ0V4cCgnXFxcXGInKyBjbGFzc05hbWUrJ1xcXFxiJywgJ2cnKSwgJycpO1xuICB9XG5cbiAgZnVuY3Rpb24gaXNNb2JpbGUoKSB7XG4gICAgbGV0IGlzX21vYmlsZSA9IGZhbHNlO1xuICAgIChmdW5jdGlvbihhKXtpZigvKGFuZHJvaWR8YmJcXGQrfG1lZWdvKS4rbW9iaWxlfGF2YW50Z298YmFkYVxcL3xibGFja2JlcnJ5fGJsYXplcnxjb21wYWx8ZWxhaW5lfGZlbm5lY3xoaXB0b3B8aWVtb2JpbGV8aXAoaG9uZXxvZCl8aXJpc3xraW5kbGV8bGdlIHxtYWVtb3xtaWRwfG1tcHxtb2JpbGUuK2ZpcmVmb3h8bmV0ZnJvbnR8b3BlcmEgbShvYnxpbilpfHBhbG0oIG9zKT98cGhvbmV8cChpeGl8cmUpXFwvfHBsdWNrZXJ8cG9ja2V0fHBzcHxzZXJpZXMoNHw2KTB8c3ltYmlhbnx0cmVvfHVwXFwuKGJyb3dzZXJ8bGluayl8dm9kYWZvbmV8d2FwfHdpbmRvd3MgY2V8eGRhfHhpaW5vL2kudGVzdChhKXx8LzEyMDd8NjMxMHw2NTkwfDNnc298NHRocHw1MFsxLTZdaXw3NzBzfDgwMnN8YSB3YXxhYmFjfGFjKGVyfG9vfHNcXC0pfGFpKGtvfHJuKXxhbChhdnxjYXxjbyl8YW1vaXxhbihleHxueXx5dyl8YXB0dXxhcihjaHxnbyl8YXModGV8dXMpfGF0dHd8YXUoZGl8XFwtbXxyIHxzICl8YXZhbnxiZShja3xsbHxucSl8YmkobGJ8cmQpfGJsKGFjfGF6KXxicihlfHYpd3xidW1ifGJ3XFwtKG58dSl8YzU1XFwvfGNhcGl8Y2N3YXxjZG1cXC18Y2VsbHxjaHRtfGNsZGN8Y21kXFwtfGNvKG1wfG5kKXxjcmF3fGRhKGl0fGxsfG5nKXxkYnRlfGRjXFwtc3xkZXZpfGRpY2F8ZG1vYnxkbyhjfHApb3xkcygxMnxcXC1kKXxlbCg0OXxhaSl8ZW0obDJ8dWwpfGVyKGljfGswKXxlc2w4fGV6KFs0LTddMHxvc3x3YXx6ZSl8ZmV0Y3xmbHkoXFwtfF8pfGcxIHV8ZzU2MHxnZW5lfGdmXFwtNXxnXFwtbW98Z28oXFwud3xvZCl8Z3IoYWR8dW4pfGhhaWV8aGNpdHxoZFxcLShtfHB8dCl8aGVpXFwtfGhpKHB0fHRhKXxocCggaXxpcCl8aHNcXC1jfGh0KGMoXFwtfCB8X3xhfGd8cHxzfHQpfHRwKXxodShhd3x0Yyl8aVxcLSgyMHxnb3xtYSl8aTIzMHxpYWMoIHxcXC18XFwvKXxpYnJvfGlkZWF8aWcwMXxpa29tfGltMWt8aW5ub3xpcGFxfGlyaXN8amEodHx2KWF8amJyb3xqZW11fGppZ3N8a2RkaXxrZWppfGtndCggfFxcLyl8a2xvbnxrcHQgfGt3Y1xcLXxreW8oY3xrKXxsZShub3x4aSl8bGcoIGd8XFwvKGt8bHx1KXw1MHw1NHxcXC1bYS13XSl8bGlid3xseW54fG0xXFwtd3xtM2dhfG01MFxcL3xtYSh0ZXx1aXx4byl8bWMoMDF8MjF8Y2EpfG1cXC1jcnxtZShyY3xyaSl8bWkobzh8b2F8dHMpfG1tZWZ8bW8oMDF8MDJ8Yml8ZGV8ZG98dChcXC18IHxvfHYpfHp6KXxtdCg1MHxwMXx2ICl8bXdicHxteXdhfG4xMFswLTJdfG4yMFsyLTNdfG4zMCgwfDIpfG41MCgwfDJ8NSl8bjcoMCgwfDEpfDEwKXxuZSgoY3xtKVxcLXxvbnx0Znx3Znx3Z3x3dCl8bm9rKDZ8aSl8bnpwaHxvMmltfG9wKHRpfHd2KXxvcmFufG93ZzF8cDgwMHxwYW4oYXxkfHQpfHBkeGd8cGcoMTN8XFwtKFsxLThdfGMpKXxwaGlsfHBpcmV8cGwoYXl8dWMpfHBuXFwtMnxwbyhja3xydHxzZSl8cHJveHxwc2lvfHB0XFwtZ3xxYVxcLWF8cWMoMDd8MTJ8MjF8MzJ8NjB8XFwtWzItN118aVxcLSl8cXRla3xyMzgwfHI2MDB8cmFrc3xyaW05fHJvKHZlfHpvKXxzNTVcXC98c2EoZ2V8bWF8bW18bXN8bnl8dmEpfHNjKDAxfGhcXC18b298cFxcLSl8c2RrXFwvfHNlKGMoXFwtfDB8MSl8NDd8bWN8bmR8cmkpfHNnaFxcLXxzaGFyfHNpZShcXC18bSl8c2tcXC0wfHNsKDQ1fGlkKXxzbShhbHxhcnxiM3xpdHx0NSl8c28oZnR8bnkpfHNwKDAxfGhcXC18dlxcLXx2ICl8c3koMDF8bWIpfHQyKDE4fDUwKXx0NigwMHwxMHwxOCl8dGEoZ3R8bGspfHRjbFxcLXx0ZGdcXC18dGVsKGl8bSl8dGltXFwtfHRcXC1tb3x0byhwbHxzaCl8dHMoNzB8bVxcLXxtM3xtNSl8dHhcXC05fHVwKFxcLmJ8ZzF8c2kpfHV0c3R8djQwMHx2NzUwfHZlcml8dmkocmd8dGUpfHZrKDQwfDVbMC0zXXxcXC12KXx2bTQwfHZvZGF8dnVsY3x2eCg1Mnw1M3w2MHw2MXw3MHw4MHw4MXw4M3w4NXw5OCl8dzNjKFxcLXwgKXx3ZWJjfHdoaXR8d2koZyB8bmN8bncpfHdtbGJ8d29udXx4NzAwfHlhc1xcLXx5b3VyfHpldG98enRlXFwtL2kudGVzdChhLnN1YnN0cigwLDQpKSkgaXNfbW9iaWxlID0gdHJ1ZTt9KShuYXZpZ2F0b3IudXNlckFnZW50fHxuYXZpZ2F0b3IudmVuZG9yfHx3aW5kb3cub3BlcmEpO1xuXG4gICAgcmV0dXJuIGlzX21vYmlsZTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGdldFJhbmRvbUludEluY2x1c2l2ZShtaW4sIG1heCkge1xuICAgIG1pbiA9IE1hdGguY2VpbChtaW4pO1xuICAgIG1heCA9IE1hdGguZmxvb3IobWF4KTtcbiAgICByZXR1cm4gTWF0aC5mbG9vcihNYXRoLnJhbmRvbSgpICogKG1heCAtIG1pbiArIDEpKSArIG1pbjsgLy9UaGUgbWF4aW11bSBpcyBpbmNsdXNpdmUgYW5kIHRoZSBtaW5pbXVtIGlzIGluY2x1c2l2ZVxuICB9XG5cbiAgZnVuY3Rpb24gcGFyc2VSZXNvbHV0aW9uU3RyaW5nKHJlcykge1xuICAgIGNvbnN0IHB0cyA9IHJlcy5zcGxpdCgvXFxzPzpcXHM/L2kpO1xuICAgIGNvbnN0IERFRkFVTFRfUkVTT0xVVElPTiA9IDE2Lzk7XG4gICAgaWYgKHB0cy5sZW5ndGggPCAyKSB7XG4gICAgICByZXR1cm4gREVGQVVMVF9SRVNPTFVUSU9OO1xuICAgIH1cblxuICAgIGNvbnN0IHcgPSBwYXJzZUludChwdHNbMF0sIDEwKTtcbiAgICBjb25zdCBoID0gcGFyc2VJbnQocHRzWzFdLCAxMCk7XG5cbiAgICBpZiAoaXNOYU4odykgfHwgaXNOYU4oaCkpIHtcbiAgICAgIHJldHVybiBERUZBVUxUX1JFU09MVVRJT047XG4gICAgfVxuXG4gICAgcmV0dXJuIHcvaDtcbiAgfVxuXG4gIGZ1bmN0aW9uIHBhcnNlUHJvcGVydGllcyhwYXJhbXMsIGRlZmF1bHRzLCBlbGVtZW50LCBhdHRyX3ByZWZpeCkge1xuICAgIGxldCByZXNfcGFyYW1zID0ge307XG5cbiAgICBpZiAoIXBhcmFtcykge1xuICAgICAgcmVzX3BhcmFtcyA9IGRlZmF1bHRzO1xuICAgIH0gZWxzZSB7XG4gICAgICBmb3IgKGxldCBrIGluIGRlZmF1bHRzKSB7XG4gICAgICAgIGlmICghcGFyYW1zLmhhc093blByb3BlcnR5KGspKSB7XG4gICAgICAgICAgLy9sb2FkIGluIGRlZmF1bHRzIGlmIHRoZSBwYXJhbSBoYXNuJ3QgYmVlbiBzZXRcbiAgICAgICAgICByZXNfcGFyYW1zW2tdID0gZGVmYXVsdHNba107XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoIWVsZW1lbnQpIHJldHVybiByZXNfcGFyYW1zO1xuICAgIC8vIGxvYWQgcGFyYW1zIGZyb20gZGF0YSBhdHRyaWJ1dGVzXG4gICAgZm9yIChsZXQgayBpbiByZXNfcGFyYW1zKSB7XG4gICAgICBsZXQgZGF0YTtcblxuICAgICAgaWYgKGF0dHJfcHJlZml4IGluc3RhbmNlb2YgQXJyYXkpIHtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBhdHRyX3ByZWZpeC5sZW5ndGg7IGkrKykge1xuICAgICAgICAgIGNvbnN0IHRlbXBfZGF0YSA9IGVsZW1lbnQuZ2V0QXR0cmlidXRlKGF0dHJfcHJlZml4W2ldK2spO1xuICAgICAgICAgIGlmICh0ZW1wX2RhdGEpIHtcbiAgICAgICAgICAgIGRhdGEgPSB0ZW1wX2RhdGE7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGRhdGEgPSBlbGVtZW50LmdldEF0dHJpYnV0ZShhdHRyX3ByZWZpeCtrKTtcbiAgICAgIH1cblxuICAgICAgaWYgKGRhdGEgIT09IHVuZGVmaW5lZCAmJiBkYXRhICE9PSBudWxsKSB7XG4gICAgICAgIGRhdGEgPSBkYXRhID09PSAnZmFsc2UnID8gZmFsc2UgOiBkYXRhO1xuICAgICAgICBkYXRhID0gL15cXGQrJC8udGVzdChkYXRhKSA/IHBhcnNlSW50KGRhdGEsIDEwKSA6IGRhdGE7XG4gICAgICAgIGRhdGEgPSAvXlxcZCtcXC5cXGQrJC8udGVzdChkYXRhKSA/IHBhcnNlRmxvYXQoZGF0YSkgOiBkYXRhO1xuICAgICAgICByZXNfcGFyYW1zW2tdID0gZGF0YTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gcmVzX3BhcmFtcztcbiAgfVxuXG4gIGNvbnN0IHRhZyA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3NjcmlwdCcpO1xuICB0YWcuc3JjID0gXCJodHRwczovL3d3dy55b3V0dWJlLmNvbS9wbGF5ZXJfYXBpXCI7XG4gIGNvbnN0IGZpcnN0U2NyaXB0VGFnID0gZG9jdW1lbnQuZ2V0RWxlbWVudHNCeVRhZ05hbWUoJ3NjcmlwdCcpWzBdO1xuICBmaXJzdFNjcmlwdFRhZy5wYXJlbnROb2RlLmluc2VydEJlZm9yZSh0YWcsIGZpcnN0U2NyaXB0VGFnKTtcblxuICBmdW5jdGlvbiBZb3V0dWJlQmFja2dyb3VuZChlbGVtLCBwYXJhbXMsIGlkLCB1aWQpIHtcbiAgICB0aGlzLmlzX21vYmlsZSA9IGlzTW9iaWxlKCk7XG5cbiAgICB0aGlzLmVsZW1lbnQgPSBlbGVtO1xuICAgIHRoaXMueXRpZCA9IGlkO1xuICAgIHRoaXMudWlkID0gdWlkO1xuICAgIHRoaXMucGxheWVyID0gbnVsbDtcbiAgICB0aGlzLmJ1dHRvbnMgPSB7fTtcblxuICAgIHRoaXMuc3RhdGUgPSB7fTtcbiAgICB0aGlzLnN0YXRlLnBsYXkgPSBmYWxzZTtcbiAgICB0aGlzLnN0YXRlLm11dGUgPSBmYWxzZTtcblxuICAgIHRoaXMucGFyYW1zID0ge307XG5cbiAgICBjb25zdCBERUZBVUxUUyA9IHtcbiAgICAgICdwYXVzZSc6IGZhbHNlLCAvL2RlcHJlY2F0ZWRcbiAgICAgICdwbGF5LWJ1dHRvbic6IGZhbHNlLFxuICAgICAgJ211dGUtYnV0dG9uJzogZmFsc2UsXG4gICAgICAnYXV0b3BsYXknOiB0cnVlLFxuICAgICAgJ211dGVkJzogdHJ1ZSxcbiAgICAgICdsb29wJzogdHJ1ZSxcbiAgICAgICdtb2JpbGUnOiBmYWxzZSxcbiAgICAgICdsb2FkLWJhY2tncm91bmQnOiB0cnVlLFxuICAgICAgJ3Jlc29sdXRpb24nOiAnMTY6OScsXG4gICAgICAnb25TdGF0dXNDaGFuZ2UnOiBmdW5jdGlvbigpIHt9LFxuICAgICAgJ2lubGluZS1zdHlsZXMnOiB0cnVlLFxuICAgICAgJ2ZpdC1ib3gnOiBmYWxzZSxcbiAgICAgICdvZmZzZXQnOiAyMDAsXG4gICAgICAnc3RhcnQtYXQnOiAwLFxuICAgICAgJ2VuZC1hdCc6IDAsXG4gICAgICAncG9zdGVyJzogbnVsbFxuICAgIH07XG5cbiAgICB0aGlzLl9faW5pdF9fID0gZnVuY3Rpb24gKCkge1xuICAgICAgaWYgKCF0aGlzLnl0aWQpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICB0aGlzLnBhcmFtcyA9IHBhcnNlUHJvcGVydGllcyhwYXJhbXMsIERFRkFVTFRTLCB0aGlzLmVsZW1lbnQsIFsnZGF0YS15dGJnLScsICdkYXRhLXZiZy0nXSk7XG4gICAgICAvL3BhdXNlIGRlcHJlY2F0ZWRcbiAgICAgIGlmICh0aGlzLnBhcmFtcy5wYXVzZSkge1xuICAgICAgICB0aGlzLnBhcmFtc1sncGxheS1idXR0b24nXSA9IHRoaXMucGFyYW1zLnBhdXNlO1xuICAgICAgfVxuICAgICAgdGhpcy5wYXJhbXMucmVzb2x1dGlvbl9tb2QgPSBwYXJzZVJlc29sdXRpb25TdHJpbmcodGhpcy5wYXJhbXMucmVzb2x1dGlvbik7XG4gICAgICB0aGlzLnN0YXRlLnBsYXlpbmcgPSB0aGlzLnBhcmFtcy5hdXRvcGxheTtcbiAgICAgIHRoaXMuc3RhdGUubXV0ZWQgPSB0aGlzLnBhcmFtcy5tdXRlZDtcbiAgICAgIHRoaXMuYnVpbGRIVE1MKCk7XG4gICAgICB0aGlzLmluamVjdFBsYXllcigpO1xuXG5cbiAgICAgIGlmICh0aGlzLnBhcmFtc1sncGxheS1idXR0b24nXSkge1xuICAgICAgICB0aGlzLmdlbmVyYXRlQWN0aW9uQnV0dG9uKHtcbiAgICAgICAgICBuYW1lOiAncGxheScsXG4gICAgICAgICAgY2xhc3NOYW1lOiAncGxheS10b2dnbGUnLFxuICAgICAgICAgIGlubmVySHRtbDogJzxpIGNsYXNzPVwiZmFcIj48L2k+JyxcbiAgICAgICAgICBpbml0aWFsU3RhdGU6IGZhbHNlLFxuICAgICAgICAgIHN0YXRlQ2xhc3NOYW1lOiAncGF1c2VkJyxcbiAgICAgICAgICBjb25kaXRpb25fcGFyYW1ldGVyOiAnYXV0b3BsYXknLFxuICAgICAgICAgIHN0YXRlQ2hpbGRDbGFzc05hbWVzOiBbJ2ZhLXBhdXNlLWNpcmNsZScsICdmYS1wbGF5LWNpcmNsZSddLFxuICAgICAgICAgIGFjdGlvbnM6IFsncGxheScsICdwYXVzZSddXG4gICAgICAgIH0pO1xuICAgICAgfVxuXG4gICAgICBpZiAodGhpcy5wYXJhbXNbJ211dGUtYnV0dG9uJ10pIHtcbiAgICAgICAgdGhpcy5nZW5lcmF0ZUFjdGlvbkJ1dHRvbih7XG4gICAgICAgICAgbmFtZTogJ211dGUnLFxuICAgICAgICAgIGNsYXNzTmFtZTogJ211dGUtdG9nZ2xlJyxcbiAgICAgICAgICBpbm5lckh0bWw6ICc8aSBjbGFzcz1cImZhXCI+PC9pPicsXG4gICAgICAgICAgaW5pdGlhbFN0YXRlOiB0cnVlLFxuICAgICAgICAgIHN0YXRlQ2xhc3NOYW1lOiAnbXV0ZWQnLFxuICAgICAgICAgIGNvbmRpdGlvbl9wYXJhbWV0ZXI6ICdtdXRlZCcsXG4gICAgICAgICAgc3RhdGVDaGlsZENsYXNzTmFtZXM6IFsnZmEtdm9sdW1lLXVwJywgJ2ZhLXZvbHVtZS1tdXRlJ10sXG4gICAgICAgICAgYWN0aW9uczogWyd1bm11dGUnLCAnbXV0ZSddXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH07XG5cbiAgICB0aGlzLl9faW5pdF9fKCk7XG4gIH1cblxuICBZb3V0dWJlQmFja2dyb3VuZC5wcm90b3R5cGUuaW5pdFlUUGxheWVyID0gZnVuY3Rpb24gKCkge1xuICAgIGNvbnN0IHNlbGYgPSB0aGlzO1xuICAgIGlmICh3aW5kb3cuaGFzT3duUHJvcGVydHkoJ1lUJykpIHtcbiAgICAgIHRoaXMucGxheWVyID0gbmV3IFlULlBsYXllcih0aGlzLnVpZCwge1xuICAgICAgICBldmVudHM6IHtcbiAgICAgICAgICAnb25SZWFkeSc6IGZ1bmN0aW9uKGV2ZW50KSB7XG4gICAgICAgICAgICBzZWxmLm9uVmlkZW9QbGF5ZXJSZWFkeShldmVudCk7XG4gICAgICAgICAgfSxcbiAgICAgICAgICAnb25TdGF0ZUNoYW5nZSc6IGZ1bmN0aW9uKGV2ZW50KSB7XG4gICAgICAgICAgICBzZWxmLm9uVmlkZW9TdGF0ZUNoYW5nZShldmVudCk7XG4gICAgICAgICAgfSxcbiAgICAgICAgICAnb25FcnJvcicgOiBmdW5jdGlvbihldmVudCkge1xuICAgICAgICAgICAgLy9jb25zb2xlLmVycm9yKCdwbGF5ZXJfYXBpJywgZXZlbnQpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfVxuICB9O1xuXG4gIFlvdXR1YmVCYWNrZ3JvdW5kLnByb3RvdHlwZS5zZWVrVG8gPSBmdW5jdGlvbiAoc2Vjb25kcykge1xuICAgIGlmIChzZWNvbmRzID4gMCkge1xuICAgICAgdGhpcy5wbGF5ZXIuc2Vla1RvKHNlY29uZHMsIHRydWUpO1xuICAgIH1cbiAgfTtcblxuICBZb3V0dWJlQmFja2dyb3VuZC5wcm90b3R5cGUub25WaWRlb1BsYXllclJlYWR5ID0gZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgaWYgKHRoaXMucGFyYW1zLmF1dG9wbGF5KSB7XG4gICAgICB0aGlzLnNlZWtUbyh0aGlzLnBhcmFtc1snc3RhcnQtYXQnXSk7XG4gICAgICB0aGlzLnBsYXllci5wbGF5VmlkZW8oKTtcbiAgICB9XG4gIH07XG5cbiAgWW91dHViZUJhY2tncm91bmQucHJvdG90eXBlLm9uVmlkZW9TdGF0ZUNoYW5nZSA9IGZ1bmN0aW9uIChldmVudCkge1xuICAgIGlmIChldmVudC5kYXRhID09PSAwICYmIHRoaXMucGFyYW1zLmxvb3ApIHtcbiAgICAgIHRoaXMuc2Vla1RvKHRoaXMucGFyYW1zWydzdGFydC1hdCddKTtcbiAgICAgIHRoaXMucGxheWVyLnBsYXlWaWRlbygpO1xuICAgIH1cblxuICAgIGlmIChldmVudC5kYXRhID09PSAtMSAmJiB0aGlzLnBhcmFtcy5hdXRvcGxheSkge1xuICAgICAgdGhpcy5zZWVrVG8odGhpcy5wYXJhbXNbJ3N0YXJ0LWF0J10pO1xuICAgICAgdGhpcy5wbGF5ZXIucGxheVZpZGVvKCk7XG4gICAgICB0aGlzLmVsZW1lbnQuZGlzcGF0Y2hFdmVudChuZXcgQ3VzdG9tRXZlbnQoJ3ZpZGVvLWJhY2tncm91bmQtcGxheScsIHsgYnViYmxlczogdHJ1ZSwgZGV0YWlsOiB0aGlzIH0pKTtcbiAgICB9XG5cbiAgICBpZiAoZXZlbnQuZGF0YSA9PT0gMSkge1xuICAgICAgdGhpcy5pZnJhbWUuc3R5bGUub3BhY2l0eSA9IDE7XG4gICAgfVxuXG4gICAgdGhpcy5wYXJhbXNbXCJvblN0YXR1c0NoYW5nZVwiXShldmVudCk7XG4gIH07XG5cbiAgWW91dHViZUJhY2tncm91bmQucHJvdG90eXBlLmluamVjdFBsYXllciA9IGZ1bmN0aW9uICgpIHtcbiAgICB0aGlzLmlmcmFtZSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2lmcmFtZScpO1xuICAgIHRoaXMuaWZyYW1lLnNldEF0dHJpYnV0ZSgnZnJhbWVib3JkZXInLCAwKTtcbiAgICB0aGlzLmlmcmFtZS5zZXRBdHRyaWJ1dGUoJ2FsbG93JywgJ2F1dG9wbGF5OyBtdXRlJyk7XG4gICAgbGV0IHNyYyA9IGBodHRwczovL3d3dy55b3V0dWJlLmNvbS9lbWJlZC8ke3RoaXMueXRpZH0/JmVuYWJsZWpzYXBpPTEmZGlzYWJsZWtiPTEmY29udHJvbHM9MCZyZWw9MCZpdl9sb2FkX3BvbGljeT0zJmNjX2xvYWRfcG9saWN5PTAmcGxheXNpbmxpbmU9MSZzaG93aW5mbz0wJm1vZGVzdGJyYW5kaW5nPTEmZnM9MGA7XG5cbiAgICBpZiAodGhpcy5wYXJhbXMubXV0ZWQpIHtcbiAgICAgIHNyYyArPSAnJm11dGU9MSc7XG4gICAgfVxuXG4gICAgaWYgKHRoaXMucGFyYW1zLmF1dG9wbGF5KSB7XG4gICAgICBzcmMgKz0gJyZhdXRvcGxheT0xJztcbiAgICB9XG5cbiAgICBpZiAodGhpcy5wYXJhbXMubG9vcCkge1xuICAgICAgc3JjICs9ICcmbG9vcD0xJztcbiAgICB9XG5cbiAgICBpZiAodGhpcy5wYXJhbXNbJ2VuZC1hdCddID4gMCkge1xuICAgICAgc3JjICs9IGAmZW5kPSR7dGhpcy5wYXJhbXNbJ2VuZC1hdCddfWA7XG4gICAgfVxuXG4gICAgdGhpcy5pZnJhbWUuc3JjID0gc3JjO1xuXG4gICAgaWYgKHRoaXMudWlkKSB7XG4gICAgICB0aGlzLmlmcmFtZS5pZCA9IHRoaXMudWlkO1xuICAgIH1cblxuICAgIGlmICh0aGlzLnBhcmFtc1snaW5saW5lLXN0eWxlcyddKSB7XG4gICAgICB0aGlzLmlmcmFtZS5zdHlsZS50b3AgPSAnNTAlJztcbiAgICAgIHRoaXMuaWZyYW1lLnN0eWxlLmxlZnQgPSAnNTAlJztcbiAgICAgIHRoaXMuaWZyYW1lLnN0eWxlLnRyYW5zZm9ybSA9ICd0cmFuc2xhdGVYKC01MCUpIHRyYW5zbGF0ZVkoLTUwJSknO1xuICAgICAgdGhpcy5pZnJhbWUuc3R5bGUucG9zaXRpb24gPSAnYWJzb2x1dGUnO1xuICAgICAgdGhpcy5pZnJhbWUuc3R5bGUub3BhY2l0eSA9IDA7XG4gICAgfVxuXG4gICAgdGhpcy5lbGVtZW50LmFwcGVuZENoaWxkKHRoaXMuaWZyYW1lKTtcblxuICAgIGlmICh0aGlzLnBhcmFtc1snZml0LWJveCddKSB7XG4gICAgICB0aGlzLmlmcmFtZS5zdHlsZS53aWR0aCA9ICcxMDAlJztcbiAgICAgIHRoaXMuaWZyYW1lLnN0eWxlLmhlaWdodCA9ICcxMDAlJztcbiAgICB9IGVsc2Uge1xuICAgICAgY29uc3Qgc2VsZiA9IHRoaXM7XG5cbiAgICAgIC8vVE9ET+Kdl++4jzogbWF5YmUgYSBzcGFjZXIgb3IgYXQgbGVhc3QgYWRkIHJlcXVlc3RBbmltYXRpb25GcmFtZVxuICAgICAgZnVuY3Rpb24gb25SZXNpemUoKSB7XG4gICAgICAgIGNvbnN0IGggPSBzZWxmLmlmcmFtZS5wYXJlbnROb2RlLm9mZnNldEhlaWdodCArIHNlbGYucGFyYW1zLm9mZnNldDsgLy8gc2luY2Ugc2hvd2luZm8gaXMgZGVwcmVjYXRlZCBhbmQgaWdub3JlZCBhZnRlciBTZXB0ZW1iZXIgMjUsIDIwMTguIHdlIGFkZCArMjAwIHRvIGhpZGUgaXQgaW4gdGhlIG92ZXJmbG93XG4gICAgICAgIGNvbnN0IHcgPSBzZWxmLmlmcmFtZS5wYXJlbnROb2RlLm9mZnNldFdpZHRoICsgc2VsZi5wYXJhbXMub2Zmc2V0O1xuICAgICAgICBjb25zdCByZXMgPSBzZWxmLnBhcmFtcy5yZXNvbHV0aW9uX21vZDtcblxuICAgICAgICBpZiAocmVzID4gdy9oKSB7XG4gICAgICAgICAgc2VsZi5pZnJhbWUuc3R5bGUud2lkdGggPSBoKnJlcyArICdweCc7XG4gICAgICAgICAgc2VsZi5pZnJhbWUuc3R5bGUuaGVpZ2h0ID0gaCArICdweCc7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgc2VsZi5pZnJhbWUuc3R5bGUud2lkdGggPSB3ICsgJ3B4JztcbiAgICAgICAgICBzZWxmLmlmcmFtZS5zdHlsZS5oZWlnaHQgPSB3L3JlcyArICdweCc7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYgKHdpbmRvdy5oYXNPd25Qcm9wZXJ0eSgnUmVzaXplT2JzZXJ2ZXInKSkge1xuICAgICAgICBjb25zdCByZXNpemVfb2JzZXJ2ZXIgPSBuZXcgUmVzaXplT2JzZXJ2ZXIoKCkgPT4ge1xuICAgICAgICAgIHdpbmRvdy5yZXF1ZXN0QW5pbWF0aW9uRnJhbWUob25SZXNpemUpO1xuICAgICAgICB9KTtcbiAgICAgICAgcmVzaXplX29ic2VydmVyLm9ic2VydmUodGhpcy5lbGVtZW50KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKCdyZXNpemUnLCAoKSA9PiB7XG4gICAgICAgICAgd2luZG93LnJlcXVlc3RBbmltYXRpb25GcmFtZShvblJlc2l6ZSk7XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgICAgb25SZXNpemUoKTtcbiAgICB9XG4gIH07XG5cbiAgWW91dHViZUJhY2tncm91bmQucHJvdG90eXBlLmJ1aWxkSFRNTCA9IGZ1bmN0aW9uICgpIHtcbiAgICBjb25zdCBwYXJlbnQgPSB0aGlzLmVsZW1lbnQucGFyZW50Tm9kZTtcbiAgICAvLyB3cmFwXG4gICAgYWRkQ2xhc3ModGhpcy5lbGVtZW50LCAneW91dHViZS1iYWNrZ3JvdW5kIHZpZGVvLWJhY2tncm91bmQnKTtcblxuICAgIC8vc2V0IGNzcyBydWxlc1xuICAgIGNvbnN0IHdyYXBwZXJfc3R5bGVzID0ge1xuICAgICAgXCJoZWlnaHRcIiA6IFwiMTAwJVwiLFxuICAgICAgXCJ3aWR0aFwiIDogXCIxMDAlXCIsXG4gICAgICBcInotaW5kZXhcIjogXCIwXCIsXG4gICAgICBcInBvc2l0aW9uXCI6IFwiYWJzb2x1dGVcIixcbiAgICAgIFwib3ZlcmZsb3dcIjogXCJoaWRkZW5cIixcbiAgICAgIFwidG9wXCI6IDAsIC8vIGFkZGVkIGJ5IEBpbnNhZFxuICAgICAgXCJsZWZ0XCI6IDAsXG4gICAgICBcImJvdHRvbVwiOiAwLFxuICAgICAgXCJyaWdodFwiOiAwXG4gICAgfTtcblxuICAgIGlmICghdGhpcy5wYXJhbXNbJ211dGUtYnV0dG9uJ10pIHtcbiAgICAgIHdyYXBwZXJfc3R5bGVzW1wicG9pbnRlci1ldmVudHNcIl0gPSBcIm5vbmVcIjsgLy8gYXZvaWQgcmlnaHQgbW91c2UgY2xpY2sgcG9wdXAgbWVudVxuICAgIH1cblxuICAgIGlmICh0aGlzLnBhcmFtc1snbG9hZC1iYWNrZ3JvdW5kJ10gfHwgdGhpcy5wYXJhbXNbJ3Bvc3RlciddKSB7XG4gICAgICBpZiAodGhpcy5wYXJhbXNbJ2xvYWQtYmFja2dyb3VuZCddKSB3cmFwcGVyX3N0eWxlc1snYmFja2dyb3VuZC1pbWFnZSddID0gJ3VybChodHRwczovL2ltZy55b3V0dWJlLmNvbS92aS8nK3RoaXMueXRpZCsnL21heHJlc2RlZmF1bHQuanBnKSc7XG4gICAgICBpZiAodGhpcy5wYXJhbXNbJ3Bvc3RlciddKSB3cmFwcGVyX3N0eWxlc1snYmFja2dyb3VuZC1pbWFnZSddID0gdGhpcy5wYXJhbXNbJ3Bvc3RlciddO1xuICAgICAgd3JhcHBlcl9zdHlsZXNbJ2JhY2tncm91bmQtc2l6ZSddID0gJ2NvdmVyJztcbiAgICAgIHdyYXBwZXJfc3R5bGVzWydiYWNrZ3JvdW5kLXJlcGVhdCddID0gJ25vLXJlcGVhdCc7XG4gICAgICB3cmFwcGVyX3N0eWxlc1snYmFja2dyb3VuZC1wb3NpdGlvbiddID0gJ2NlbnRlcic7XG4gICAgfVxuXG4gICAgaWYgKHRoaXMucGFyYW1zWydpbmxpbmUtc3R5bGVzJ10pIHtcbiAgICAgIGZvciAobGV0IHByb3BlcnR5IGluIHdyYXBwZXJfc3R5bGVzKSB7XG4gICAgICAgIHRoaXMuZWxlbWVudC5zdHlsZVtwcm9wZXJ0eV0gPSB3cmFwcGVyX3N0eWxlc1twcm9wZXJ0eV07XG4gICAgICB9XG4gICAgICBcbiAgICAgIGlmICghWydhYnNvbHV0ZScsICdmaXhlZCcsICdyZWxhdGl2ZScsICdzdGlja3knXS5pbmRleE9mKHBhcmVudC5zdHlsZS5wb3NpdGlvbikpIHtcbiAgICAgICAgcGFyZW50LnN0eWxlLnBvc2l0aW9uID0gJ3JlbGF0aXZlJztcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAodGhpcy5pc19tb2JpbGUgJiYgIXRoaXMucGFyYW1zLm1vYmlsZSkge1xuICAgICAgcmV0dXJuIHRoaXMuZWxlbWVudDtcbiAgICB9XG5cbiAgICAvLyBzZXQgcGxheS9tdXRlIGNvbnRyb2xzIHdyYXBcbiAgICBpZiAodGhpcy5wYXJhbXNbJ3BsYXktYnV0dG9uJ10gfHwgdGhpcy5wYXJhbXNbJ211dGUtYnV0dG9uJ10pIHtcbiAgICAgIGNvbnN0IGNvbnRyb2xzID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgICBjb250cm9scy5jbGFzc05hbWUgPSAndmlkZW8tYmFja2dyb3VuZC1jb250cm9scyc7XG5cbiAgICAgIGNvbnRyb2xzLnN0eWxlLnBvc2l0aW9uID0gJ2Fic29sdXRlJztcbiAgICAgIGNvbnRyb2xzLnN0eWxlLnRvcCA9ICcxMHB4JztcbiAgICAgIGNvbnRyb2xzLnN0eWxlLnJpZ2h0ID0gJzEwcHgnO1xuICAgICAgY29udHJvbHMuc3R5bGVbJ3otaW5kZXgnXSA9IDI7XG5cbiAgICAgIHRoaXMuY29udHJvbHNfZWxlbWVudCA9IGNvbnRyb2xzO1xuICAgICAgcGFyZW50LmFwcGVuZENoaWxkKGNvbnRyb2xzKTtcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcy5lbGVtZW50O1xuICB9O1xuXG4gIFlvdXR1YmVCYWNrZ3JvdW5kLnByb3RvdHlwZS5wbGF5ID0gZnVuY3Rpb24gKCkge1xuICAgIC8vVE9ETzogc29sdmUgdGhpcyB3aXRoIEFSSUEgdG9nZ2xlIHN0YXRlcy4gUC5TLiB3YXJuaW5nIHJlcGV0aXRpdmUgY29kZSEhIVxuICAgIGlmICh0aGlzLmJ1dHRvbnMuaGFzT3duUHJvcGVydHkoJ3BsYXknKSkge1xuICAgICAgY29uc3QgYnRuX29iaiA9IHRoaXMuYnV0dG9ucy5wbGF5O1xuICAgICAgcmVtb3ZlQ2xhc3MoYnRuX29iai5lbGVtZW50LCBidG5fb2JqLmJ1dHRvbl9wcm9wZXJ0aWVzLnN0YXRlQ2xhc3NOYW1lKTtcbiAgICAgIGFkZENsYXNzKGJ0bl9vYmouZWxlbWVudC5maXJzdENoaWxkLCBidG5fb2JqLmJ1dHRvbl9wcm9wZXJ0aWVzLnN0YXRlQ2hpbGRDbGFzc05hbWVzWzBdKTtcbiAgICAgIHJlbW92ZUNsYXNzKGJ0bl9vYmouZWxlbWVudC5maXJzdENoaWxkLCBidG5fb2JqLmJ1dHRvbl9wcm9wZXJ0aWVzLnN0YXRlQ2hpbGRDbGFzc05hbWVzWzFdKTtcbiAgICB9XG5cbiAgICBpZiAodGhpcy5wbGF5ZXIpIHtcbiAgICAgIGlmICh0aGlzLnBhcmFtc1snc3RhcnQtYXQnXSAmJiB0aGlzLnBsYXllci5nZXRDdXJyZW50VGltZSgpIDwgdGhpcy5wYXJhbXNbJ3N0YXJ0LWF0J10gKSB7XG4gICAgICAgIHRoaXMuc2Vla1RvKHRoaXMucGFyYW1zWydzdGFydC1hdCddKTtcbiAgICAgIH1cbiAgICAgIHRoaXMucGxheWVyLnBsYXlWaWRlbygpO1xuICAgICAgdGhpcy5lbGVtZW50LmRpc3BhdGNoRXZlbnQobmV3IEN1c3RvbUV2ZW50KCd2aWRlby1iYWNrZ3JvdW5kLXBsYXknLCB7IGJ1YmJsZXM6IHRydWUsIGRldGFpbDogdGhpcyB9KSk7XG4gICAgfVxuICB9O1xuXG4gIFlvdXR1YmVCYWNrZ3JvdW5kLnByb3RvdHlwZS5wYXVzZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAvL1RPRE86IHNvbHZlIHRoaXMgd2l0aCBBUklBIHRvZ2dsZSBzdGF0ZXNcbiAgICBpZiAodGhpcy5idXR0b25zLmhhc093blByb3BlcnR5KCdwbGF5JykpIHtcbiAgICAgIGNvbnN0IGJ0bl9vYmogPSB0aGlzLmJ1dHRvbnMucGxheTtcbiAgICAgIGFkZENsYXNzKGJ0bl9vYmouZWxlbWVudCwgYnRuX29iai5idXR0b25fcHJvcGVydGllcy5zdGF0ZUNsYXNzTmFtZSk7XG4gICAgICByZW1vdmVDbGFzcyhidG5fb2JqLmVsZW1lbnQuZmlyc3RDaGlsZCwgYnRuX29iai5idXR0b25fcHJvcGVydGllcy5zdGF0ZUNoaWxkQ2xhc3NOYW1lc1swXSk7XG4gICAgICBhZGRDbGFzcyhidG5fb2JqLmVsZW1lbnQuZmlyc3RDaGlsZCwgYnRuX29iai5idXR0b25fcHJvcGVydGllcy5zdGF0ZUNoaWxkQ2xhc3NOYW1lc1sxXSk7XG4gICAgfVxuXG4gICAgaWYgKHRoaXMucGxheWVyKSB7XG4gICAgICB0aGlzLnBsYXllci5wYXVzZVZpZGVvKCk7XG4gICAgICB0aGlzLmVsZW1lbnQuZGlzcGF0Y2hFdmVudChuZXcgQ3VzdG9tRXZlbnQoJ3ZpZGVvLWJhY2tncm91bmQtcGF1c2UnLCB7IGJ1YmJsZXM6IHRydWUsIGRldGFpbDogdGhpcyB9KSk7XG4gICAgfVxuICB9O1xuXG4gIFlvdXR1YmVCYWNrZ3JvdW5kLnByb3RvdHlwZS51bm11dGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgLy9UT0RPOiBzb2x2ZSB0aGlzIHdpdGggQVJJQSB0b2dnbGUgc3RhdGVzXG4gICAgaWYgKHRoaXMuYnV0dG9ucy5oYXNPd25Qcm9wZXJ0eSgnbXV0ZScpKSB7XG4gICAgICBjb25zdCBidG5fb2JqID0gdGhpcy5idXR0b25zLm11dGU7XG4gICAgICByZW1vdmVDbGFzcyhidG5fb2JqLmVsZW1lbnQsIGJ0bl9vYmouYnV0dG9uX3Byb3BlcnRpZXMuc3RhdGVDbGFzc05hbWUpO1xuICAgICAgYWRkQ2xhc3MoYnRuX29iai5lbGVtZW50LmZpcnN0Q2hpbGQsIGJ0bl9vYmouYnV0dG9uX3Byb3BlcnRpZXMuc3RhdGVDaGlsZENsYXNzTmFtZXNbMF0pO1xuICAgICAgcmVtb3ZlQ2xhc3MoYnRuX29iai5lbGVtZW50LmZpcnN0Q2hpbGQsIGJ0bl9vYmouYnV0dG9uX3Byb3BlcnRpZXMuc3RhdGVDaGlsZENsYXNzTmFtZXNbMV0pO1xuICAgIH1cblxuICAgIGlmICh0aGlzLnBsYXllcikge1xuICAgICAgdGhpcy5wbGF5ZXIudW5NdXRlKCk7XG4gICAgICB0aGlzLmVsZW1lbnQuZGlzcGF0Y2hFdmVudChuZXcgQ3VzdG9tRXZlbnQoJ3ZpZGVvLWJhY2tncm91bmQtdW5tdXRlJywgeyBidWJibGVzOiB0cnVlLCBkZXRhaWw6IHRoaXMgfSkpO1xuICAgIH1cbiAgfTtcblxuICBZb3V0dWJlQmFja2dyb3VuZC5wcm90b3R5cGUubXV0ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAvL1RPRE86IHNvbHZlIHRoaXMgd2l0aCBBUklBIHRvZ2dsZSBzdGF0ZXNcbiAgICBpZiAodGhpcy5idXR0b25zLmhhc093blByb3BlcnR5KCdtdXRlJykpIHtcbiAgICAgIGNvbnN0IGJ0bl9vYmogPSB0aGlzLmJ1dHRvbnMubXV0ZTtcbiAgICAgIGFkZENsYXNzKGJ0bl9vYmouZWxlbWVudCwgYnRuX29iai5idXR0b25fcHJvcGVydGllcy5zdGF0ZUNsYXNzTmFtZSk7XG4gICAgICByZW1vdmVDbGFzcyhidG5fb2JqLmVsZW1lbnQuZmlyc3RDaGlsZCwgYnRuX29iai5idXR0b25fcHJvcGVydGllcy5zdGF0ZUNoaWxkQ2xhc3NOYW1lc1swXSk7XG4gICAgICBhZGRDbGFzcyhidG5fb2JqLmVsZW1lbnQuZmlyc3RDaGlsZCwgYnRuX29iai5idXR0b25fcHJvcGVydGllcy5zdGF0ZUNoaWxkQ2xhc3NOYW1lc1sxXSk7XG4gICAgfVxuXG4gICAgaWYgKHRoaXMucGxheWVyKSB7XG4gICAgICB0aGlzLnBsYXllci5tdXRlKCk7XG4gICAgICB0aGlzLmVsZW1lbnQuZGlzcGF0Y2hFdmVudChuZXcgQ3VzdG9tRXZlbnQoJ3ZpZGVvLWJhY2tncm91bmQtbXV0ZScsIHsgYnViYmxlczogdHJ1ZSwgZGV0YWlsOiB0aGlzIH0pKTtcbiAgICB9XG4gIH07XG5cbiAgLy9UT0RPOiByZWZhY3RvciBzdGF0ZXMgdG8gYmUgZXF1YWwgZm9yIGFsbCBidXR0b25zXG4gIFlvdXR1YmVCYWNrZ3JvdW5kLnByb3RvdHlwZS5nZW5lcmF0ZUFjdGlvbkJ1dHRvbiA9IGZ1bmN0aW9uIChvYmopIHtcbiAgICBjb25zdCBidG4gPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdidXR0b24nKTtcbiAgICBidG4uY2xhc3NOYW1lID0gb2JqLmNsYXNzTmFtZTtcbiAgICBidG4uaW5uZXJIVE1MID0gb2JqLmlubmVySHRtbDtcbiAgICBhZGRDbGFzcyhidG4uZmlyc3RDaGlsZCwgb2JqLnN0YXRlQ2hpbGRDbGFzc05hbWVzWzBdKTtcblxuICAgIC8vVE9ETzogc29sdmUgdGhpcyB3aXRoIEFSSUEgdG9nZ2xlIHN0YXRlc1xuICAgIGlmICh0aGlzLnBhcmFtc1tvYmouY29uZGl0aW9uX3BhcmFtZXRlcl0gPT09IG9iai5pbml0aWFsU3RhdGUpIHtcbiAgICAgIGFkZENsYXNzKGJ0biwgb2JqLnN0YXRlQ2xhc3NOYW1lKTtcbiAgICAgIHJlbW92ZUNsYXNzKGJ0bi5maXJzdENoaWxkLCBvYmouc3RhdGVDaGlsZENsYXNzTmFtZXNbMF0pO1xuICAgICAgYWRkQ2xhc3MoYnRuLmZpcnN0Q2hpbGQsIG9iai5zdGF0ZUNoaWxkQ2xhc3NOYW1lc1sxXSk7XG4gICAgfVxuXG4gICAgY29uc3Qgc2VsZiA9IHRoaXM7XG4gICAgYnRuLmFkZEV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgZnVuY3Rpb24oZSkge1xuICAgICAgaWYgKGhhc0NsYXNzKHRoaXMsIG9iai5zdGF0ZUNsYXNzTmFtZSkpIHtcbiAgICAgICAgc2VsZi5zdGF0ZVtvYmoubmFtZV0gPSBmYWxzZTtcbiAgICAgICAgc2VsZltvYmouYWN0aW9uc1swXV0oKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHNlbGYuc3RhdGVbb2JqLm5hbWVdID0gdHJ1ZTtcbiAgICAgICAgc2VsZltvYmouYWN0aW9uc1sxXV0oKTtcbiAgICAgIH1cbiAgICB9KTtcblxuICAgIHRoaXMuYnV0dG9uc1tvYmoubmFtZV0gPSB7XG4gICAgICBlbGVtZW50OiBidG4sXG4gICAgICBidXR0b25fcHJvcGVydGllczogb2JqXG4gICAgfTtcblxuICAgIHRoaXMuY29udHJvbHNfZWxlbWVudC5hcHBlbmRDaGlsZChidG4pO1xuICB9O1xuXG4gIGZ1bmN0aW9uIFZpbWVvQmFja2dyb3VuZChlbGVtLCBwYXJhbXMsIGlkLCB1aWQpIHtcbiAgICB0aGlzLmlzX21vYmlsZSA9IGlzTW9iaWxlKCk7XG5cbiAgICB0aGlzLmVsZW1lbnQgPSBlbGVtO1xuICAgIHRoaXMudmlkID0gaWQ7XG4gICAgdGhpcy51aWQgPSB1aWQ7XG4gICAgdGhpcy5wbGF5ZXIgPSBudWxsO1xuICAgIHRoaXMuYnV0dG9ucyA9IHt9O1xuXG4gICAgdGhpcy5zdGF0ZSA9IHt9O1xuICAgIHRoaXMuc3RhdGUucGxheSA9IGZhbHNlO1xuICAgIHRoaXMuc3RhdGUubXV0ZSA9IGZhbHNlO1xuXG4gICAgdGhpcy5wYXJhbXMgPSB7fTtcblxuICAgIGNvbnN0IERFRkFVTFRTID0ge1xuICAvLyAgICAncGF1c2UnOiBmYWxzZSwgLy9kZXByZWNhdGVkXG4gIC8vICAgICdwbGF5LWJ1dHRvbic6IGZhbHNlLFxuICAvLyAgICAnbXV0ZS1idXR0b24nOiBmYWxzZSxcbiAgICAgICdhdXRvcGxheSc6IHRydWUsXG4gICAgICAnbXV0ZWQnOiB0cnVlLFxuICAgICAgJ2xvb3AnOiB0cnVlLFxuICAgICAgJ21vYmlsZSc6IGZhbHNlLFxuICAvLyAgICAnbG9hZC1iYWNrZ3JvdW5kJzogdHJ1ZSxcbiAgICAgICdyZXNvbHV0aW9uJzogJzE2OjknLFxuICAgICAgJ2lubGluZS1zdHlsZXMnOiB0cnVlLFxuICAgICAgJ2ZpdC1ib3gnOiBmYWxzZSxcbiAgICAgICdvZmZzZXQnOiAyMDAsXG4gICAgICAnc3RhcnQtYXQnOiAwLFxuICAgICAgJ3Bvc3Rlcic6IG51bGxcbiAgICB9O1xuXG4gICAgdGhpcy5fX2luaXRfXyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIGlmICghdGhpcy52aWQpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICB0aGlzLnBhcmFtcyA9IHBhcnNlUHJvcGVydGllcyhwYXJhbXMsIERFRkFVTFRTLCB0aGlzLmVsZW1lbnQsIFsnZGF0YS15dGJnLScsICdkYXRhLXZiZy0nXSk7XG4gICAgICAvL3BhdXNlIGRlcHJlY2F0ZWRcbiAgICAgIGlmICh0aGlzLnBhcmFtcy5wYXVzZSkge1xuICAgICAgICB0aGlzLnBhcmFtc1sncGxheS1idXR0b24nXSA9IHRoaXMucGFyYW1zLnBhdXNlO1xuICAgICAgfVxuICAgICAgdGhpcy5wYXJhbXMucmVzb2x1dGlvbl9tb2QgPSBwYXJzZVJlc29sdXRpb25TdHJpbmcodGhpcy5wYXJhbXMucmVzb2x1dGlvbik7XG4gICAgICB0aGlzLnN0YXRlLnBsYXlpbmcgPSB0aGlzLnBhcmFtcy5hdXRvcGxheTtcbiAgICAgIHRoaXMuc3RhdGUubXV0ZWQgPSB0aGlzLnBhcmFtcy5tdXRlZDtcblxuICAgICAgdGhpcy5idWlsZEhUTUwoKTtcbiAgICAgIHRoaXMuaW5qZWN0UGxheWVyKCk7XG4gICAgfTtcblxuICAgIHRoaXMuX19pbml0X18oKTtcbiAgfVxuXG4gIFZpbWVvQmFja2dyb3VuZC5wcm90b3R5cGUuaW5qZWN0UGxheWVyID0gZnVuY3Rpb24gKCkge1xuICAgIHRoaXMuaWZyYW1lID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnaWZyYW1lJyk7XG4gICAgdGhpcy5pZnJhbWUuc2V0QXR0cmlidXRlKCdmcmFtZWJvcmRlcicsIDApO1xuICAgIHRoaXMuaWZyYW1lLnNldEF0dHJpYnV0ZSgnYWxsb3cnLCBbJ2F1dG9wbGF5OyBtdXRlJ10pO1xuICAgIGxldCBzcmMgPSAnaHR0cHM6Ly9wbGF5ZXIudmltZW8uY29tL3ZpZGVvLycrdGhpcy52aWQrJz9iYWNrZ3JvdW5kPTEmY29udHJvbHM9MCc7XG5cbiAgICBpZiAodGhpcy5wYXJhbXMubXV0ZWQpIHtcbiAgICAgIHNyYyArPSAnJm11dGVkPTEnO1xuICAgIH1cblxuICAgIGlmICh0aGlzLnBhcmFtcy5hdXRvcGxheSkge1xuICAgICAgc3JjICs9ICcmYXV0b3BsYXk9MSc7XG4gICAgfVxuXG4gICAgaWYgKHRoaXMucGFyYW1zLmxvb3ApIHtcbiAgICAgIHNyYyArPSAnJmxvb3A9MSZhdXRvcGF1c2U9MCc7XG4gICAgfVxuXG4gICAgLy9XQVJO4p2X77iPIHRoaXMgaXMgYSBoYXNoIG5vdCBhIHF1ZXJ5IHBhcmFtXG4gICAgaWYgKHRoaXMucGFyYW1zWydzdGFydC1hdCddKSB7XG4gICAgICBzcmMgKz0gJyN0PScgKyB0aGlzLnBhcmFtc1snc3RhcnQtYXQnXSArICdzJztcbiAgICB9XG5cbiAgICB0aGlzLmlmcmFtZS5zcmMgPSBzcmM7XG5cbiAgICBpZiAodGhpcy51aWQpIHtcbiAgICAgIHRoaXMuaWZyYW1lLmlkID0gdGhpcy51aWQ7XG4gICAgfVxuXG4gICAgaWYgKHRoaXMucGFyYW1zWydsb2FkLWJhY2tncm91bmQnXSB8fCB0aGlzLnBhcmFtc1sncG9zdGVyJ10pIHtcbiAgICAgIC8vaWYgKHRoaXMucGFyYW1zWydsb2FkLWJhY2tncm91bmQnXSkgd3JhcHBlcl9zdHlsZXNbJ2JhY2tncm91bmQtaW1hZ2UnXSA9ICd1cmwoaHR0cHM6Ly9pbWcueW91dHViZS5jb20vdmkvJyt0aGlzLnl0aWQrJy9tYXhyZXNkZWZhdWx0LmpwZyknO1xuICAgICAgaWYgKHRoaXMucGFyYW1zWydwb3N0ZXInXSkgd3JhcHBlcl9zdHlsZXNbJ2JhY2tncm91bmQtaW1hZ2UnXSA9IHRoaXMucGFyYW1zWydwb3N0ZXInXTtcbiAgICAgIHdyYXBwZXJfc3R5bGVzWydiYWNrZ3JvdW5kLXNpemUnXSA9ICdjb3Zlcic7XG4gICAgICB3cmFwcGVyX3N0eWxlc1snYmFja2dyb3VuZC1yZXBlYXQnXSA9ICduby1yZXBlYXQnO1xuICAgICAgd3JhcHBlcl9zdHlsZXNbJ2JhY2tncm91bmQtcG9zaXRpb24nXSA9ICdjZW50ZXInO1xuICAgIH1cblxuICAgIGlmICh0aGlzLnBhcmFtc1snaW5saW5lLXN0eWxlcyddKSB7XG4gICAgICB0aGlzLmlmcmFtZS5zdHlsZS50b3AgPSAnNTAlJztcbiAgICAgIHRoaXMuaWZyYW1lLnN0eWxlLmxlZnQgPSAnNTAlJztcbiAgICAgIHRoaXMuaWZyYW1lLnN0eWxlLnRyYW5zZm9ybSA9ICd0cmFuc2xhdGVYKC01MCUpIHRyYW5zbGF0ZVkoLTUwJSknO1xuICAgICAgdGhpcy5pZnJhbWUuc3R5bGUucG9zaXRpb24gPSAnYWJzb2x1dGUnO1xuICAgICAgdGhpcy5pZnJhbWUuc3R5bGUub3BhY2l0eSA9IDE7XG4gICAgfVxuXG4gICAgdGhpcy5lbGVtZW50LmFwcGVuZENoaWxkKHRoaXMuaWZyYW1lKTtcblxuICAgIGlmICh0aGlzLnBhcmFtc1snZml0LWJveCddKSB7XG4gICAgICB0aGlzLmlmcmFtZS5zdHlsZS53aWR0aCA9ICcxMDAlJztcbiAgICAgIHRoaXMuaWZyYW1lLnN0eWxlLmhlaWdodCA9ICcxMDAlJztcbiAgICB9IGVsc2Uge1xuICAgICAgY29uc3Qgc2VsZiA9IHRoaXM7XG5cbiAgICAgIGNvbnN0IG9uUmVzaXplID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIGNvbnN0IGggPSBzZWxmLmlmcmFtZS5wYXJlbnROb2RlLm9mZnNldEhlaWdodCArIHNlbGYucGFyYW1zLm9mZnNldDsgLy8gc2luY2Ugc2hvd2luZm8gaXMgZGVwcmVjYXRlZCBhbmQgaWdub3JlZCBhZnRlciBTZXB0ZW1iZXIgMjUsIDIwMTguIHdlIGFkZCArMjAwIHRvIGhpZGUgaXQgaW4gdGhlIG92ZXJmbG93XG4gICAgICAgIGNvbnN0IHcgPSBzZWxmLmlmcmFtZS5wYXJlbnROb2RlLm9mZnNldFdpZHRoICsgc2VsZi5wYXJhbXMub2Zmc2V0O1xuICAgICAgICBjb25zdCByZXMgPSBzZWxmLnBhcmFtcy5yZXNvbHV0aW9uX21vZDtcblxuICAgICAgICBpZiAocmVzID4gdy9oKSB7XG4gICAgICAgICAgc2VsZi5pZnJhbWUuc3R5bGUud2lkdGggPSBoKnJlcyArICdweCc7XG4gICAgICAgICAgc2VsZi5pZnJhbWUuc3R5bGUuaGVpZ2h0ID0gaCArICdweCc7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgc2VsZi5pZnJhbWUuc3R5bGUud2lkdGggPSB3ICsgJ3B4JztcbiAgICAgICAgICBzZWxmLmlmcmFtZS5zdHlsZS5oZWlnaHQgPSB3L3JlcyArICdweCc7XG4gICAgICAgIH1cbiAgICAgIH07XG5cbiAgICAgIGlmICh3aW5kb3cuaGFzT3duUHJvcGVydHkoJ1Jlc2l6ZU9ic2VydmVyJykpIHtcbiAgICAgICAgY29uc3QgcmVzaXplX29ic2VydmVyID0gbmV3IFJlc2l6ZU9ic2VydmVyKCgpID0+IHtcbiAgICAgICAgICB3aW5kb3cucmVxdWVzdEFuaW1hdGlvbkZyYW1lKG9uUmVzaXplKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHJlc2l6ZV9vYnNlcnZlci5vYnNlcnZlKHRoaXMuZWxlbWVudCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcigncmVzaXplJywgKCkgPT4ge1xuICAgICAgICAgIHdpbmRvdy5yZXF1ZXN0QW5pbWF0aW9uRnJhbWUob25SZXNpemUpO1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICAgIG9uUmVzaXplKCk7XG4gICAgfVxuICB9O1xuXG4gIFZpbWVvQmFja2dyb3VuZC5wcm90b3R5cGUuYnVpbGRIVE1MID0gZnVuY3Rpb24gKCkge1xuICAgIGNvbnN0IHBhcmVudCA9IHRoaXMuZWxlbWVudC5wYXJlbnROb2RlO1xuICAgIC8vIHdyYXBcbiAgICBhZGRDbGFzcyh0aGlzLmVsZW1lbnQsICd5b3V0dWJlLWJhY2tncm91bmQnKTtcblxuICAgIC8vc2V0IGNzcyBydWxlc1xuICAgIGNvbnN0IHdyYXBwZXJfc3R5bGVzID0ge1xuICAgICAgXCJoZWlnaHRcIiA6IFwiMTAwJVwiLFxuICAgICAgXCJ3aWR0aFwiIDogXCIxMDAlXCIsXG4gICAgICBcInotaW5kZXhcIjogXCIwXCIsXG4gICAgICBcInBvc2l0aW9uXCI6IFwiYWJzb2x1dGVcIixcbiAgICAgIFwib3ZlcmZsb3dcIjogXCJoaWRkZW5cIixcbiAgICAgIFwidG9wXCI6IDAsIC8vIGFkZGVkIGJ5IEBpbnNhZFxuICAgICAgXCJsZWZ0XCI6IDAsXG4gICAgICBcImJvdHRvbVwiOiAwLFxuICAgICAgXCJyaWdodFwiOiAwXG4gICAgfTtcblxuICAgIGlmICh0aGlzLnBhcmFtc1snbG9hZC1iYWNrZ3JvdW5kJ10gfHwgdGhpcy5wYXJhbXNbJ3Bvc3RlciddKSB7XG4gICAgICAvL2lmICh0aGlzLnBhcmFtc1snbG9hZC1iYWNrZ3JvdW5kJ10pIHdyYXBwZXJfc3R5bGVzWydiYWNrZ3JvdW5kLWltYWdlJ10gPSAndXJsKGh0dHBzOi8vaW1nLnlvdXR1YmUuY29tL3ZpLycrdGhpcy55dGlkKycvbWF4cmVzZGVmYXVsdC5qcGcpJztcbiAgICAgIGlmICh0aGlzLnBhcmFtc1sncG9zdGVyJ10pIHdyYXBwZXJfc3R5bGVzWydiYWNrZ3JvdW5kLWltYWdlJ10gPSB0aGlzLnBhcmFtc1sncG9zdGVyJ107XG4gICAgICB3cmFwcGVyX3N0eWxlc1snYmFja2dyb3VuZC1zaXplJ10gPSAnY292ZXInO1xuICAgICAgd3JhcHBlcl9zdHlsZXNbJ2JhY2tncm91bmQtcmVwZWF0J10gPSAnbm8tcmVwZWF0JztcbiAgICAgIHdyYXBwZXJfc3R5bGVzWydiYWNrZ3JvdW5kLXBvc2l0aW9uJ10gPSAnY2VudGVyJztcbiAgICB9XG5cbiAgICBpZiAoIXRoaXMucGFyYW1zWydtdXRlLWJ1dHRvbiddKSB7XG4gICAgICB3cmFwcGVyX3N0eWxlc1tcInBvaW50ZXItZXZlbnRzXCJdID0gXCJub25lXCI7IC8vIGF2b2lkIHJpZ2h0IG1vdXNlIGNsaWNrIHBvcHVwIG1lbnVcbiAgICB9XG5cbiAgICBpZiAodGhpcy5wYXJhbXNbJ2xvYWQtYmFja2dyb3VuZCddKSB7XG4gICAgICAvL1RPRE86IHdyYXBwZXJfc3R5bGVzWydiYWNrZ3JvdW5kLWltYWdlJ10gPSAndXJsKGh0dHBzOi8vaW1nLnlvdXR1YmUuY29tL3ZpLycrdGhpcy52aWQrJy9tYXhyZXNkZWZhdWx0LmpwZyknO1xuICAgICAgd3JhcHBlcl9zdHlsZXNbJ2JhY2tncm91bmQtc2l6ZSddID0gJ2NvdmVyJztcbiAgICAgIHdyYXBwZXJfc3R5bGVzWydiYWNrZ3JvdW5kLXJlcGVhdCddID0gJ25vLXJlcGVhdCc7XG4gICAgICB3cmFwcGVyX3N0eWxlc1snYmFja2dyb3VuZC1wb3NpdGlvbiddID0gJ2NlbnRlcic7XG4gICAgfVxuXG4gICAgaWYgKHRoaXMucGFyYW1zWydpbmxpbmUtc3R5bGVzJ10pIHtcbiAgICAgIGZvciAobGV0IHByb3BlcnR5IGluIHdyYXBwZXJfc3R5bGVzKSB7XG4gICAgICAgIHRoaXMuZWxlbWVudC5zdHlsZVtwcm9wZXJ0eV0gPSB3cmFwcGVyX3N0eWxlc1twcm9wZXJ0eV07XG4gICAgICB9XG5cbiAgICAgIGlmICghWydhYnNvbHV0ZScsICdmaXhlZCcsICdyZWxhdGl2ZScsICdzdGlja3knXS5pbmRleE9mKHBhcmVudC5zdHlsZS5wb3NpdGlvbikpIHtcbiAgICAgICAgcGFyZW50LnN0eWxlLnBvc2l0aW9uID0gJ3JlbGF0aXZlJztcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcy5lbGVtZW50O1xuICB9O1xuXG4gIGZ1bmN0aW9uIFZpZGVvQmFja2dyb3VuZChlbGVtLCBwYXJhbXMsIHZpZF9kYXRhLCB1aWQpIHtcbiAgICB0aGlzLmlzX21vYmlsZSA9IGlzTW9iaWxlKCk7XG5cbiAgICB0aGlzLmVsZW1lbnQgPSBlbGVtO1xuICAgIHRoaXMubGluayA9IHZpZF9kYXRhLmxpbms7XG4gICAgdGhpcy5leHQgPSB2aWRfZGF0YS5pZDtcbiAgICB0aGlzLnVpZCA9IHVpZDtcbiAgICB0aGlzLnBsYXllciA9IG51bGw7XG4gICAgdGhpcy5idXR0b25zID0ge307XG5cbiAgICB0aGlzLnN0YXRlID0ge307XG4gICAgdGhpcy5zdGF0ZS5wbGF5ID0gZmFsc2U7XG4gICAgdGhpcy5zdGF0ZS5tdXRlID0gZmFsc2U7XG5cbiAgICB0aGlzLnBhcmFtcyA9IHt9O1xuXG4gICAgY29uc3QgTUlNRV9NQVAgPSB7XG4gICAgICAnb2d2JyA6ICd2aWRlby9vZ2cnLFxuICAgICAgJ29nbScgOiAndmlkZW8vb2dnJyxcbiAgICAgICdvZ2cnIDogJ3ZpZGVvL29nZycsXG4gICAgICAnYXZpJyA6ICd2aWRlby9hdmknLFxuICAgICAgJ21wNCcgOiAndmlkZW8vbXA0JyxcbiAgICAgICd3ZWJtJyA6ICd2aWRlby93ZWJtJ1xuICAgIH07XG5cbiAgICBjb25zdCBERUZBVUxUUyA9IHtcbiAgICAgICdwYXVzZSc6IGZhbHNlLCAvL2RlcHJlY2F0ZWRcbiAgICAgICdwbGF5LWJ1dHRvbic6IGZhbHNlLFxuICAgICAgJ211dGUtYnV0dG9uJzogZmFsc2UsXG4gICAgICAnYXV0b3BsYXknOiB0cnVlLFxuICAgICAgJ211dGVkJzogdHJ1ZSxcbiAgICAgICdsb29wJzogdHJ1ZSxcbiAgICAgICdtb2JpbGUnOiBmYWxzZSxcbiAgICAgICdyZXNvbHV0aW9uJzogJzE2OjknLFxuICAgICAgJ2lubGluZS1zdHlsZXMnOiB0cnVlLFxuICAgICAgJ2ZpdC1ib3gnOiBmYWxzZSxcbiAgICAgICdvZmZzZXQnOiAyMDAsXG4gIC8vICAgICdzdGFydC1hdCc6IDAsXG4gIC8vICAgICdlbmQtYXQnOiAwLFxuICAgICAgJ3Bvc3Rlcic6IG51bGxcbiAgICB9O1xuXG4gICAgdGhpcy5fX2luaXRfXyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIGlmICghdGhpcy5saW5rIHx8ICF0aGlzLmV4dCkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIHRoaXMubWltZSA9IE1JTUVfTUFQW3RoaXMuZXh0LnRvTG93ZXJDYXNlKCldO1xuICAgICAgdGhpcy5wYXJhbXMgPSBwYXJzZVByb3BlcnRpZXMocGFyYW1zLCBERUZBVUxUUywgdGhpcy5lbGVtZW50LCBbJ2RhdGEteXRiZy0nLCAnZGF0YS12YmctJ10pO1xuICAgICAgLy9wYXVzZSBkZXByZWNhdGVkXG4gICAgICBpZiAodGhpcy5wYXJhbXMucGF1c2UpIHtcbiAgICAgICAgdGhpcy5wYXJhbXNbJ3BsYXktYnV0dG9uJ10gPSB0aGlzLnBhcmFtcy5wYXVzZTtcbiAgICAgIH1cbiAgICAgIHRoaXMucGFyYW1zLnJlc29sdXRpb25fbW9kID0gcGFyc2VSZXNvbHV0aW9uU3RyaW5nKHRoaXMucGFyYW1zLnJlc29sdXRpb24pO1xuICAgICAgdGhpcy5zdGF0ZS5wbGF5aW5nID0gdGhpcy5wYXJhbXMuYXV0b3BsYXk7XG4gICAgICB0aGlzLnN0YXRlLm11dGVkID0gdGhpcy5wYXJhbXMubXV0ZWQ7XG5cbiAgICAgIHRoaXMuYnVpbGRIVE1MKCk7XG4gICAgICB0aGlzLmluamVjdFBsYXllcigpO1xuXG5cbiAgICAgIGlmICh0aGlzLnBhcmFtc1sncGxheS1idXR0b24nXSkge1xuICAgICAgICB0aGlzLmdlbmVyYXRlQWN0aW9uQnV0dG9uKHtcbiAgICAgICAgICBuYW1lOiAncGxheScsXG4gICAgICAgICAgY2xhc3NOYW1lOiAncGxheS10b2dnbGUnLFxuICAgICAgICAgIGlubmVySHRtbDogJzxpIGNsYXNzPVwiZmFcIj48L2k+JyxcbiAgICAgICAgICBpbml0aWFsU3RhdGU6IGZhbHNlLFxuICAgICAgICAgIHN0YXRlQ2xhc3NOYW1lOiAncGF1c2VkJyxcbiAgICAgICAgICBjb25kaXRpb25fcGFyYW1ldGVyOiAnYXV0b3BsYXknLFxuICAgICAgICAgIHN0YXRlQ2hpbGRDbGFzc05hbWVzOiBbJ2ZhLXBhdXNlLWNpcmNsZScsICdmYS1wbGF5LWNpcmNsZSddLFxuICAgICAgICAgIGFjdGlvbnM6IFsncGxheScsICdwYXVzZSddXG4gICAgICAgIH0pO1xuICAgICAgfVxuXG4gICAgICBpZiAodGhpcy5wYXJhbXNbJ211dGUtYnV0dG9uJ10pIHtcbiAgICAgICAgdGhpcy5nZW5lcmF0ZUFjdGlvbkJ1dHRvbih7XG4gICAgICAgICAgbmFtZTogJ211dGUnLFxuICAgICAgICAgIGNsYXNzTmFtZTogJ211dGUtdG9nZ2xlJyxcbiAgICAgICAgICBpbm5lckh0bWw6ICc8aSBjbGFzcz1cImZhXCI+PC9pPicsXG4gICAgICAgICAgaW5pdGlhbFN0YXRlOiB0cnVlLFxuICAgICAgICAgIHN0YXRlQ2xhc3NOYW1lOiAnbXV0ZWQnLFxuICAgICAgICAgIGNvbmRpdGlvbl9wYXJhbWV0ZXI6ICdtdXRlZCcsXG4gICAgICAgICAgc3RhdGVDaGlsZENsYXNzTmFtZXM6IFsnZmEtdm9sdW1lLXVwJywgJ2ZhLXZvbHVtZS1tdXRlJ10sXG4gICAgICAgICAgYWN0aW9uczogWyd1bm11dGUnLCAnbXV0ZSddXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH07XG5cbiAgICB0aGlzLl9faW5pdF9fKCk7XG4gIH1cblxuICBWaWRlb0JhY2tncm91bmQucHJvdG90eXBlLnNlZWtUbyA9IGZ1bmN0aW9uIChzZWNvbmRzKSB7XG4gICAgaWYgKHRoaXMucGxheWVyLmhhc093blByb3BlcnR5KCdmYXN0U2VlaycpKSB7XG4gICAgICB0aGlzLnBsYXllci5mYXN0U2VlayhzZWNvbmRzKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdGhpcy5wbGF5ZXIuY3VycmVudFRpbWUgPSBzZWNvbmRzO1xuICB9O1xuXG4gIFZpZGVvQmFja2dyb3VuZC5wcm90b3R5cGUuaW5qZWN0UGxheWVyID0gZnVuY3Rpb24gKCkge1xuICAgIHRoaXMucGxheWVyID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgndmlkZW8nKTtcbiAgICB0aGlzLnBsYXllci5tdXRlZCA9IHRoaXMucGFyYW1zLm11dGVkO1xuICAgIHRoaXMucGxheWVyLmF1dG9wbGF5ID0gdGhpcy5wYXJhbXMuYXV0b3BsYXk7XG4gICAgdGhpcy5wbGF5ZXIubG9vcCA9IHRoaXMucGFyYW1zLmxvb3A7XG4gICAgdGhpcy5wbGF5ZXIucGxheXNpbmxpbmUgPSB0cnVlO1xuXG4gICAgdGhpcy5wbGF5ZXIuc2V0QXR0cmlidXRlKCdpZCcsIHRoaXMudWlkKTtcblxuICAgIGlmICh0aGlzLnBhcmFtc1snaW5saW5lLXN0eWxlcyddKSB7XG4gICAgICB0aGlzLnBsYXllci5zdHlsZS50b3AgPSAnNTAlJztcbiAgICAgIHRoaXMucGxheWVyLnN0eWxlLmxlZnQgPSAnNTAlJztcbiAgICAgIHRoaXMucGxheWVyLnN0eWxlLnRyYW5zZm9ybSA9ICd0cmFuc2xhdGVYKC01MCUpIHRyYW5zbGF0ZVkoLTUwJSknO1xuICAgICAgdGhpcy5wbGF5ZXIuc3R5bGUucG9zaXRpb24gPSAnYWJzb2x1dGUnO1xuICAgICAgdGhpcy5wbGF5ZXIuc3R5bGUub3BhY2l0eSA9IDA7XG5cbiAgICAgIHRoaXMucGxheWVyLmFkZEV2ZW50TGlzdGVuZXIoJ2NhbnBsYXknLCAoZSkgPT4ge1xuICAgICAgICBlLnRhcmdldC5zdHlsZS5vcGFjaXR5ID0gMTtcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIGNvbnN0IHNlbGYgPSB0aGlzO1xuICAgIC8qXG4gICAgdGhpcy5wbGF5ZXIuYWRkRXZlbnRMaXN0ZW5lcignY2FucGxheScsIChlKSA9PiB7XG4gICAgICBpZiAoc2VsZi5wYXJhbXNbJ3N0YXJ0LWF0J10gJiYgc2VsZi5wYXJhbXMuYXV0b3BsYXkpIHtcbiAgICAgICAgc2VsZi5zZWVrVG8oc2VsZi5wYXJhbXNbJ3N0YXJ0LWF0J10pO1xuICAgICAgfVxuICAgIH0pO1xuXG4gICAgdGhpcy5wbGF5ZXIuYWRkRXZlbnRMaXN0ZW5lcignY2FucGxheXRocm91Z2gnLCAoZSkgPT4ge1xuICAgICAgaWYgKHNlbGYucGFyYW1zWydlbmQtYXQnXSA+IDApIHtcbiAgICAgIHNlbGYucGxheWVyLmFkZEV2ZW50TGlzdGVuZXIoJ3RpbWV1cGRhdGUnLCAoZSkgPT4ge1xuICAgICAgICBpZiAoc2VsZi5wYXJhbXNbJ2VuZC1hdCddID49IHNlbGYucGxheWVyLmN1cnJlbnRUaW1lKSB7XG4gICAgICAgICAgc2VsZi5zZWVrVG8oc2VsZi5wYXJhbXNbJ3N0YXJ0LWF0J10pO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9XG4gICAgfSk7XG4gICAgKi9cblxuICAgIGNvbnN0IHNvdXJjZSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3NvdXJjZScpO1xuICAgIHNvdXJjZS5zZXRBdHRyaWJ1dGUoJ3NyYycsIHRoaXMubGluayk7XG4gICAgc291cmNlLnNldEF0dHJpYnV0ZSgndHlwZScsIHRoaXMubWltZSk7XG4gICAgdGhpcy5wbGF5ZXIuYXBwZW5kQ2hpbGQoc291cmNlKTtcbiAgICB0aGlzLmVsZW1lbnQuYXBwZW5kQ2hpbGQodGhpcy5wbGF5ZXIpO1xuXG4gICAgaWYgKHRoaXMucGFyYW1zWydmaXQtYm94J10pIHtcbiAgICAgIHRoaXMucGxheWVyLnN0eWxlLndpZHRoID0gJzEwMCUnO1xuICAgICAgdGhpcy5wbGF5ZXIuc3R5bGUuaGVpZ2h0ID0gJzEwMCUnO1xuICAgIH0gZWxzZSB7XG4gICAgICAvL1RPRE/inZfvuI86IG1heWJlIGEgc3BhY2VyIG9yIGF0IGxlYXN0IGFkZCByZXF1ZXN0QW5pbWF0aW9uRnJhbWVcbiAgICAgIGZ1bmN0aW9uIG9uUmVzaXplKCkge1xuICAgICAgICBjb25zdCBoID0gc2VsZi5wbGF5ZXIucGFyZW50Tm9kZS5vZmZzZXRIZWlnaHQgKyBzZWxmLnBhcmFtcy5vZmZzZXQ7IC8vIHNpbmNlIHNob3dpbmZvIGlzIGRlcHJlY2F0ZWQgYW5kIGlnbm9yZWQgYWZ0ZXIgU2VwdGVtYmVyIDI1LCAyMDE4LiB3ZSBhZGQgKzIwMCB0byBoaWRlIGl0IGluIHRoZSBvdmVyZmxvd1xuICAgICAgICBjb25zdCB3ID0gc2VsZi5wbGF5ZXIucGFyZW50Tm9kZS5vZmZzZXRXaWR0aCArIHNlbGYucGFyYW1zLm9mZnNldDtcbiAgICAgICAgY29uc3QgcmVzID0gc2VsZi5wYXJhbXMucmVzb2x1dGlvbl9tb2Q7XG5cbiAgICAgICAgaWYgKHJlcyA+IHcvaCkge1xuICAgICAgICAgIHNlbGYucGxheWVyLnN0eWxlLndpZHRoID0gaCpyZXMgKyAncHgnO1xuICAgICAgICAgIHNlbGYucGxheWVyLnN0eWxlLmhlaWdodCA9IGggKyAncHgnO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHNlbGYucGxheWVyLnN0eWxlLndpZHRoID0gdyArICdweCc7XG4gICAgICAgICAgc2VsZi5wbGF5ZXIuc3R5bGUuaGVpZ2h0ID0gdy9yZXMgKyAncHgnO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmICh3aW5kb3cuaGFzT3duUHJvcGVydHkoJ1Jlc2l6ZU9ic2VydmVyJykpIHtcbiAgICAgICAgY29uc3QgcmVzaXplX29ic2VydmVyID0gbmV3IFJlc2l6ZU9ic2VydmVyKCgpID0+IHtcbiAgICAgICAgICB3aW5kb3cucmVxdWVzdEFuaW1hdGlvbkZyYW1lKG9uUmVzaXplKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHJlc2l6ZV9vYnNlcnZlci5vYnNlcnZlKHRoaXMuZWxlbWVudCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcigncmVzaXplJywgKCkgPT4ge1xuICAgICAgICAgIHdpbmRvdy5yZXF1ZXN0QW5pbWF0aW9uRnJhbWUob25SZXNpemUpO1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICAgIG9uUmVzaXplKCk7XG4gICAgfVxuICB9O1xuXG4gIFZpZGVvQmFja2dyb3VuZC5wcm90b3R5cGUuYnVpbGRIVE1MID0gZnVuY3Rpb24gKCkge1xuICAgIGNvbnN0IHBhcmVudCA9IHRoaXMuZWxlbWVudC5wYXJlbnROb2RlO1xuICAgIC8vIHdyYXBcbiAgICBhZGRDbGFzcyh0aGlzLmVsZW1lbnQsICd2aWRlby1iYWNrZ3JvdW5kJyk7XG5cbiAgICAvL3NldCBjc3MgcnVsZXNcbiAgICBjb25zdCB3cmFwcGVyX3N0eWxlcyA9IHtcbiAgICAgIFwiaGVpZ2h0XCIgOiBcIjEwMCVcIixcbiAgICAgIFwid2lkdGhcIiA6IFwiMTAwJVwiLFxuICAgICAgXCJ6LWluZGV4XCI6IFwiMFwiLFxuICAgICAgXCJwb3NpdGlvblwiOiBcImFic29sdXRlXCIsXG4gICAgICBcIm92ZXJmbG93XCI6IFwiaGlkZGVuXCIsXG4gICAgICBcInRvcFwiOiAwLCAvLyBhZGRlZCBieSBAaW5zYWRcbiAgICAgIFwibGVmdFwiOiAwLFxuICAgICAgXCJib3R0b21cIjogMCxcbiAgICAgIFwicmlnaHRcIjogMFxuICAgIH07XG5cbiAgICBpZiAoIXRoaXMucGFyYW1zWydtdXRlLWJ1dHRvbiddKSB7XG4gICAgICB3cmFwcGVyX3N0eWxlc1tcInBvaW50ZXItZXZlbnRzXCJdID0gXCJub25lXCI7IC8vIGF2b2lkIHJpZ2h0IG1vdXNlIGNsaWNrIHBvcHVwIG1lbnVcbiAgICB9XG5cbiAgICBpZiAodGhpcy5wYXJhbXNbJ2xvYWQtYmFja2dyb3VuZCddIHx8IHRoaXMucGFyYW1zWydwb3N0ZXInXSkge1xuICAgICAgaWYgKHRoaXMucGFyYW1zWydwb3N0ZXInXSkgd3JhcHBlcl9zdHlsZXNbJ2JhY2tncm91bmQtaW1hZ2UnXSA9IGB1cmwoJyR7dGhpcy5wYXJhbXNbJ3Bvc3RlciddfScpYDtcbiAgICAgIHdyYXBwZXJfc3R5bGVzWydiYWNrZ3JvdW5kLXNpemUnXSA9ICdjb3Zlcic7XG4gICAgICB3cmFwcGVyX3N0eWxlc1snYmFja2dyb3VuZC1yZXBlYXQnXSA9ICduby1yZXBlYXQnO1xuICAgICAgd3JhcHBlcl9zdHlsZXNbJ2JhY2tncm91bmQtcG9zaXRpb24nXSA9ICdjZW50ZXInO1xuICAgIH1cblxuICAgIGlmICh0aGlzLnBhcmFtc1snaW5saW5lLXN0eWxlcyddKSB7XG4gICAgICBmb3IgKGxldCBwcm9wZXJ0eSBpbiB3cmFwcGVyX3N0eWxlcykge1xuICAgICAgICB0aGlzLmVsZW1lbnQuc3R5bGVbcHJvcGVydHldID0gd3JhcHBlcl9zdHlsZXNbcHJvcGVydHldO1xuICAgICAgfVxuXG4gICAgICBpZiAoIVsnYWJzb2x1dGUnLCAnZml4ZWQnLCAncmVsYXRpdmUnLCAnc3RpY2t5J10uaW5kZXhPZihwYXJlbnQuc3R5bGUucG9zaXRpb24pKSB7XG4gICAgICAgIHBhcmVudC5zdHlsZS5wb3NpdGlvbiA9ICdyZWxhdGl2ZSc7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKHRoaXMuaXNfbW9iaWxlICYmICF0aGlzLnBhcmFtcy5tb2JpbGUpIHtcbiAgICAgIHJldHVybiB0aGlzLmVsZW1lbnQ7XG4gICAgfVxuXG4gICAgLy8gc2V0IHBsYXkvbXV0ZSBjb250cm9scyB3cmFwXG4gICAgaWYgKHRoaXMucGFyYW1zWydwbGF5LWJ1dHRvbiddIHx8IHRoaXMucGFyYW1zWydtdXRlLWJ1dHRvbiddKSB7XG4gICAgICBjb25zdCBjb250cm9scyA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgICAgY29udHJvbHMuY2xhc3NOYW1lID0gJ3ZpZGVvLWJhY2tncm91bmQtY29udHJvbHMnO1xuXG4gICAgICBjb250cm9scy5zdHlsZS5wb3NpdGlvbiA9ICdhYnNvbHV0ZSc7XG4gICAgICBjb250cm9scy5zdHlsZS50b3AgPSAnMTBweCc7XG4gICAgICBjb250cm9scy5zdHlsZS5yaWdodCA9ICcxMHB4JztcbiAgICAgIGNvbnRyb2xzLnN0eWxlWyd6LWluZGV4J10gPSAyO1xuXG4gICAgICB0aGlzLmNvbnRyb2xzX2VsZW1lbnQgPSBjb250cm9scztcbiAgICAgIHBhcmVudC5hcHBlbmRDaGlsZChjb250cm9scyk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXMuZWxlbWVudDtcbiAgfTtcblxuICBWaWRlb0JhY2tncm91bmQucHJvdG90eXBlLnBsYXkgPSBmdW5jdGlvbiAoKSB7XG4gICAgLy9UT0RPOiBzb2x2ZSB0aGlzIHdpdGggQVJJQSB0b2dnbGUgc3RhdGVzLiBQLlMuIHdhcm5pbmcgcmVwZXRpdGl2ZSBjb2RlISEhXG4gICAgaWYgKHRoaXMuYnV0dG9ucy5oYXNPd25Qcm9wZXJ0eSgncGxheScpKSB7XG4gICAgICBjb25zdCBidG5fb2JqID0gdGhpcy5idXR0b25zLnBsYXk7XG4gICAgICByZW1vdmVDbGFzcyhidG5fb2JqLmVsZW1lbnQsIGJ0bl9vYmouYnV0dG9uX3Byb3BlcnRpZXMuc3RhdGVDbGFzc05hbWUpO1xuICAgICAgYWRkQ2xhc3MoYnRuX29iai5lbGVtZW50LmZpcnN0Q2hpbGQsIGJ0bl9vYmouYnV0dG9uX3Byb3BlcnRpZXMuc3RhdGVDaGlsZENsYXNzTmFtZXNbMF0pO1xuICAgICAgcmVtb3ZlQ2xhc3MoYnRuX29iai5lbGVtZW50LmZpcnN0Q2hpbGQsIGJ0bl9vYmouYnV0dG9uX3Byb3BlcnRpZXMuc3RhdGVDaGlsZENsYXNzTmFtZXNbMV0pO1xuICAgIH1cblxuICAgIGlmICh0aGlzLnBsYXllcikge1xuICAgICAgLyogaWYgKHRoaXMucGFyYW1zWydzdGFydC1hdCddICYmIHRoaXMucGxheWVyLmN1cnJlbnRUaW1lIDwgdGhpcy5wYXJhbXNbJ3N0YXJ0LWF0J10gKSB7XG4gICAgICAgIHRoaXMuc2Vla1RvKHRoaXMucGFyYW1zWydzdGFydC1hdCddKTtcbiAgICAgIH0gKi9cbiAgICAgIHRoaXMucGxheWVyLnBsYXkoKTtcbiAgICAgIHRoaXMuZWxlbWVudC5kaXNwYXRjaEV2ZW50KG5ldyBDdXN0b21FdmVudCgndmlkZW8tYmFja2dyb3VuZC1wbGF5JywgeyBidWJibGVzOiB0cnVlLCBkZXRhaWw6IHRoaXMgfSkpO1xuICAgIH1cbiAgfTtcblxuICBWaWRlb0JhY2tncm91bmQucHJvdG90eXBlLnBhdXNlID0gZnVuY3Rpb24gKCkge1xuICAgIC8vVE9ETzogc29sdmUgdGhpcyB3aXRoIEFSSUEgdG9nZ2xlIHN0YXRlc1xuICAgIGlmICh0aGlzLmJ1dHRvbnMuaGFzT3duUHJvcGVydHkoJ3BsYXknKSkge1xuICAgICAgY29uc3QgYnRuX29iaiA9IHRoaXMuYnV0dG9ucy5wbGF5O1xuICAgICAgYWRkQ2xhc3MoYnRuX29iai5lbGVtZW50LCBidG5fb2JqLmJ1dHRvbl9wcm9wZXJ0aWVzLnN0YXRlQ2xhc3NOYW1lKTtcbiAgICAgIHJlbW92ZUNsYXNzKGJ0bl9vYmouZWxlbWVudC5maXJzdENoaWxkLCBidG5fb2JqLmJ1dHRvbl9wcm9wZXJ0aWVzLnN0YXRlQ2hpbGRDbGFzc05hbWVzWzBdKTtcbiAgICAgIGFkZENsYXNzKGJ0bl9vYmouZWxlbWVudC5maXJzdENoaWxkLCBidG5fb2JqLmJ1dHRvbl9wcm9wZXJ0aWVzLnN0YXRlQ2hpbGRDbGFzc05hbWVzWzFdKTtcbiAgICB9XG5cbiAgICBpZiAodGhpcy5wbGF5ZXIpIHtcbiAgICAgIHRoaXMucGxheWVyLnBhdXNlKCk7XG4gICAgICB0aGlzLmVsZW1lbnQuZGlzcGF0Y2hFdmVudChuZXcgQ3VzdG9tRXZlbnQoJ3ZpZGVvLWJhY2tncm91bmQtcGF1c2UnLCB7IGJ1YmJsZXM6IHRydWUsIGRldGFpbDogdGhpcyB9KSk7XG4gICAgfVxuICB9O1xuXG4gIFZpZGVvQmFja2dyb3VuZC5wcm90b3R5cGUudW5tdXRlID0gZnVuY3Rpb24gKCkge1xuICAgIC8vVE9ETzogc29sdmUgdGhpcyB3aXRoIEFSSUEgdG9nZ2xlIHN0YXRlc1xuICAgIGlmICh0aGlzLmJ1dHRvbnMuaGFzT3duUHJvcGVydHkoJ211dGUnKSkge1xuICAgICAgY29uc3QgYnRuX29iaiA9IHRoaXMuYnV0dG9ucy5tdXRlO1xuICAgICAgcmVtb3ZlQ2xhc3MoYnRuX29iai5lbGVtZW50LCBidG5fb2JqLmJ1dHRvbl9wcm9wZXJ0aWVzLnN0YXRlQ2xhc3NOYW1lKTtcbiAgICAgIGFkZENsYXNzKGJ0bl9vYmouZWxlbWVudC5maXJzdENoaWxkLCBidG5fb2JqLmJ1dHRvbl9wcm9wZXJ0aWVzLnN0YXRlQ2hpbGRDbGFzc05hbWVzWzBdKTtcbiAgICAgIHJlbW92ZUNsYXNzKGJ0bl9vYmouZWxlbWVudC5maXJzdENoaWxkLCBidG5fb2JqLmJ1dHRvbl9wcm9wZXJ0aWVzLnN0YXRlQ2hpbGRDbGFzc05hbWVzWzFdKTtcbiAgICB9XG5cbiAgICBpZiAodGhpcy5wbGF5ZXIpIHtcbiAgICAgIHRoaXMucGxheWVyLm11dGVkID0gZmFsc2U7XG4gICAgICB0aGlzLmVsZW1lbnQuZGlzcGF0Y2hFdmVudChuZXcgQ3VzdG9tRXZlbnQoJ3ZpZGVvLWJhY2tncm91bmQtdW5tdXRlJywgeyBidWJibGVzOiB0cnVlLCBkZXRhaWw6IHRoaXMgfSkpO1xuICAgIH1cbiAgfTtcblxuICBWaWRlb0JhY2tncm91bmQucHJvdG90eXBlLm11dGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgLy9UT0RPOiBzb2x2ZSB0aGlzIHdpdGggQVJJQSB0b2dnbGUgc3RhdGVzXG4gICAgaWYgKHRoaXMuYnV0dG9ucy5oYXNPd25Qcm9wZXJ0eSgnbXV0ZScpKSB7XG4gICAgICBjb25zdCBidG5fb2JqID0gdGhpcy5idXR0b25zLm11dGU7XG4gICAgICBhZGRDbGFzcyhidG5fb2JqLmVsZW1lbnQsIGJ0bl9vYmouYnV0dG9uX3Byb3BlcnRpZXMuc3RhdGVDbGFzc05hbWUpO1xuICAgICAgcmVtb3ZlQ2xhc3MoYnRuX29iai5lbGVtZW50LmZpcnN0Q2hpbGQsIGJ0bl9vYmouYnV0dG9uX3Byb3BlcnRpZXMuc3RhdGVDaGlsZENsYXNzTmFtZXNbMF0pO1xuICAgICAgYWRkQ2xhc3MoYnRuX29iai5lbGVtZW50LmZpcnN0Q2hpbGQsIGJ0bl9vYmouYnV0dG9uX3Byb3BlcnRpZXMuc3RhdGVDaGlsZENsYXNzTmFtZXNbMV0pO1xuICAgIH1cblxuICAgIGlmICh0aGlzLnBsYXllcikge1xuICAgICAgdGhpcy5wbGF5ZXIubXV0ZWQgPSB0cnVlO1xuICAgICAgdGhpcy5lbGVtZW50LmRpc3BhdGNoRXZlbnQobmV3IEN1c3RvbUV2ZW50KCd2aWRlby1iYWNrZ3JvdW5kLW11dGUnLCB7IGJ1YmJsZXM6IHRydWUsIGRldGFpbDogdGhpcyB9KSk7XG4gICAgfVxuICB9O1xuXG4gIC8vVE9ETzogcmVmYWN0b3Igc3RhdGVzIHRvIGJlIGVxdWFsIGZvciBhbGwgYnV0dG9uc1xuICBWaWRlb0JhY2tncm91bmQucHJvdG90eXBlLmdlbmVyYXRlQWN0aW9uQnV0dG9uID0gZnVuY3Rpb24gKG9iaikge1xuICAgIGNvbnN0IGJ0biA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2J1dHRvbicpO1xuICAgIGJ0bi5jbGFzc05hbWUgPSBvYmouY2xhc3NOYW1lO1xuICAgIGJ0bi5pbm5lckhUTUwgPSBvYmouaW5uZXJIdG1sO1xuICAgIGFkZENsYXNzKGJ0bi5maXJzdENoaWxkLCBvYmouc3RhdGVDaGlsZENsYXNzTmFtZXNbMF0pO1xuXG4gICAgLy9UT0RPOiBzb2x2ZSB0aGlzIHdpdGggQVJJQSB0b2dnbGUgc3RhdGVzXG4gICAgaWYgKHRoaXMucGFyYW1zW29iai5jb25kaXRpb25fcGFyYW1ldGVyXSA9PT0gb2JqLmluaXRpYWxTdGF0ZSkge1xuICAgICAgYWRkQ2xhc3MoYnRuLCBvYmouc3RhdGVDbGFzc05hbWUpO1xuICAgICAgcmVtb3ZlQ2xhc3MoYnRuLmZpcnN0Q2hpbGQsIG9iai5zdGF0ZUNoaWxkQ2xhc3NOYW1lc1swXSk7XG4gICAgICBhZGRDbGFzcyhidG4uZmlyc3RDaGlsZCwgb2JqLnN0YXRlQ2hpbGRDbGFzc05hbWVzWzFdKTtcbiAgICB9XG5cbiAgICBjb25zdCBzZWxmID0gdGhpcztcbiAgICBidG4uYWRkRXZlbnRMaXN0ZW5lcignY2xpY2snLCBmdW5jdGlvbihlKSB7XG4gICAgICBpZiAoaGFzQ2xhc3ModGhpcywgb2JqLnN0YXRlQ2xhc3NOYW1lKSkge1xuICAgICAgICBzZWxmLnN0YXRlW29iai5uYW1lXSA9IGZhbHNlO1xuICAgICAgICBzZWxmW29iai5hY3Rpb25zWzBdXSgpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgc2VsZi5zdGF0ZVtvYmoubmFtZV0gPSB0cnVlO1xuICAgICAgICBzZWxmW29iai5hY3Rpb25zWzFdXSgpO1xuICAgICAgfVxuICAgIH0pO1xuXG4gICAgdGhpcy5idXR0b25zW29iai5uYW1lXSA9IHtcbiAgICAgIGVsZW1lbnQ6IGJ0bixcbiAgICAgIGJ1dHRvbl9wcm9wZXJ0aWVzOiBvYmpcbiAgICB9O1xuXG4gICAgdGhpcy5jb250cm9sc19lbGVtZW50LmFwcGVuZENoaWxkKGJ0bik7XG4gIH07XG5cbiAgZnVuY3Rpb24gVmlkZW9CYWNrZ3JvdW5kcyhzZWxlY3RvciwgcGFyYW1zKSB7XG4gICAgdGhpcy5lbGVtZW50cyA9IHNlbGVjdG9yO1xuXG4gICAgaWYgKHR5cGVvZiBzZWxlY3RvciA9PT0gJ3N0cmluZycpIHtcbiAgICAgIHRoaXMuZWxlbWVudHMgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yQWxsKHNlbGVjdG9yKTtcbiAgICB9XG5cbiAgICB0aGlzLmluZGV4ID0ge307XG4gICAgdGhpcy5yZSA9IHt9O1xuICAgIHRoaXMucmUuWU9VVFVCRSA9IC8oPzp5b3V0dWJlXFwuY29tXFwvKD86W15cXC9dK1xcLy4rXFwvfCg/OnZ8ZSg/Om1iZWQpPylcXC98LipbPyZddj0pfHlvdXR1XFwuYmVcXC8pKFteXCImP1xcLyBdezExfSkvaTtcbiAgICB0aGlzLnJlLlZJTUVPID0gLyg/Ond3d1xcLnxwbGF5ZXJcXC4pP3ZpbWVvLmNvbVxcLyg/OmNoYW5uZWxzXFwvKD86XFx3K1xcLyk/fGdyb3Vwc1xcLyg/OlteXFwvXSopXFwvdmlkZW9zXFwvfGFsYnVtXFwvKD86XFxkKylcXC92aWRlb1xcL3x2aWRlb1xcL3wpKFxcZCspKD86W2EtekEtWjAtOV9cXC1dKyk/L2k7XG4gICAgdGhpcy5yZS5WSURFTyA9IC9cXC9bXlxcL10rXFwuKG1wNHxvZ2d8b2d2fG9nbXx3ZWJtfGF2aSlcXHM/JC9pO1xuXG4gICAgdGhpcy5fX2luaXRfXyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5lbGVtZW50cy5sZW5ndGg7IGkrKykge1xuICAgICAgICBjb25zdCBlbGVtZW50ID0gdGhpcy5lbGVtZW50c1tpXTtcblxuICAgICAgICBjb25zdCBsaW5rID0gZWxlbWVudC5nZXRBdHRyaWJ1dGUoJ2RhdGEteW91dHViZScpIHx8IGVsZW1lbnQuZ2V0QXR0cmlidXRlKCdkYXRhLXZiZycpO1xuICAgICAgICBjb25zdCB2aWRfZGF0YSA9IHRoaXMuZ2V0VmlkSUQobGluayk7XG5cbiAgICAgICAgaWYgKCF2aWRfZGF0YSkge1xuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG5cbiAgICAgICAgY29uc3QgdWlkID0gdGhpcy5nZW5lcmF0ZVVJRCh2aWRfZGF0YS5pZCk7XG5cbiAgICAgICAgaWYgKCF1aWQpIHtcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIHN3aXRjaCAodmlkX2RhdGEudHlwZSkge1xuICAgICAgICAgIGNhc2UgJ1lPVVRVQkUnOlxuICAgICAgICAgICAgY29uc3QgeWIgPSBuZXcgWW91dHViZUJhY2tncm91bmQoZWxlbWVudCwgcGFyYW1zLCB2aWRfZGF0YS5pZCwgdWlkKTtcbiAgICAgICAgICAgIHRoaXMuaW5kZXhbdWlkXSA9IHliO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgY2FzZSAnVklNRU8nOlxuICAgICAgICAgICAgY29uc3Qgdm0gPSBuZXcgVmltZW9CYWNrZ3JvdW5kKGVsZW1lbnQsIHBhcmFtcywgdmlkX2RhdGEuaWQsIHVpZCk7XG4gICAgICAgICAgICB0aGlzLmluZGV4W3VpZF0gPSB2bTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGNhc2UgJ1ZJREVPJzpcbiAgICAgICAgICAgIGNvbnN0IHZpZCA9IG5ldyBWaWRlb0JhY2tncm91bmQoZWxlbWVudCwgcGFyYW1zLCB2aWRfZGF0YSwgdWlkKTtcbiAgICAgICAgICAgIHRoaXMuaW5kZXhbdWlkXSA9IHZpZDtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHRoaXMuaW5pdFlUUGxheWVycygvKmZ1bmN0aW9uKCkge1xuICAgICAgICAvL1RPRE86IEZJWCFcbiAgICAgICAgaWYgKHBhcmFtcyAmJlxuICAgICAgICAgIChwYXJhbXMuaGFzT3duUHJvcGVydHkoJ2FjdGl2aXR5X3RpbWVvdXQnKVxuICAgICAgICAgICAgfHwgcGFyYW1zLmhhc093blByb3BlcnR5KCdpbmFjdGl2aXR5X3RpbWVvdXQnKSkpIHtcbiAgICAgICAgICB0aGlzLmFjdGl2aXR5X21vbml0b3IgPSBuZXcgQWN0aXZpdHlNb25pdG9yKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgc2VsZi5wbGF5VmlkZW9zKCk7XG4gICAgICAgICAgICB9LCBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgc2VsZi5wYXVzZVZpZGVvcygpO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHBhcmFtcyA/IHBhcmFtcy5hY3Rpdml0eV90aW1lb3V0IDogbnVsbCxcbiAgICAgICAgICAgIHBhcmFtcyA/IHBhcmFtcy5pbmFjdGl2aXR5X3RpbWVvdXQgOiBudWxsLFxuICAgICAgICAgICAgWydtb3VzZW1vdmUnLCAnc2Nyb2xsJ11cbiAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgICB9Ki8pO1xuICAgIH07XG5cbiAgICB0aGlzLl9faW5pdF9fKCk7XG4gIH1cblxuICBWaWRlb0JhY2tncm91bmRzLnByb3RvdHlwZS5nZXRWaWRJRCA9IGZ1bmN0aW9uIChsaW5rKSB7XG4gICAgaWYgKGxpbmsgIT09IHVuZGVmaW5lZCAmJiBsaW5rICE9PSBudWxsKSB7XG4gICAgICBmb3IgKGxldCBrIGluIHRoaXMucmUpIHtcbiAgICAgICAgY29uc3QgcHRzID0gbGluay5tYXRjaCh0aGlzLnJlW2tdKTtcblxuICAgICAgICBpZiAocHRzICYmIHB0cy5sZW5ndGgpIHtcbiAgICAgICAgICB0aGlzLnJlW2tdLmxhc3RJbmRleCA9IDA7XG4gICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGlkOiBwdHNbMV0sXG4gICAgICAgICAgICB0eXBlOiBrLFxuICAgICAgICAgICAgcmVnZXhfcHRzOiBwdHMsXG4gICAgICAgICAgICBsaW5rOiBsaW5rXG4gICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBudWxsO1xuICB9O1xuXG5cbiAgVmlkZW9CYWNrZ3JvdW5kcy5wcm90b3R5cGUuZ2VuZXJhdGVVSUQgPSBmdW5jdGlvbiAocHJlZikge1xuICAgIC8vaW5kZXggdGhlIGluc3RhbmNlXG4gICAgbGV0IHVpZCA9IHByZWYgKyctJysgZ2V0UmFuZG9tSW50SW5jbHVzaXZlKDAsIDk5OTkpO1xuICAgIHdoaWxlICh0aGlzLmluZGV4Lmhhc093blByb3BlcnR5KHVpZCkpIHtcbiAgICAgIHVpZCA9IHByZWYgKyctJysgZ2V0UmFuZG9tSW50SW5jbHVzaXZlKDAsIDk5OTkpO1xuICAgIH1cblxuICAgIHJldHVybiB1aWQ7XG4gIH07XG5cbiAgVmlkZW9CYWNrZ3JvdW5kcy5wcm90b3R5cGUucGF1c2VWaWRlb3MgPSBmdW5jdGlvbiAoKSB7XG4gICAgZm9yIChsZXQgayBpbiB0aGlzLmluZGV4KSB7XG4gICAgICB0aGlzLmluZGV4W2tdLnBhdXNlKCk7XG4gICAgfVxuICB9O1xuXG4gIFZpZGVvQmFja2dyb3VuZHMucHJvdG90eXBlLnBsYXlWaWRlb3MgPSBmdW5jdGlvbiAoKSB7XG4gICAgZm9yIChsZXQgayBpbiB0aGlzLmluZGV4KSB7XG4gICAgICB0aGlzLmluZGV4W2tdLnBsYXkoKTtcbiAgICB9XG4gIH07XG5cbiAgVmlkZW9CYWNrZ3JvdW5kcy5wcm90b3R5cGUuaW5pdFlUUGxheWVycyA9IGZ1bmN0aW9uIChjYWxsYmFjaykge1xuICAgIGNvbnN0IHNlbGYgPSB0aGlzO1xuXG4gICAgd2luZG93Lm9uWW91VHViZUlmcmFtZUFQSVJlYWR5ID0gZnVuY3Rpb24gKCkge1xuICAgICAgZm9yIChsZXQgayBpbiBzZWxmLmluZGV4KSB7XG4gICAgICAgIGlmIChzZWxmLmluZGV4W2tdIGluc3RhbmNlb2YgWW91dHViZUJhY2tncm91bmQpIHtcbiAgICAgICAgICBzZWxmLmluZGV4W2tdLmluaXRZVFBsYXllcigpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmIChjYWxsYmFjaykge1xuICAgICAgICBzZXRUaW1lb3V0KGNhbGxiYWNrLCAxMDApO1xuICAgICAgfVxuICAgIH07XG5cbiAgICBpZiAod2luZG93Lmhhc093blByb3BlcnR5KCdZVCcpICYmIHdpbmRvdy5ZVC5sb2FkZWQpIHtcbiAgICAgIHdpbmRvdy5vbllvdVR1YmVJZnJhbWVBUElSZWFkeSgpO1xuICAgIH1cbiAgfTtcblxuICBpZiAodHlwZW9mIGpRdWVyeSA9PSAnZnVuY3Rpb24nKSB7XG4gICAgKGZ1bmN0aW9uICgkKSB7XG4gICAgICAkLmZuLnlvdXR1YmVfYmFja2dyb3VuZCA9IGZ1bmN0aW9uIChwYXJhbXMpIHtcbiAgICAgICAgY29uc3QgJHRoaXMgPSAkKHRoaXMpO1xuICAgICAgICBuZXcgVmlkZW9CYWNrZ3JvdW5kcyh0aGlzLCBwYXJhbXMpO1xuICAgICAgICByZXR1cm4gJHRoaXM7XG4gICAgICB9O1xuICAgIH0pKGpRdWVyeSk7XG4gIH1cblxuICB3aW5kb3cuVmlkZW9CYWNrZ3JvdW5kcyA9IFZpZGVvQmFja2dyb3VuZHM7XG5cbn0pKCk7XG4iLCIvLyBUaGUgbW9kdWxlIGNhY2hlXG52YXIgX193ZWJwYWNrX21vZHVsZV9jYWNoZV9fID0ge307XG5cbi8vIFRoZSByZXF1aXJlIGZ1bmN0aW9uXG5mdW5jdGlvbiBfX3dlYnBhY2tfcmVxdWlyZV9fKG1vZHVsZUlkKSB7XG5cdC8vIENoZWNrIGlmIG1vZHVsZSBpcyBpbiBjYWNoZVxuXHR2YXIgY2FjaGVkTW9kdWxlID0gX193ZWJwYWNrX21vZHVsZV9jYWNoZV9fW21vZHVsZUlkXTtcblx0aWYgKGNhY2hlZE1vZHVsZSAhPT0gdW5kZWZpbmVkKSB7XG5cdFx0cmV0dXJuIGNhY2hlZE1vZHVsZS5leHBvcnRzO1xuXHR9XG5cdC8vIENyZWF0ZSBhIG5ldyBtb2R1bGUgKGFuZCBwdXQgaXQgaW50byB0aGUgY2FjaGUpXG5cdHZhciBtb2R1bGUgPSBfX3dlYnBhY2tfbW9kdWxlX2NhY2hlX19bbW9kdWxlSWRdID0ge1xuXHRcdC8vIG5vIG1vZHVsZS5pZCBuZWVkZWRcblx0XHQvLyBubyBtb2R1bGUubG9hZGVkIG5lZWRlZFxuXHRcdGV4cG9ydHM6IHt9XG5cdH07XG5cblx0Ly8gRXhlY3V0ZSB0aGUgbW9kdWxlIGZ1bmN0aW9uXG5cdF9fd2VicGFja19tb2R1bGVzX19bbW9kdWxlSWRdKG1vZHVsZSwgbW9kdWxlLmV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pO1xuXG5cdC8vIFJldHVybiB0aGUgZXhwb3J0cyBvZiB0aGUgbW9kdWxlXG5cdHJldHVybiBtb2R1bGUuZXhwb3J0cztcbn1cblxuIiwiLy8gZ2V0RGVmYXVsdEV4cG9ydCBmdW5jdGlvbiBmb3IgY29tcGF0aWJpbGl0eSB3aXRoIG5vbi1oYXJtb255IG1vZHVsZXNcbl9fd2VicGFja19yZXF1aXJlX18ubiA9IChtb2R1bGUpID0+IHtcblx0dmFyIGdldHRlciA9IG1vZHVsZSAmJiBtb2R1bGUuX19lc01vZHVsZSA/XG5cdFx0KCkgPT4gKG1vZHVsZVsnZGVmYXVsdCddKSA6XG5cdFx0KCkgPT4gKG1vZHVsZSk7XG5cdF9fd2VicGFja19yZXF1aXJlX18uZChnZXR0ZXIsIHsgYTogZ2V0dGVyIH0pO1xuXHRyZXR1cm4gZ2V0dGVyO1xufTsiLCIvLyBkZWZpbmUgZ2V0dGVyIGZ1bmN0aW9ucyBmb3IgaGFybW9ueSBleHBvcnRzXG5fX3dlYnBhY2tfcmVxdWlyZV9fLmQgPSAoZXhwb3J0cywgZGVmaW5pdGlvbikgPT4ge1xuXHRmb3IodmFyIGtleSBpbiBkZWZpbml0aW9uKSB7XG5cdFx0aWYoX193ZWJwYWNrX3JlcXVpcmVfXy5vKGRlZmluaXRpb24sIGtleSkgJiYgIV9fd2VicGFja19yZXF1aXJlX18ubyhleHBvcnRzLCBrZXkpKSB7XG5cdFx0XHRPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywga2V5LCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZGVmaW5pdGlvbltrZXldIH0pO1xuXHRcdH1cblx0fVxufTsiLCJfX3dlYnBhY2tfcmVxdWlyZV9fLm8gPSAob2JqLCBwcm9wKSA9PiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG9iaiwgcHJvcCkpIiwiLy8gZGVmaW5lIF9fZXNNb2R1bGUgb24gZXhwb3J0c1xuX193ZWJwYWNrX3JlcXVpcmVfXy5yID0gKGV4cG9ydHMpID0+IHtcblx0aWYodHlwZW9mIFN5bWJvbCAhPT0gJ3VuZGVmaW5lZCcgJiYgU3ltYm9sLnRvU3RyaW5nVGFnKSB7XG5cdFx0T2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFN5bWJvbC50b1N0cmluZ1RhZywgeyB2YWx1ZTogJ01vZHVsZScgfSk7XG5cdH1cblx0T2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsICdfX2VzTW9kdWxlJywgeyB2YWx1ZTogdHJ1ZSB9KTtcbn07IiwiLyoqXG4gKiBEbyBzb21lIGZhbmN5IFVJIHN0dWZmIGluIGEgcmF0aGVyIHVuZmFuY3kgd2F5LlxuICpcbiAqIEBhdXRob3IgRGFsZSBEYXZpZXMgPGRhbGVAZGFsZWRhdmllcy5jby51az5cbiAqIEBsaWNlbnNlIE1JVFxuICovXG5cbmltcG9ydCBNYWluIGZyb20gJy4vY2xhc3Nlcy9NYWluJztcbmltcG9ydCB2ZXJzaW9uIGZyb20gJy4uLy4uLy4uLy5qdW1wLXZlcnNpb24nO1xuaW1wb3J0ICd5b3V0dWJlLWJhY2tncm91bmQnO1xuXG5jb25zb2xlLmluZm8oYCVjXG4tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbiAgICAg4paI4paIIOKWiOKWiCAgICDilojilogg4paI4paI4paIICAgIOKWiOKWiOKWiCDilojilojilojilojilojilohcbiAgICAg4paI4paIIOKWiOKWiCAgICDilojilogg4paI4paI4paI4paIICDilojilojilojilogg4paI4paIICAg4paI4paIXG4gICAgIOKWiOKWiCDilojiloggICAg4paI4paIIOKWiOKWiCDilojilojilojilogg4paI4paIIOKWiOKWiOKWiOKWiOKWiOKWiFxu4paI4paIICAg4paI4paIIOKWiOKWiCAgICDilojilogg4paI4paIICDilojiloggIOKWiOKWiCDilojilohcbiDilojilojilojilojiloggICDilojilojilojilojilojiloggIOKWiOKWiCAgICAgIOKWiOKWiCDilojilohcblxuaHR0cHM6Ly9naXRodWIuY29tL2RhbGVkYXZpZXMvanVtcFxuXG4tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbiAgICAgSnVtcCAke3ZlcnNpb259XG5cbi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxuYCwgXCJmb250LWZhbWlseTptb25vc3BhY2VcIik7XG5cbmxldCBqdW1wYXBwID0gbmV3IE1haW4oKTtcbmp1bXBhcHAuaW5pdCgpO1xuXG5uZXcgVmlkZW9CYWNrZ3JvdW5kcygnW2RhdGEtdmJnXScpO1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9